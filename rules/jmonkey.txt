com.jme3.app.SettingsDialog#<init>(Lcom/jme3/system/AppSettings;Ljava/net/URL;Z)V
  source
    +c:"Settings source cannot be null".

com.jme3.system.NativeLibraryLoader#registerNativeLibrary(Ljava/lang/String;Lcom/jme3/system/Platform;Ljava/lang/String;Ljava/lang/String;)V
  path
    +d: The path inside the natives-jar or classpath corresponding to this library. Must be compatible with the platform argument.

com.jme3.system.NativeLibraryLoader#registerNativeLibrary(Ljava/lang/String;Lcom/jme3/system/Platform;Ljava/lang/String;)V
  path
    +d: The path inside the natives-jar or classpath corresponding to this library. Must be compatible with the platform argument.

com.jme3.system.NativeLibraryLoader#loadNativeLibrary(Ljava/lang/String;Z)V
  isRequired
    +c:The required native library '  '  is not available for your OS:.The required native library '   '  was not found in the classpath via '   '. Error message:.

com.jme3.system.JmeDesktopSystem#showSettingsDialog(Lcom/jme3/system/AppSettings;Z)Z
  sourceSettings
    +c:.

com.jme3.system.JmeDesktopSystem#newContext(Lcom/jme3/system/AppSettings;Lcom/jme3/system/JmeContext$Type;)Lcom/jme3/system/JmeContext;
  settings
    +c:Unrecognizable renderer specified:.

com.jme3.system.JmeDesktopSystem#newAudioRenderer(Lcom/jme3/system/AppSettings;)Lcom/jme3/audio/AudioRenderer;
  settings
    +c:Unrecognizable audio renderer specified:.

com.jme3.system.awt.AwtPanelsContext#setInputSource(Lcom/jme3/system/awt/AwtPanel;)V
  panel
    +c:.

com.jme3.system.awt.AwtPanel#postFrame(Lcom/jme3/texture/FrameBuffer;)V
  out
    +c:"Why did you change the output framebuffer?".

com.jme3.texture.plugins.AWTLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  info
    +c:The given image cannot be loaded.The extension      is not supported.

jme3tools.converters.ImageToAwt#convert(Ljava/awt/image/BufferedImage;Lcom/jme3/texture/Image$Format;Ljava/nio/ByteBuffer;)V
  format
    +c:Image format    is not supported.

jme3tools.converters.ImageToAwt#convert(Lcom/jme3/texture/Image;Lcom/jme3/texture/Image;)V
  output
    +c:.

com.jme3.asset.BlenderKey#setLoadGeneratedTextures(Z)V
  loadGeneratedTextures
    +d: <b>true</b> if generated textures should be loaded and <b>false</b> otherwise

com.jme3.asset.BlenderKey#setLoadUnlinkedAssets(Z)V
  loadUnlinkedAssets
    +d: <b>true</b> if unlinked assets should be loaded and <b>false</b> otherwise

com.jme3.asset.BlenderKey#setSkyGeneratedTextureSize(I)V
  skyGeneratedTextureSize
    +c:The texture size must be a positive value (the value given as a parameter:   )!.

com.jme3.asset.BlenderKey#setSkyGeneratedTextureShape(Lcom/jme3/asset/BlenderKey$SkyGeneratedTextureShape;)V
  skyGeneratedTextureShape
    +c:"The sky generated shape type cannot be null!".

com.jme3.scene.plugins.blender.BlenderContext#addLoadedFeatures(Ljava/lang/Long;Lcom/jme3/scene/plugins/blender/BlenderContext$LoadedDataType;Ljava/lang/Object;)V
  feature
    +c:"One of the given arguments is null!".

com.jme3.scene.plugins.blender.BlenderContext#getLoadedFeature(Ljava/lang/Long;Lcom/jme3/scene/plugins/blender/BlenderContext$LoadedDataType;)Ljava/lang/Object;
  loadedFeatureDataType
    +d: the type of data we want to retreive it can be either filled structure or already converted feature

com.jme3.scene.plugins.blender.BlenderContext#getBoneContext(Lcom/jme3/animation/Bone;)Lcom/jme3/scene/plugins/blender/animations/BoneContext;
  bone
    +c:Cannot find context for bone:.

com.jme3.scene.plugins.blender.BlenderContext#addMarker(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V
  feature
    +d: te scene's feature (can be node, material or texture or anything else)
  markerValue
    +c:"The marker's value cannot be null.".

com.jme3.scene.plugins.blender.animations.AnimationHelper#applyAnimations(Lcom/jme3/scene/Node;Lcom/jme3/asset/BlenderKey$AnimationMatchMethod;)V
  animationMatchMethod
    +d: the way animation should be matched with node

com.jme3.scene.plugins.blender.animations.AnimationHelper#applyAnimations(Lcom/jme3/scene/Node;Lcom/jme3/animation/Skeleton;Lcom/jme3/asset/BlenderKey$AnimationMatchMethod;)V
  animationMatchMethod
    +d: the way animation should be matched with skeleton

com.jme3.scene.plugins.blender.animations.AnimationHelper#getCurveType(Lcom/jme3/scene/plugins/blender/file/Structure;Lcom/jme3/scene/plugins/blender/BlenderContext;)I
  structure
    +d: the structure must contain the 'rna_path' field and 'array_index' field (the type is not important here)

com.jme3.scene.plugins.blender.constraints.ConstraintHelper#getTransform(Ljava/lang/Long;Ljava/lang/String;Lcom/jme3/scene/plugins/blender/constraints/ConstraintHelper$Space;)Lcom/jme3/math/Transform;
  space
    +c:Unknown space type:."Nodes can have only Local and World spaces applied!".Unknown space type:.

com.jme3.scene.plugins.blender.constraints.ConstraintHelper#applyTransform(Ljava/lang/Long;Ljava/lang/String;Lcom/jme3/scene/plugins/blender/constraints/ConstraintHelper$Space;Lcom/jme3/math/Transform;)V
  space
    +c:Invalid space type for target object:.Invalid space type for spatial object:.

com.jme3.scene.plugins.blender.curves.CurvesTemporalMesh#getValueAlongCurve(F)Lcom/jme3/math/Vector3f;
  alongRatio
    +d: the relative distance along the curve; should be a value between 0 and 1 inclusive; if the value exceeds the boundaries it is truncated to them

com.jme3.scene.plugins.blender.curves.BezierCurve#<init>(ILjava/util/List;IZ)V
  dimension
    +c:"The dimension of the curve should be 2 or 3!".

com.jme3.scene.plugins.blender.curves.BezierCurve#evaluate(II)D
  frame
    +c:
  valuePart
    +d: this param specifies wheather we should return the X, Y or Z part of the result value; it should have one of the following values: X_VALUE - the X factor of the result Y_VALUE - the Y factor of the result Z_VALUE - the Z factor of the result

com.jme3.scene.plugins.blender.file.DynamicArray#<init>null
  data
    +c:"The size of the table does not match the size of the given data!".

com.jme3.scene.plugins.blender.file.DynamicArray#get([I)Ljava/lang/Object;
  position
    +c:The table accepts     indexing number(s)!.

com.jme3.scene.plugins.blender.file.BlenderInputStream#alignPosition(I)V
  bytesAmount
    +c:"Alignment byte number shoulf be positivbe!".

com.jme3.scene.plugins.blender.file.Structure#fill(Lcom/jme3/scene/plugins/blender/file/BlenderInputStream;)V
  inputStream
    +d: the stream we read data from, its read cursor should be placed at the start position of the data for the structure

com.jme3.scene.plugins.blender.materials.MaterialHelper#hsvToRgb(FFF[F)V
  rgb
    +d: rgb result vector (should have 3 elements)

com.jme3.scene.plugins.blender.meshes.Edge#getOtherIndex(I)I
  index
    +c:Cannot give the other index for [  ] because this index does not exist in edge:.

com.jme3.scene.plugins.blender.meshes.Edge#shiftIndexes(ILcom/jme3/scene/plugins/blender/meshes/IndexesLoop$IndexPredicate;)V
  predicate
    +d: the predicate that verifies which indexes should be shifted; if null then all will be shifted

com.jme3.scene.plugins.blender.meshes.Point#shiftIndexes(ILcom/jme3/scene/plugins/blender/meshes/IndexesLoop$IndexPredicate;)V
  predicate
    +d: the predicate that verifies which indexes should be shifted; if null then all will be shifted

com.jme3.scene.plugins.blender.meshes.IndexesLoop#shiftIndexes(ILcom/jme3/scene/plugins/blender/meshes/IndexesLoop$IndexPredicate;)V
  predicate
    +d: the predicate that verifies which indexes should be shifted; if null then all will be shifted

com.jme3.scene.plugins.blender.meshes.IndexesLoop#findPath(Ljava/lang/Integer;Ljava/lang/Integer;Ljava/util/List;)V
  result
    +c:"Indexes of face have infinite loops!".

com.jme3.scene.plugins.blender.meshes.Face#<init>([Ljava/lang/Integer;ZILjava/util/Map;Ljava/util/List;Lcom/jme3/scene/plugins/blender/meshes/TemporalMesh;)V
  temporalMesh
    +c:

com.jme3.scene.plugins.blender.meshes.Face#setTemporalMesh(Lcom/jme3/scene/plugins/blender/meshes/TemporalMesh;)V
  temporalMesh
    +c:"No temporal mesh for the face given!".

com.jme3.scene.plugins.blender.textures.ColorBand#<init>(ILjava/util/List;Ljava/util/List;I)V
  ipoType
    +c:Unknown colorband interpolation type:.
  colors
    +c:"The amount of colorband's colors must be at least 1.".
  positions
    +c:"The size of positions and colors list should be equal!".
  resultSize
    +c:Invalid position value:   ! Should be from range: [0,   ]!.

com.jme3.scene.plugins.blender.textures.UVCoordinatesGenerator#generateUVCoordinatesFor2DTexture(Lcom/jme3/scene/Mesh;Lcom/jme3/scene/plugins/blender/textures/UVCoordinatesGenerator$UVCoordinatesType;Lcom/jme3/scene/plugins/blender/textures/UVProjectionGenerator$UVProjectionType;Lcom/jme3/scene/Geometry;)Ljava/util/List;
  texco
    +c:Unknown texture coordinates value:.
  projection
    +c:Unknown projection type:.
  geometries
    +c:

com.jme3.scene.plugins.blender.textures.UVCoordinatesGenerator#generateUVCoordinatesFor3DTexture(Lcom/jme3/scene/Mesh;Lcom/jme3/scene/plugins/blender/textures/UVCoordinatesGenerator$UVCoordinatesType;[I[Lcom/jme3/scene/Geometry;)Ljava/util/List;
  texco
    +c:Unknown texture coordinates value:.
  geometries
    +c:

com.jme3.scene.plugins.blender.textures.UVCoordinatesGenerator#isTextureCoordinateTypeSupported(Lcom/jme3/scene/plugins/blender/textures/UVCoordinatesGenerator$UVCoordinatesType;)Z
  texco
    +c:Unknown texture coordinates value:.

com.jme3.scene.plugins.blender.textures.UVCoordinatesGenerator#getBoundingBox([Lcom/jme3/scene/Geometry;)Lcom/jme3/bounding/BoundingBox;
  geometries
    +c:

com.jme3.scene.plugins.blender.textures.UVCoordinatesGenerator#getBoundingSphere([Lcom/jme3/scene/Geometry;)Lcom/jme3/bounding/BoundingSphere;
  geometries
    +c:

com.jme3.scene.plugins.blender.textures.UVCoordinatesGenerator#getBoundingTube([Lcom/jme3/scene/Geometry;)Lcom/jme3/scene/plugins/blender/textures/UVCoordinatesGenerator$BoundingTube;
  geometries
    +c:

com.jme3.scene.plugins.blender.textures.TextureHelper#getTexture(Lcom/jme3/scene/plugins/blender/file/Structure;Lcom/jme3/scene/plugins/blender/file/Structure;Lcom/jme3/scene/plugins/blender/BlenderContext;)Lcom/jme3/texture/Texture;
  textureStructure
    +c:Unknown texture type:    type  for texture:.
  blenderContext
    +c:Unknown mipmap generation method:.

com.jme3.scene.plugins.blender.textures.TextureHelper#getSubimage(Lcom/jme3/texture/Image;IIII)Lcom/jme3/texture/Image;
  image
    +c:"Only flat images are allowed for subimage operation!".
  maxX
    +c:"Minimum Y value is higher than maximum Y value!".
  maxY
    +c:"Minimum Y value is higher than maximum Y value!".

com.jme3.scene.plugins.blender.textures.TextureHelper#loadImageFromFile(Ljava/lang/String;ILcom/jme3/scene/plugins/blender/BlenderContext;)Lcom/jme3/texture/Texture;
  blenderContext
    +c:Unknown mipmap generation method:.

com.jme3.scene.plugins.blender.textures.ImageUtils#merge(Lcom/jme3/texture/Image;Lcom/jme3/texture/Image;)V
  sourceImage
    +c:"The given images should have the same depth to merge them!"."The given images should have the same width to merge them!"."The given images should have the same height to merge them!".

com.jme3.scene.plugins.blender.textures.ImageUtils#mix(Lcom/jme3/texture/Image;Lcom/jme3/texture/Image;)V
  sourceImage
    +c:"The given images should have the same depth to merge them!"."The given images should have the same width to merge them!"."The given images should have the same height to merge them!".

com.jme3.scene.plugins.blender.textures.CombinedTexture#add(Lcom/jme3/texture/Texture;Lcom/jme3/scene/plugins/blender/textures/blending/TextureBlender;IILcom/jme3/scene/plugins/blender/file/Structure;Ljava/lang/String;Lcom/jme3/scene/plugins/blender/BlenderContext;)V
  texture
    +c:Unsupported texture type:   null.

com.jme3.scene.plugins.blender.textures.blending.TextureBlenderLuminance#getTinAndAlpha(Ljava/nio/ByteBuffer;Lcom/jme3/texture/Image$Format;Z[F)V
  imageFormat
    +c:Invalid image format type for Luminance texture blender:.

com.jme3.scene.plugins.blender.textures.blending.TextureBlenderLuminance#blendPixel([F[F[FFFILcom/jme3/scene/plugins/blender/BlenderContext;)V
  blendtype
    +c:Unknown blend type:.

com.jme3.scene.plugins.blender.textures.generating.TextureGeneratorFactory#createTextureGenerator(I)Lcom/jme3/scene/plugins/blender/textures/generating/TextureGenerator;
  generatedTexture
    +c:Unknown generated texture type:.

com.jme3.scene.plugins.blender.textures.io.PixelIOFactory#getPixelIO(Lcom/jme3/texture/Image$Format;)Lcom/jme3/scene/plugins/blender/textures/io/PixelInputOutput;
  format
    +c:Unsupported image format for IO operations:.

com.jme3.bullet.control.BetterCharacterControl#setDuckedFactor(F)V
  factor
    +d: the factor by which the height should be multiplied when ducking (&ge;0, &le;1)

com.jme3.bullet.util.CollisionShapeFactory#createMeshShape(Lcom/jme3/scene/Spatial;)Lcom/jme3/bullet/collision/shapes/CollisionShape;
  spatial
    +c:"Supplied spatial must either be Node or Geometry!".

com.jme3.bullet.util.CollisionShapeFactory#createDynamicMeshShape(Lcom/jme3/scene/Spatial;)Lcom/jme3/bullet/collision/shapes/CollisionShape;
  spatial
    +c:"Supplied spatial must either be Node or Geometry!".

com.jme3.bullet.util.CollisionShapeFactory#createBoxShape(Lcom/jme3/scene/Spatial;)Lcom/jme3/bullet/collision/shapes/CollisionShape;
  spatial
    +c:"Supplied spatial must either be Node or Geometry!".

com.jme3.anim.AnimComposer#removeAnimClip(Lcom/jme3/anim/AnimClip;)V
  anim
    +c:Given animation does not exist  in this AnimControl.

com.jme3.anim.AnimComposer#setCurrentAction(Ljava/lang/String;Ljava/lang/String;)Lcom/jme3/anim/tween/action/Action;
  layerName
    +c:Unknown layer.

com.jme3.anim.AnimComposer#makeAction(Ljava/lang/String;)Lcom/jme3/anim/tween/action/Action;
  name
    +c:Cannot find clip named.

com.jme3.anim.ArmatureMask#findJoint(Lcom/jme3/anim/Armature;Ljava/lang/String;)Lcom/jme3/anim/Joint;
  jointName
    +c:Cannot find joint.

com.jme3.anim.MorphTrack#<init>(Lcom/jme3/scene/Geometry;[F[FI)V
  times
    +c:
  weights
    +c:

com.jme3.anim.MorphTrack#setTimes([F)V
  times
    +c:"TransformTrack with no keyframes!".

com.jme3.anim.MorphTrack#setKeyframes([F[F)V
  times
    +c:"MorphTrack doesn't have any time for key frames, please call setTimes first".
  weights
    +c:

com.jme3.anim.SkinningControl#<init>(Lcom/jme3/anim/Armature;)V
  armature
    +c:"armature cannot be null".

com.jme3.anim.SkinningControl#getAttachmentsNode(Ljava/lang/String;)Lcom/jme3/scene/Node;
  jointName
    +c:

com.jme3.anim.TransformTrack#<init>(Lcom/jme3/anim/util/HasLocalTransform;[F[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Quaternion;[Lcom/jme3/math/Vector3f;)V
  times
    +c:
  translations
    +c:
  rotations
    +c:
  scales
    +c:

com.jme3.anim.TransformTrack#setTimes([F)V
  times
    +c:"TransformTrack with no keyframes!".

com.jme3.anim.TransformTrack#setKeyframesTranslation([Lcom/jme3/math/Vector3f;)V
  translations
    +c:"TransformTrack with no translation keyframes!"..

com.jme3.anim.TransformTrack#setKeyframesScale([Lcom/jme3/math/Vector3f;)V
  scales
    +c:"TransformTrack with no scale keyframes!"..

com.jme3.anim.TransformTrack#setKeyframesRotation([Lcom/jme3/math/Quaternion;)V
  rotations
    +c:"TransformTrack with no rotation keyframes!"..

com.jme3.anim.TransformTrack#setKeyframes([F[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Quaternion;[Lcom/jme3/math/Vector3f;)V
  times
    +c:
  translations
    +c:
  rotations
    +c:
  scales
    +c:

com.jme3.anim.util.Primitives#wrap(Ljava/lang/Class;)Ljava/lang/Class;
  type
    +c:"type is null".

com.jme3.animation.SkeletonControl#<init>(Lcom/jme3/animation/Skeleton;)V
  skeleton
    +c:"skeleton cannot be null".

com.jme3.animation.SkeletonControl#getAttachmentsNode(Ljava/lang/String;)Lcom/jme3/scene/Node;
  boneName
    +c:

com.jme3.animation.Bone#<init>(Ljava/lang/String;)V
  name
    +c:"Name cannot be null".

com.jme3.animation.BoneTrack#<init>(I[F[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Quaternion;)V
  times
    +c:
  translations
    +c:
  rotations
    +c:

com.jme3.animation.BoneTrack#<init>(I[F[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Quaternion;[Lcom/jme3/math/Vector3f;)V
  times
    +c:
  translations
    +c:
  rotations
    +c:
  scales
    +c:

com.jme3.animation.BoneTrack#setKeyframes([F[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Quaternion;)V
  times
    +c:"BoneTrack with no keyframes!".
  translations
    +c:.
  rotations
    +c:.

com.jme3.animation.BoneTrack#setKeyframes([F[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Quaternion;[Lcom/jme3/math/Vector3f;)V
  times
    +c:
  translations
    +c:
  rotations
    +c:
  scales
    +c:

com.jme3.animation.AnimChannel#setAnim(Ljava/lang/String;F)V
  name
    +c:"name cannot be null".Cannot find animation named: '  '.
  blendTime
    +c:"blendTime cannot be less than zero".

com.jme3.animation.SpatialTrack#<init>([F[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Quaternion;[Lcom/jme3/math/Vector3f;)V
  times
    +c:
  translations
    +c:
  rotations
    +c:
  scales
    +c:

com.jme3.animation.SpatialTrack#setKeyframes([F[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Quaternion;[Lcom/jme3/math/Vector3f;)V
  times
    +c:"BoneTrack with no keyframes!".
  translations
    +c:
  rotations
    +c:
  scales
    +c:

com.jme3.animation.AnimationFactory#getTranslationForFrame(I)Lcom/jme3/math/Vector3f;
  keyFrameIndex
    +c:keyFrameIndex must be between 0 and    (received   ).

com.jme3.animation.AnimationFactory#getScaleForFrame(I)Lcom/jme3/math/Vector3f;
  keyFrameIndex
    +c:keyFrameIndex must be between 0 and    (received   ).

com.jme3.animation.AnimationFactory#getRotationForFrame(I)Lcom/jme3/animation/AnimationFactory$Rotation;
  keyFrameIndex
    +c:keyFrameIndex must be between 0 and    (received   ).

com.jme3.animation.AnimControl#setAnimations(Ljava/util/HashMap;)V
  animations
    +d: Set the animations that this AnimControl will be capable of playing. The animations should be compatible with the skeleton given in the constructor.

com.jme3.animation.AnimControl#removeAnim(Lcom/jme3/animation/Animation;)V
  anim
    +c:Given animation does not exist  in this AnimControl.

com.jme3.animation.AnimControl#addListener(Lcom/jme3/animation/AnimEventListener;)V
  listener
    +c:The given listener is already  registed at this AnimControl.

com.jme3.animation.AnimControl#removeListener(Lcom/jme3/animation/AnimEventListener;)V
  listener
    +c:The given listener is not  registed at this AnimControl.

com.jme3.animation.AnimControl#getAnimationLength(Ljava/lang/String;)F
  name
    +c:The animation    does not exist in this AnimControl.

com.jme3.app.StatsAppState#initialize(Lcom/jme3/app/state/AppStateManager;Lcom/jme3/app/Application;)V
  app
    +c:

com.jme3.app.LegacyApplication#setAssetManager(Lcom/jme3/asset/AssetManager;)V
  assetManager
    +c:Can only set asset manager  before initialization.

com.jme3.app.ChaseCameraAppState#setDragToRotate(Z)V
  dragToRotate
    +d: When true, the user must hold the mouse button and drag over the screen to rotate the camera, and the cursor is visible until dragged. Otherwise, the cursor is invisible at all times and holding the mouse button is not needed to rotate the camera. This feature is disabled by default.

com.jme3.asset.DesktopAssetManager#getFromCache(Lcom/jme3/asset/AssetKey;)Ljava/lang/Object;
  key
    +c:Key    specifies no cache.

com.jme3.asset.DesktopAssetManager#addToCache(Lcom/jme3/asset/AssetKey;Ljava/lang/Object;)V
  key
    +c:Key    specifies no cache.

com.jme3.asset.DesktopAssetManager#deleteFromCache(Lcom/jme3/asset/AssetKey;)Z
  key
    +c:Key    specifies no cache.

com.jme3.asset.DesktopAssetManager#loadLocatedAsset(Lcom/jme3/asset/AssetKey;Lcom/jme3/asset/AssetInfo;Lcom/jme3/asset/AssetProcessor;Lcom/jme3/asset/cache/AssetCache;)Ljava/lang/Object;
  key
    +c:An exception has occured while loading asset:.Error occured while loading asset \  \ using.

com.jme3.asset.DesktopAssetManager#registerAndCloneSmartAsset(Lcom/jme3/asset/AssetKey;Ljava/lang/Object;Lcom/jme3/asset/AssetProcessor;Lcom/jme3/asset/cache/AssetCache;)Ljava/lang/Object;
  proc
    +d: The processor which will generate the clone, cannot be null
    +c:Asset implements  CloneableSmartAsset but doesn't  have processor to handle cloning.
  cache
    +d: The cache to register the clone with, cannot be null.
    +c:Asset implements  CloneableSmartAsset but doesn't have cache or  was not cloned.

com.jme3.asset.DesktopAssetManager#loadAssetFromStream(Lcom/jme3/asset/AssetKey;Ljava/io/InputStream;)Ljava/lang/Object;
  key
    +c:"key cannot be null".

com.jme3.asset.DesktopAssetManager#loadAsset(Lcom/jme3/asset/AssetKey;)Ljava/lang/Object;
  key
    +c:"key cannot be null"..

com.jme3.audio.LowPassFilter#setHighFreqVolume(F)V
  highFreqVolume
    +c:"High freq volume must be between 0 and 1".

com.jme3.audio.LowPassFilter#setVolume(F)V
  volume
    +c:"Volume must be between 0 and 1".

com.jme3.audio.AudioNode#setPitch(F)V
  pitch
    +c:"Pitch must be between 0.5 and 2.0".

com.jme3.audio.AudioNode#setVolume(F)V
  volume
    +c:"Volume cannot be negative".

com.jme3.audio.AudioNode#setTimeOffset(F)V
  timeOffset
    +c:"Time offset cannot be negative".

com.jme3.audio.AudioNode#setMaxDistance(F)V
  maxDistance
    +c:"Max distance cannot be negative".

com.jme3.audio.AudioNode#setRefDistance(F)V
  refDistance
    +c:"Reference distance cannot be negative".

com.jme3.audio.AudioStream#updateData(Ljava/io/InputStream;F)V
  in
    +c:"Data already set!".

com.jme3.audio.Environment#<init>([F)V
  e
    +c:"Not an EAX preset".

com.jme3.audio.openal.ALAudioRenderer#updateSourceParam(Lcom/jme3/audio/AudioSource;Lcom/jme3/audio/AudioParam;)V
  src
    +c:.

com.jme3.audio.openal.ALAudioRenderer#playSourceInstance(Lcom/jme3/audio/AudioSource;)V
  src
    +c:Cannot play instances  of audio streams. Use play() instead.

com.jme3.audio.openal.ALAudioRenderer#pauseSource(Lcom/jme3/audio/AudioSource;)V
  src
    +c:.

com.jme3.bounding.BoundingBox#intersectsBoundingBox(Lcom/jme3/bounding/BoundingBox;)Z
  bb
    +c:.

com.jme3.bounding.BoundingBox#collideWith(Lcom/jme3/collision/Collidable;Lcom/jme3/collision/CollisionResults;)I
  other
    +c:With:.

com.jme3.bounding.BoundingBox#collideWith(Lcom/jme3/collision/Collidable;)I
  other
    +c:With:.

com.jme3.bounding.BoundingBox#setXExtent(F)V
  xExtent
    +c:.

com.jme3.bounding.BoundingBox#setYExtent(F)V
  yExtent
    +c:.

com.jme3.bounding.BoundingBox#setZExtent(F)V
  zExtent
    +c:.

com.jme3.bounding.BoundingSphere#collideWith(Lcom/jme3/collision/Collidable;Lcom/jme3/collision/CollisionResults;)I
  other
    +c:.

com.jme3.bounding.BoundingSphere#collideWith(Lcom/jme3/collision/Collidable;)I
  other
    +c:.

com.jme3.cinematic.Cinematic#bindCamera(Ljava/lang/String;Lcom/jme3/renderer/Camera;)Lcom/jme3/scene/CameraNode;
  cameraName
    +c:Camera    is already binded to this cinematic.

com.jme3.collision.CollisionResults#getCollision(I)Lcom/jme3/collision/CollisionResult;
  index
    +c:Index:   , Size: 0.

com.jme3.collision.CollisionResults#getCollisionDirect(I)Lcom/jme3/collision/CollisionResult;
  index
    +c:Index:   , Size: 0.

com.jme3.collision.bih.BIHTree#<init>(Lcom/jme3/scene/Mesh;I)V
  mesh
    +c:"Mesh cannot be null".
  maxTrisPerNode
    +c:"maxTrisPerNode cannot be less than 1".

com.jme3.collision.bih.BIHTree#collideWithBoundingVolume(Lcom/jme3/bounding/BoundingVolume;Lcom/jme3/math/Matrix4f;Lcom/jme3/collision/CollisionResults;)I
  bv
    +c:BoundingVolume:.

com.jme3.collision.bih.BIHTree#collideWith(Lcom/jme3/collision/Collidable;Lcom/jme3/math/Matrix4f;Lcom/jme3/bounding/BoundingVolume;Lcom/jme3/collision/CollisionResults;)I
  other
    +c:Collidable:.

com.jme3.effect.ParticleEmitter#setMeshType(Lcom/jme3/effect/ParticleMesh$Type;)V
  meshType
    +c:Unrecognized particle type:.

com.jme3.effect.ParticleEmitter#setFaceNormal(Lcom/jme3/math/Vector3f;)V
  faceNormal
    +d: The normals particles should face, or null if particles should face the camera.

com.jme3.effect.ParticleEmitter#setRandomAngle(Z)V
  randomAngle
    +d: if every particle spawned should have a random facing angle.

com.jme3.effect.ParticleEmitter#setSelectRandomImage(Z)V
  selectRandomImage
    +d: True if every particle spawned should get a random image.

com.jme3.effect.ParticleEmitter#setFacingVelocity(Z)V
  followVelocity
    +d: True if particles spawned should face their velocity.

com.jme3.effect.ParticleEmitter#setVelocityVariation(F)V
  variation
    +d: Set the variation by which the initial velocity of the particle is determined. variation should be a value from 0 to 1, where 0 means particles are to spawn with exactly the velocity given in ParticleEmitter#setStartVel(com.jme3.math.Vector3f) , and 1 means particles are to spawn with a completely random velocity.

com.jme3.effect.shapes.EmitterSphereShape#<init>(Lcom/jme3/math/Vector3f;F)V
  center
    +c:"center cannot be null".
  radius
    +c:"Radius must be greater than 0".

com.jme3.effect.shapes.EmitterBoxShape#<init>(Lcom/jme3/math/Vector3f;Lcom/jme3/math/Vector3f;)V
  min
    +c:"min or max cannot be null".

com.jme3.environment.LightProbeFactory#getDebugGui(Lcom/jme3/asset/AssetManager;Lcom/jme3/light/LightProbe;)Lcom/jme3/scene/Node;
  probe
    +c:"This EnvProbe is not ready yet, try to test isReady()".

com.jme3.environment.generation.PrefilteredEnvMapFaceGenerator#generatePrefilteredEnvMap(Lcom/jme3/texture/TextureCubeMap;ILcom/jme3/environment/util/EnvMapUtils$FixSeamsMethod;Lcom/jme3/texture/TextureCubeMap;)Lcom/jme3/texture/TextureCubeMap;
  sourceEnvMap
    +c:The input cube map must have at least    mip maps.

com.jme3.environment.util.EnvMapUtils#getSolidAngleAndVector(IIIILcom/jme3/math/Vector3f;Lcom/jme3/environment/util/EnvMapUtils$FixSeamsMethod;)F
  store
    +c:"the store parameter must not be null".

com.jme3.environment.util.EnvMapUtils#getSphericalHarmonicsCoefficents(Lcom/jme3/texture/TextureCubeMap;Lcom/jme3/environment/util/EnvMapUtils$FixSeamsMethod;)[Lcom/jme3/math/Vector3f;
  cubeMap
    +c:"The cube map must contain Efficient data, if you rendered the cube map on the GPU please use renderer.readFrameBuffer, to create a CPU image".

com.jme3.environment.util.CubeMapWrapper#initMipMaps(I)V
  nbMipMaps
    +c:Max mip map number for a    x    cube map is.

com.jme3.export.SavableClassUtil#getSavedSavableVersion(Ljava/lang/Object;Ljava/lang/Class;[II)I
  desiredClass
    +c:does not extend    !.
  formatVersion
    +c:cannot access version of     because it doesn't implement Savable.

com.jme3.font.BitmapFont#merge(Lcom/jme3/font/BitmapFont;)V
  newFont
    +d: Style must be assigned to this.

com.jme3.font.BitmapCharacterSet#merge(Lcom/jme3/font/BitmapCharacterSet;)V
  styleSet
    +d: Style must be assigned to this.
    +c:"Only support same font size".

com.jme3.font.BitmapText#setAlignment(Lcom/jme3/font/BitmapFont$Align;)V
  align
    +c:"Bound is not set".

com.jme3.font.BitmapText#setVerticalAlignment(Lcom/jme3/font/BitmapFont$VAlign;)V
  align
    +c:"Bound is not set".

com.jme3.input.InputManager#<init>(Lcom/jme3/input/MouseInput;Lcom/jme3/input/KeyInput;Lcom/jme3/input/JoyInput;Lcom/jme3/input/TouchInput;)V
  mouse
    +c:"Mouse or keyboard cannot be null".

com.jme3.input.InputManager#deleteTrigger(Ljava/lang/String;Lcom/jme3/input/controls/Trigger;)V
  mappingName
    +c:Cannot find mapping:.

com.jme3.input.ChaseCamera#setDragToRotate(Z)V
  dragToRotate
    +d: When true, the user must hold the mouse button and drag over the screen to rotate the camera, and the cursor is visible until dragged. Otherwise, the cursor is invisible at all times and holding the mouse button is not needed to rotate the camera. This feature is disabled by default.

com.jme3.input.controls.JoyButtonTrigger#joyButtonHash(II)I
  joyButton
    +c:.

com.jme3.input.controls.JoyAxisTrigger#joyAxisHash(IIZ)I
  joyAxis
    +c:.

com.jme3.input.controls.MouseButtonTrigger#<init>(I)V
  mouseButton
    +c:"Mouse Button cannot be negative".

com.jme3.input.controls.MouseButtonTrigger#mouseButtonHash(I)I
  mouseButton
    +c:.

com.jme3.input.controls.MouseAxisTrigger#<init>(IZ)V
  mouseAxis
    +c:"Mouse Axis must be between 0 and 2".

com.jme3.input.controls.MouseAxisTrigger#mouseAxisHash(IZ)I
  mouseAxis
    +c:.

com.jme3.input.controls.KeyTrigger#keyHash(I)I
  keyCode
    +c:.

com.jme3.input.controls.TouchTrigger#touchHash(I)I
  keyCode
    +c:.

com.jme3.light.SpotLight#setSpotRange(F)V
  spotRange
    +c:"SpotLight range cannot be negative".

com.jme3.light.SpotLight#setSpotInnerAngle(F)V
  spotInnerAngle
    +c:"spot angle must be between 0 and pi/2".

com.jme3.light.SpotLight#setSpotOuterAngle(F)V
  spotOuterAngle
    +c:"spot angle must be between 0 and pi/2".

com.jme3.light.PointLight#setRadius(F)V
  radius
    +c:"Light radius cannot be negative".

com.jme3.light.LightList#remove(I)V
  index
    +c:.

com.jme3.light.LightList#get(I)Lcom/jme3/light/Light;
  num
    +c:.

com.jme3.material.MatParamTexture#setValue(Ljava/lang/Object;)V
  value
    +c:"value must be a texture object".

com.jme3.material.RenderState#setLineWidth(F)V
  lineWidth
    +c:"lineWidth must be greater than or equal to 1.0".

com.jme3.material.Material#<init>(Lcom/jme3/material/MaterialDef;)V
  def
    +c:"Material definition cannot be null".

com.jme3.material.Material#setParam(Ljava/lang/String;Lcom/jme3/shader/VarType;Ljava/lang/Object;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#clearParam(Ljava/lang/String;)V
  name
    +c:

com.jme3.material.Material#setTextureParam(Ljava/lang/String;Lcom/jme3/shader/VarType;Lcom/jme3/texture/Texture;)V
  name
    +c:
  value
    +c:.

com.jme3.material.Material#setTexture(Ljava/lang/String;Lcom/jme3/texture/Texture;)V
  name
    +c:
  value
    +c:Unknown texture type:.

com.jme3.material.Material#setMatrix4(Ljava/lang/String;Lcom/jme3/math/Matrix4f;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setBoolean(Ljava/lang/String;Z)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setFloat(Ljava/lang/String;F)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setFloat(Ljava/lang/String;Ljava/lang/Float;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setInt(Ljava/lang/String;I)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setColor(Ljava/lang/String;Lcom/jme3/math/ColorRGBA;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setUniformBufferObject(Ljava/lang/String;Lcom/jme3/shader/BufferObject;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setShaderStorageBufferObject(Ljava/lang/String;Lcom/jme3/shader/BufferObject;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setVector2(Ljava/lang/String;Lcom/jme3/math/Vector2f;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setVector3(Ljava/lang/String;Lcom/jme3/math/Vector3f;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#setVector4(Ljava/lang/String;Lcom/jme3/math/Vector4f;)V
  name
    +c:
  value
    +c:

com.jme3.material.Material#selectTechnique(Ljava/lang/String;Lcom/jme3/renderer/RenderManager;)V
  name
    +c:The requested technique %s is not available on material %s.No technique '%s' on material  '%s' is supported by the video hardware.  The capabilities %s are required.

com.jme3.math.FastMath#convertFloatToHalf(F)S
  flt
    +c:"NaN to half conversion not supported!".

com.jme3.math.Ray#collideWith(Lcom/jme3/collision/Collidable;Lcom/jme3/collision/CollisionResults;)I
  other
    +c:.

com.jme3.math.Ray#setDirection(Lcom/jme3/math/Vector3f;)V
  direction
    +c:.

com.jme3.math.Spline#<init>(Lcom/jme3/math/Spline$SplineType;[Lcom/jme3/math/Vector3f;FZ)V
  splineType
    +c:"To create NURBS spline use: 'public Spline(Vector3f[] controlPoints, float[] weights, float[] nurbKnots)' constructor!".
  controlPoints
    +d: an array of vector to use as control points of the spline If the type of the curve is Bezier curve the control points should be provided in the appropriate way. Each point 'p' describing control position in the scene should be surrounded by two handler points. This applies to every point except for the border points of the curve, who should have only one handle point. The pattern should be as follows: P0 - H0  :  H1 - P1 - H1  :  ...  :  Hn - Pn n is the amount of 'P' - points.

com.jme3.math.Spline#<init>(Lcom/jme3/math/Spline$SplineType;Ljava/util/List;FZ)V
  splineType
    +c:"To create NURBS spline use: 'public Spline(Vector3f[] controlPoints, float[] weights, float[] nurbKnots)' constructor!".
  controlPoints
    +d: a list of vector to use as control points of the spline If the type of the curve is Bezier curve the control points should be provided in the appropriate way. Each point 'p' describing control position in the scene should be surrounded by two handler points. This applies to every point except for the border points of the curve, who should have only one handle point. The pattern should be as follows: P0 - H0  :  H1 - P1 - H1  :  ...  :  Hn - Pn n is the amount of 'P' - points.

com.jme3.math.Spline#<init>(Ljava/util/List;Ljava/util/List;)V
  nurbKnots
    +c:"The knots values cannot decrease!".

com.jme3.math.Matrix3f#get([FZ)V
  data
    +d: The array to return the data into. This array can be 9 or 16 floats in size. Only the upper 3x3 are assigned to in the case of a 16 element array.
    +c:"Array size must be 9 or 16 in Matrix3f.get().".

com.jme3.math.Matrix3f#getColumn(I)Lcom/jme3/math/Vector3f;
  i
    +c:

com.jme3.math.Matrix3f#getColumn(ILcom/jme3/math/Vector3f;)Lcom/jme3/math/Vector3f;
  i
    +c:Invalid column index.

com.jme3.math.Matrix3f#getRow(I)Lcom/jme3/math/Vector3f;
  i
    +c:

com.jme3.math.Matrix3f#getRow(ILcom/jme3/math/Vector3f;)Lcom/jme3/math/Vector3f;
  i
    +c:Invalid row index.

com.jme3.math.Matrix3f#setColumn(ILcom/jme3/math/Vector3f;)Lcom/jme3/math/Matrix3f;
  i
    +c:Invalid column index.

com.jme3.math.Matrix3f#setRow(ILcom/jme3/math/Vector3f;)Lcom/jme3/math/Matrix3f;
  i
    +c:Invalid row index.

com.jme3.math.Matrix3f#set([[F)Lcom/jme3/math/Matrix3f;
  matrix
    +c:"Array must be of size 9.".

com.jme3.math.Matrix3f#set([F)Lcom/jme3/math/Matrix3f;
  matrix
    +c:

com.jme3.math.Matrix3f#set([FZ)Lcom/jme3/math/Matrix3f;
  matrix
    +c:"Array must be of size 9.".

com.jme3.math.Matrix4f#get([F)V
  matrix
    +c:

com.jme3.math.Matrix4f#get([FZ)V
  matrix
    +c:"Array must be of size 16.".

com.jme3.math.Matrix4f#getColumn(I)[F
  i
    +c:

com.jme3.math.Matrix4f#getColumn(I[F)[F
  i
    +c:Invalid column index.

com.jme3.math.Matrix4f#setColumn(I[F)V
  i
    +c:Invalid column index.

com.jme3.math.Matrix4f#set([[F)V
  matrix
    +c:"Array must be of size 16.".

com.jme3.math.Matrix4f#set([F)V
  matrix
    +c:

com.jme3.math.Matrix4f#set([FZ)V
  matrix
    +c:"Array must be of size 16.".

com.jme3.math.Matrix4f#toFloatBuffer(Z)Ljava/nio/FloatBuffer;
  columnMajor
    +d: if true, this buffer should be filled with column major data, otherwise it will be filled row major.

com.jme3.math.Matrix4f#fillFloatBuffer(Ljava/nio/FloatBuffer;)Ljava/nio/FloatBuffer;
  fb
    +d: the buffer to fill, must be correct size

com.jme3.math.Matrix4f#fillFloatBuffer(Ljava/nio/FloatBuffer;Z)Ljava/nio/FloatBuffer;
  columnMajor
    +d: if true, this buffer should be filled with column major data, otherwise it will be filled row major.

com.jme3.math.Matrix4f#readFloatBuffer(Ljava/nio/FloatBuffer;)Lcom/jme3/math/Matrix4f;
  fb
    +d: the buffer to read from, must be correct size

com.jme3.math.Matrix4f#readFloatBuffer(Ljava/nio/FloatBuffer;Z)Lcom/jme3/math/Matrix4f;
  fb
    +d: the buffer to read from, must be correct size
  columnMajor
    +d: if true, this buffer should be filled with column major data, otherwise it will be filled row major.

com.jme3.math.Matrix4f#setTranslation([F)V
  translation
    +c:"Translation size must be 3.".

com.jme3.math.Matrix4f#setInverseTranslation([F)V
  translation
    +c:"Translation size must be 3.".

com.jme3.math.Matrix4f#setInverseRotationRadians([F)V
  angles
    +c:"Angles must be of size 3.".

com.jme3.math.Matrix4f#setInverseRotationDegrees([F)V
  angles
    +c:"Angles must be of size 3.".

com.jme3.math.Matrix4f#inverseTranslateVect([F)V
  vec
    +c:"vec must be of size 3.".

com.jme3.math.Plane#<init>(Lcom/jme3/math/Vector3f;F)V
  normal
    +c:"normal cannot be null".

com.jme3.math.Plane#setNormal(Lcom/jme3/math/Vector3f;)V
  normal
    +c:"normal cannot be null".

com.jme3.math.CurveAndSurfaceMath#interpolateNurbs(FLcom/jme3/math/Spline;Lcom/jme3/math/Vector3f;)V
  nurbSpline
    +c:"Given spline is not of a NURB type!".

com.jme3.math.Quaternion#fromAngles([F)Lcom/jme3/math/Quaternion;
  angles
    +c:"Angles array must have three elements".

com.jme3.math.Quaternion#toAngles([F)[F
  angles
    +d: the float[] in which the angles should be stored, or null if you want a new float[] to be created
    +c:"Angles array must have three elements".

com.jme3.math.Quaternion#getRotationColumn(ILcom/jme3/math/Vector3f;)Lcom/jme3/math/Vector3f;
  i
    +c:Invalid column index.

com.jme3.math.Quaternion#fromAxes([Lcom/jme3/math/Vector3f;)Lcom/jme3/math/Quaternion;
  axis
    +c:"Axis array must have three elements".

com.jme3.opencl.ProgramCache#loadFromCache(Ljava/lang/String;Ljava/lang/String;)Lcom/jme3/opencl/Program;
  buildArgs
    +d: additional build arguments, can be  null

com.jme3.post.FilterPostProcessor#addFilter(Lcom/jme3/post/Filter;)V
  filter
    +c:"Filter cannot be null.".

com.jme3.post.FilterPostProcessor#removeFilter(Lcom/jme3/post/Filter;)V
  filter
    +c:"Filter cannot be null.".

com.jme3.post.FilterPostProcessor#setNumSamples(I)V
  numSamples
    +c:"numSamples must be > 0".

com.jme3.renderer.Statistics#onShaderUse(Lcom/jme3/shader/Shader;Z)V
  shader
    +c:.

com.jme3.renderer.Statistics#onTextureUse(Lcom/jme3/texture/Image;Z)V
  image
    +c:.

com.jme3.renderer.Statistics#onFrameBufferUse(Lcom/jme3/texture/FrameBuffer;Z)V
  fb
    +c:.

com.jme3.renderer.ViewPort#<init>(Ljava/lang/String;Lcom/jme3/renderer/Camera;)V
  cam
    +d: The camera through which the viewport is rendered. The camera cannot be swapped to a different one after creating the viewport.

com.jme3.renderer.ViewPort#addProcessor(Lcom/jme3/post/SceneProcessor;)V
  processor
    +c:"Processor cannot be null.".

com.jme3.renderer.ViewPort#removeProcessor(Lcom/jme3/post/SceneProcessor;)V
  processor
    +c:"Processor cannot be null.".

com.jme3.renderer.ViewPort#attachScene(Lcom/jme3/scene/Spatial;)V
  scene
    +c:"Scene cannot be null.".

com.jme3.renderer.ViewPort#detachScene(Lcom/jme3/scene/Spatial;)V
  scene
    +c:"Scene cannot be null.".

com.jme3.renderer.RenderManager#preloadScene(Lcom/jme3/scene/Spatial;)V
  scene
    +c:

com.jme3.renderer.RenderManager#renderScene(Lcom/jme3/scene/Spatial;Lcom/jme3/renderer/ViewPort;)V
  scene
    +c:
  vp
    +c:

com.jme3.renderer.RenderManager#renderViewPortRaw(Lcom/jme3/renderer/ViewPort;)V
  vp
    +c:

com.jme3.renderer.RenderManager#renderViewPort(Lcom/jme3/renderer/ViewPort;F)V
  vp
    +c:

com.jme3.renderer.opengl.GLTracer#printBuffer(Ljava/nio/Buffer;)V
  buffer
    +c:.

com.jme3.renderer.opengl.GLRenderer#setDefaultAnisotropicFilter(I)V
  level
    +c:"level cannot be less than 1".

com.jme3.renderer.opengl.GLRenderer#applyRenderState(Lcom/jme3/material/RenderState;)V
  state
    +c:Unrecognized face cull mode:.Unrecognized blend mode:.

com.jme3.renderer.opengl.GLRenderer#updateUniform(Lcom/jme3/shader/Shader;Lcom/jme3/shader/Uniform;)V
  shader
    +c:.
  uniform
    +c:.Unsupported uniform type:.

com.jme3.renderer.opengl.GLRenderer#updateShaderBufferBlock(Lcom/jme3/shader/Shader;Lcom/jme3/shader/ShaderBufferBlock;)V
  shader
    +c:.
  bufferBlock
    +c:.

com.jme3.renderer.opengl.GLRenderer#updateShaderUniforms(Lcom/jme3/shader/Shader;)V
  shader
    +c:

com.jme3.renderer.opengl.GLRenderer#updateShaderBufferBlocks(Lcom/jme3/shader/Shader;)V
  shader
    +c:

com.jme3.renderer.opengl.GLRenderer#convertShaderType(Lcom/jme3/shader/Shader$ShaderType;)I
  type
    +c:"Unrecognized shader type.".

com.jme3.renderer.opengl.GLRenderer#updateShaderSourceData(Lcom/jme3/shader/Shader$ShaderSource;)V
  source
    +c:compile error in:   \n.compile error in:   \nerror: <not provided>.

com.jme3.renderer.opengl.GLRenderer#updateShaderData(Lcom/jme3/shader/Shader;)V
  shader
    +c:Shader failed to link, shader:  \n.Shader failed to link, shader:  \ninfo: <not provided>.

com.jme3.renderer.opengl.GLRenderer#setShader(Lcom/jme3/shader/Shader;)V
  shader
    +c:"Shader cannot be null"..

com.jme3.renderer.opengl.GLRenderer#updateFrameBufferAttachment(Lcom/jme3/texture/FrameBuffer;Lcom/jme3/texture/FrameBuffer$RenderBuffer;)V
  fb
    +c:

com.jme3.renderer.opengl.GLRenderer#updateFrameBuffer(Lcom/jme3/texture/FrameBuffer;)V
  fb
    +c:The framebuffer:   \nDoesn't have any color/depth buffers.

com.jme3.renderer.opengl.GLRenderer#getFrameBufferSamplePositions(Lcom/jme3/texture/FrameBuffer;)[Lcom/jme3/math/Vector2f;
  fb
    +c:"Framebuffer must be multisampled".

com.jme3.renderer.opengl.GLRenderer#setMainFrameBufferOverride(Lcom/jme3/texture/FrameBuffer;)V
  fb
    +c:

com.jme3.renderer.opengl.GLRenderer#setReadDrawBuffers(Lcom/jme3/texture/FrameBuffer;)V
  fb
    +c:Framebuffer has more color  attachments than are supported  by the video hardware!.Framebuffer has more  multi targets than are supported  by the video hardware!.

com.jme3.renderer.opengl.GLRenderer#setFrameBuffer(Lcom/jme3/texture/FrameBuffer;)V
  fb
    +c:..

com.jme3.renderer.opengl.GLRenderer#readFrameBuffer(Lcom/jme3/texture/FrameBuffer;Ljava/nio/ByteBuffer;)V
  fb
    +c:

com.jme3.renderer.opengl.GLRenderer#readFrameBufferWithFormat(Lcom/jme3/texture/FrameBuffer;Ljava/nio/ByteBuffer;Lcom/jme3/texture/Image$Format;)V
  fb
    +c:

com.jme3.renderer.opengl.GLRenderer#updateTexImageData(Lcom/jme3/texture/Image;Lcom/jme3/texture/Texture$Type;IZ)V
  img
    +c:"Multisample textures do not support mipmaps"."Depth textures are not supported by the video hardware".Cannot upload cubemap   . The maximum supported cubemap resolution is."Cubemaps must have square dimensions".Cannot upload texture   . The maximum supported texture resolution is.
  type
    +c:

com.jme3.renderer.opengl.GLRenderer#setTexture(ILcom/jme3/texture/Texture;)V
  tex
    +c:

com.jme3.renderer.opengl.GLRenderer#modifyTexture(Lcom/jme3/texture/Texture;Lcom/jme3/texture/Image;II)V
  tex
    +c:

com.jme3.renderer.opengl.GLRenderer#updateBufferData(Lcom/jme3/scene/VertexBuffer;)V
  vb
    +c:"Unknown buffer format.".

com.jme3.renderer.opengl.GLRenderer#updateBufferData(Lcom/jme3/shader/BufferObject;)V
  bo
    +c:

com.jme3.renderer.opengl.GLRenderer#setVertexAttrib(Lcom/jme3/scene/VertexBuffer;Lcom/jme3/scene/VertexBuffer;)V
  vb
    +c:"Index buffers not allowed to be set to vertex attrib".Number of components in multi-slot  buffers must be divisible by 4.
  idb
    +c:

com.jme3.renderer.opengl.GLRenderer#setVertexAttrib(Lcom/jme3/scene/VertexBuffer;)V
  vb
    +c:

com.jme3.renderer.opengl.GLRenderer#drawTriangleArray(Lcom/jme3/scene/Mesh$Mode;II)V
  mode
    +c:

com.jme3.renderer.opengl.GLRenderer#drawTriangleList(Lcom/jme3/scene/VertexBuffer;Lcom/jme3/scene/Mesh;I)V
  indexBuf
    +c:"Only index buffers are allowed as triangle lists.".Unexpected format for index buffer:.

com.jme3.renderer.opengl.GLRenderer#convertElementMode(Lcom/jme3/scene/Mesh$Mode;)I
  mode
    +c:Unrecognized mesh mode:.

com.jme3.renderer.opengl.GLRenderer#renderMesh(Lcom/jme3/scene/Mesh;II[Lcom/jme3/scene/VertexBuffer;)V
  count
    +c:"Mesh instancing is not supported by the video hardware".

com.jme3.renderer.queue.RenderQueue#setGeometryComparator(Lcom/jme3/renderer/queue/RenderQueue$Bucket;Lcom/jme3/renderer/queue/GeometryComparator;)V
  bucket
    +c:Unknown bucket type:.

com.jme3.renderer.queue.RenderQueue#getGeometryComparator(Lcom/jme3/renderer/queue/RenderQueue$Bucket;)Lcom/jme3/renderer/queue/GeometryComparator;
  bucket
    +c:Unknown bucket type:.

com.jme3.renderer.queue.RenderQueue#addToQueue(Lcom/jme3/scene/Geometry;Lcom/jme3/renderer/queue/RenderQueue$Bucket;)V
  bucket
    +c:Unknown bucket type:.

com.jme3.renderer.queue.RenderQueue#renderShadowQueue(Lcom/jme3/renderer/queue/GeometryList;Lcom/jme3/renderer/RenderManager;Lcom/jme3/renderer/Camera;Z)V
  list
    +c:

com.jme3.renderer.queue.RenderQueue#isQueueEmpty(Lcom/jme3/renderer/queue/RenderQueue$Bucket;)Z
  bucket
    +c:Unsupported bucket type:.

com.jme3.renderer.queue.RenderQueue#renderQueue(Lcom/jme3/renderer/queue/RenderQueue$Bucket;Lcom/jme3/renderer/RenderManager;Lcom/jme3/renderer/Camera;)V
  bucket
    +c:

com.jme3.renderer.queue.RenderQueue#renderQueue(Lcom/jme3/renderer/queue/RenderQueue$Bucket;Lcom/jme3/renderer/RenderManager;Lcom/jme3/renderer/Camera;Z)V
  bucket
    +c:Unsupported bucket type:.

com.jme3.scene.VertexBuffer#setupData(Lcom/jme3/scene/VertexBuffer$Usage;ILcom/jme3/scene/VertexBuffer$Format;Ljava/nio/Buffer;)V
  usage
    +c:
  components
    +c:"components must be between 1 and 4".
  format
    +c:
  data
    +c:"None of the arguments can be null"."VertexBuffer data cannot be read-only.".

com.jme3.scene.VertexBuffer#updateData(Ljava/nio/Buffer;)V
  data
    +c:"VertexBuffer data cannot be read-only.".

com.jme3.scene.VertexBuffer#copyElement(ILcom/jme3/scene/VertexBuffer;I)V
  outVb
    +c:

com.jme3.scene.VertexBuffer#copyElements(ILcom/jme3/scene/VertexBuffer;II)V
  outVb
    +c:"Buffer format mismatch. Cannot copy".

com.jme3.scene.VertexBuffer#createBuffer(Lcom/jme3/scene/VertexBuffer$Format;II)Ljava/nio/Buffer;
  format
    +c:Unrecoginized buffer format:.
  components
    +c:"Num components must be between 1 and 4".

com.jme3.scene.Geometry#<init>(Ljava/lang/String;Lcom/jme3/scene/Mesh;)V
  mesh
    +c:"mesh cannot be null".

com.jme3.scene.Geometry#setLodLevel(I)V
  lod
    +c:LOD level is out of range:.

com.jme3.scene.Geometry#setMesh(Lcom/jme3/scene/Mesh;)V
  mesh
    +c:.

com.jme3.scene.SimpleBatchNode#attachChild(Lcom/jme3/scene/Spatial;)I
  child
    +c:"BatchNode is BatchMode.Simple only support child of type Geometry, use BatchMode.Complex to use a complex structure".

com.jme3.scene.Node#attachChildAt(Lcom/jme3/scene/Spatial;I)I
  child
    +c:.

com.jme3.scene.Node#detachChild(Lcom/jme3/scene/Spatial;)I
  child
    +c:.

com.jme3.scene.Node#detachChildNamed(Ljava/lang/String;)I
  childName
    +c:.

com.jme3.scene.Mesh#setLineWidth(F)V
  lineWidth
    +c:"lineWidth must be greater than or equal to 1.0".

com.jme3.scene.Mesh#getTriangleCount(I)I
  lod
    +c:"LOD level cannot be < 0".LOD level    does not exist!."There are no LOD levels on the mesh!".

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer;)V
  vb
    +c:Buffer type already set:.

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;ILcom/jme3/scene/VertexBuffer$Format;Ljava/nio/Buffer;)V
  components
    +c:The buffer already set  is incompatible with the given parameters.

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;ILjava/nio/FloatBuffer;)V
  components
    +d: Number of components on the vertex buffer, should be between 1 and 4.
    +c:

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;I[F)V
  components
    +c:

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;ILjava/nio/IntBuffer;)V
  components
    +c:

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;I[I)V
  components
    +c:

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;ILjava/nio/ShortBuffer;)V
  components
    +c:

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;I[B)V
  components
    +c:

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;ILjava/nio/ByteBuffer;)V
  components
    +c:

com.jme3.scene.Mesh#setBuffer(Lcom/jme3/scene/VertexBuffer$Type;I[S)V
  components
    +c:

com.jme3.scene.UserData#<init>(BLjava/lang/Object;)V
  type
    +d: Type of data, should be between 0 and 8.
    +c:.

com.jme3.scene.UserData#getObjectType(Ljava/lang/Object;)B
  type
    +c:Unsupported type:.

com.jme3.scene.control.LodControl#setSpatial(Lcom/jme3/scene/Spatial;)V
  spatial
    +c:"LodControl can only be attached to Geometry!".

com.jme3.scene.instancing.InstancedGeometry#setMaxNumInstances(I)V
  maxNumInstances
    +c:"maxNumInstances must be 1 or higher".

com.jme3.scene.instancing.InstancedGeometry#addInstance(Lcom/jme3/scene/Geometry;)V
  geometry
    +c:"geometry cannot be null".

com.jme3.scene.mesh.VirtualIndexBuffer#<init>(ILcom/jme3/scene/Mesh$Mode;)V
  meshMode
    +c:.

com.jme3.scene.shape.Sphere#updateGeometry(IIF)V
  zSamples
    +c:"zSamples cannot be smaller than 3".

com.jme3.scene.shape.Sphere#updateGeometry(IIFZZ)V
  zSamples
    +c:"zSamples cannot be smaller than 3".

com.jme3.scene.shape.Cylinder#updateGeometry(IIFFFZZ)V
  axisSamples
    +c:"Cylinders must have at least 2 axis samples and 3 radial samples, and positive dimensions.".

com.jme3.scene.shape.Surface#validateInputData(Ljava/util/List;[Ljava/util/List;II)V
  controlPoints
    +c:"The amount of 'U' control points is invalid!".
  nurbKnots
    +c:"Nurb surface should have two rows of knots!"."The knots' values cannot decrease!".
  uSegments
    +c:"U segments amount should be positive!".
  vSegments
    +c:"V segments amount cannot be negative!".

com.jme3.scene.shape.Dome#<init>(IIF)V
  planes
    +d: The number of planes along the Z-axis. Must be >= 2. Influences how round the arch of the dome is.

com.jme3.scene.shape.Dome#<init>(Lcom/jme3/math/Vector3f;IIF)V
  planes
    +d: The number of planes along the Z-axis. Must be >= 2. Influences how round the arch of the dome is.

com.jme3.scene.shape.Dome#<init>(Lcom/jme3/math/Vector3f;IIFZ)V
  planes
    +d: The number of planes along the Z-axis. Must be >= 2. Influences how round the arch of the dome is.

com.jme3.shader.ShaderNodeVariable#<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
  nameSpace
    +d: the nameSpace (can be the name of the shaderNode or Global,Attr,MatParam,WorldParam)

com.jme3.shader.ShaderNodeVariable#<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
  nameSpace
    +d:    the nameSpace (can be the name of the shaderNode or Global,Attr,MatParam,WorldParam)

com.jme3.shader.ShaderNodeVariable#<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
  nameSpace
    +d: the nameSpace (can be the name of the shaderNode or Global,Attr,MatParam,WorldParam)

com.jme3.shader.Uniform#setValue(Lcom/jme3/shader/VarType;Ljava/lang/Object;)V
  type
    +c:Expected a      value!.
  value
    +c:for uniform   : value cannot be null.Cannot instanciate param of class.

com.jme3.shader.BufferObject#getVarTypeByValue(Ljava/lang/Object;)Lcom/jme3/shader/VarType;
  value
    +c:Can't calculate a var type for the empty collection value[  ].Can't calculate a var type for the value.

com.jme3.shader.BufferObject#declareField(Ljava/lang/String;Lcom/jme3/shader/VarType;)V
  name
    +c:The field    is already declared.

com.jme3.shader.BufferObject#setFieldValue(Ljava/lang/String;Ljava/lang/Object;)V
  name
    +c:
  value
    +c:

com.jme3.shader.BufferObject#getFieldValue(Ljava/lang/String;)Ljava/lang/Object;
  name
    +c:Unknown a field with the name.

com.jme3.shader.BufferObject#computeData(I)Ljava/nio/ByteBuffer;
  maxSize
    +c:The estimated size(    ) of this BO is bigger than  maximum available size.

com.jme3.shader.BufferObject#estimateSize(Lcom/jme3/shader/BufferObjectField;)I
  field
    +c:The type of BO field     doesn't support.

com.jme3.shader.BufferObject#estimateArray(Ljava/lang/Object;I)I
  value
    +c:Unexpected value.

com.jme3.shader.BufferObject#writeField(Lcom/jme3/shader/BufferObjectField;Ljava/nio/ByteBuffer;)V
  field
    +c:The type of BO field     doesn't support.

com.jme3.shader.BufferObject#deleteObject(Ljava/lang/Object;)V
  rendererObject
    +c:This bo can't be deleted from.

com.jme3.shader.DefineList#<init>(I)V
  numValues
    +c:"numValues must be between 0 and 64".

com.jme3.shader.DefineList#isSet(I)Z
  id
    +c:

com.jme3.shader.DefineList#unset(I)V
  id
    +c:

com.jme3.shader.DefineList#set(II)V
  id
    +c:

com.jme3.shader.DefineList#set(IF)V
  id
    +c:

com.jme3.shader.DefineList#set(IZ)V
  id
    +c:

com.jme3.shader.DefineList#set(ILcom/jme3/shader/VarType;Ljava/lang/Object;)V
  id
    +c:

com.jme3.shader.Glsl100ShaderGenerator#appendOutput(Ljava/lang/StringBuilder;Ljava/lang/String;Lcom/jme3/shader/ShaderNodeVariable;)V
  globalOutputName
    +d: the name of the global output (can be gl_Position or gl_FragColor etc...).

com.jme3.shader.Glsl100ShaderGenerator#declareVarying(Ljava/lang/StringBuilder;Lcom/jme3/shader/ShaderNodeVariable;Z)V
  input
    +d: a boolean set to true if the this varying is an input. this in not used in this implementation but can be used in overriding implementation

com.jme3.shader.Shader#getUniform(Ljava/lang/String;)Lcom/jme3/shader/Uniform;
  name
    +c:.

com.jme3.shader.Shader#getBufferBlock(Ljava/lang/String;)Lcom/jme3/shader/ShaderBufferBlock;
  name
    +c:.

com.jme3.shader.ShaderBufferBlock#setBufferObject(Lcom/jme3/shader/BufferObject;)V
  bufferObject
    +c:for storage block   : storageData cannot be null.

com.jme3.shadow.PssmShadowRenderer#setFilterMode(Lcom/jme3/shadow/PssmShadowRenderer$FilterMode;)V
  filterMode
    +c:.

com.jme3.shadow.PssmShadowRenderer#setCompareMode(Lcom/jme3/shadow/PssmShadowRenderer$CompareMode;)V
  compareMode
    +c:.

com.jme3.shadow.DirectionalLightShadowRenderer#init(II)V
  nbSplits
    +c:Number of splits must be between 1 and 4. Given value :.

com.jme3.system.AppSettings#setOpenCLPlatformChooser(Ljava/lang/Class;)V
  chooser
    +d: the class of the chooser, must have a default constructor

com.jme3.texture.Image#<init>(Lcom/jme3/texture/Image$Format;IIILjava/util/ArrayList;[ILcom/jme3/texture/image/ColorSpace;)V
  format
    +c:

com.jme3.texture.Image#<init>(Lcom/jme3/texture/Image$Format;IILjava/nio/ByteBuffer;[ILcom/jme3/texture/image/ColorSpace;)V
  format
    +c:

com.jme3.texture.Image#setMultiSamples(I)V
  multiSamples
    +c:"multiSamples must be > 0".

com.jme3.texture.Image#setData(ILjava/nio/ByteBuffer;)V
  index
    +c:"index must be greater than or equal to 0.".

com.jme3.texture.Image#setFormat(Lcom/jme3/texture/Image$Format;)V
  format
    +c:"format may not be null.".

com.jme3.texture.TextureArray#getWrap(Lcom/jme3/texture/Texture$WrapAxis;)Lcom/jme3/texture/Texture$WrapMode;
  axis
    +c:invalid WrapAxis:.

com.jme3.texture.TextureArray#setWrap(Lcom/jme3/texture/Texture$WrapAxis;Lcom/jme3/texture/Texture$WrapMode;)V
  axis
    +c:"axis can not be null."."Not applicable for 2D textures".
  mode
    +c:"mode can not be null.".

com.jme3.texture.TextureArray#setWrap(Lcom/jme3/texture/Texture$WrapMode;)V
  mode
    +c:"mode can not be null.".

com.jme3.texture.Texture2D#setWrap(Lcom/jme3/texture/Texture$WrapAxis;Lcom/jme3/texture/Texture$WrapMode;)V
  axis
    +c:"axis can not be null."."Not applicable for 2D textures".
  mode
    +c:"mode can not be null.".

com.jme3.texture.Texture2D#setWrap(Lcom/jme3/texture/Texture$WrapMode;)V
  mode
    +c:"mode can not be null.".

com.jme3.texture.Texture2D#getWrap(Lcom/jme3/texture/Texture$WrapAxis;)Lcom/jme3/texture/Texture$WrapMode;
  axis
    +c:invalid WrapAxis:.

com.jme3.texture.FrameBuffer#<init>(III)V
  width
    +c:"FrameBuffer must have valid size.".

com.jme3.texture.FrameBuffer#setDepthBuffer(Lcom/jme3/texture/Image$Format;)V
  format
    +c:"Depth buffer format must be depth.".

com.jme3.texture.FrameBuffer#setColorBuffer(Lcom/jme3/texture/Image$Format;)V
  format
    +c:"Color buffer format must be color/luminance.".

com.jme3.texture.FrameBuffer#setTargetIndex(I)V
  index
    +c:"Target index must be between 0 and 16".The target at    is not set!.

com.jme3.texture.FrameBuffer#setColorTexture(Lcom/jme3/texture/Texture2D;)V
  tex
    +c:

com.jme3.texture.FrameBuffer#setColorTexture(Lcom/jme3/texture/TextureArray;I)V
  tex
    +c:

com.jme3.texture.FrameBuffer#setColorTexture(Lcom/jme3/texture/TextureCubeMap;Lcom/jme3/texture/TextureCubeMap$Face;)V
  tex
    +c:

com.jme3.texture.FrameBuffer#addColorBuffer(Lcom/jme3/texture/Image$Format;)V
  format
    +c:"Color buffer format must be color/luminance.".

com.jme3.texture.FrameBuffer#addColorTexture(Lcom/jme3/texture/Texture2D;)V
  tex
    +c:

com.jme3.texture.FrameBuffer#addColorTexture(Lcom/jme3/texture/TextureArray;I)V
  tex
    +c:

com.jme3.texture.FrameBuffer#addColorTexture(Lcom/jme3/texture/TextureCubeMap;Lcom/jme3/texture/TextureCubeMap$Face;)V
  tex
    +c:

com.jme3.texture.FrameBuffer#setDepthTexture(Lcom/jme3/texture/Texture2D;)V
  tex
    +c:

com.jme3.texture.FrameBuffer#setDepthTexture(Lcom/jme3/texture/TextureArray;I)V
  tex
    +c:

com.jme3.texture.FrameBuffer#setSrgb(Z)V
  srgb
    +d: If the framebuffer color values should be stored in sRGB color space.

com.jme3.texture.TextureCubeMap#setWrap(Lcom/jme3/texture/Texture$WrapAxis;Lcom/jme3/texture/Texture$WrapMode;)V
  axis
    +c:"axis can not be null.".
  mode
    +c:"mode can not be null.".

com.jme3.texture.TextureCubeMap#setWrap(Lcom/jme3/texture/Texture$WrapMode;)V
  mode
    +c:"mode can not be null.".

com.jme3.texture.TextureCubeMap#getWrap(Lcom/jme3/texture/Texture$WrapAxis;)Lcom/jme3/texture/Texture$WrapMode;
  axis
    +c:invalid WrapAxis:.

com.jme3.texture.Texture3D#setWrap(Lcom/jme3/texture/Texture$WrapAxis;Lcom/jme3/texture/Texture$WrapMode;)V
  axis
    +c:"axis can not be null.".
  mode
    +c:"mode can not be null.".

com.jme3.texture.Texture3D#setWrap(Lcom/jme3/texture/Texture$WrapMode;)V
  mode
    +c:"mode can not be null.".

com.jme3.texture.Texture3D#getWrap(Lcom/jme3/texture/Texture$WrapAxis;)Lcom/jme3/texture/Texture$WrapMode;
  axis
    +c:invalid WrapAxis:.

com.jme3.texture.image.DefaultImageRaster#rangeCheck(II)V
  x
    +c:x and y must be inside the image dimensions:  ,    in:  ,.

com.jme3.texture.image.DefaultImageRaster#<init>(Lcom/jme3/texture/Image;IIZ)V
  mipMapLevel
    +c:Cannot create image raster for mipmap level #  .  Image only has     mipmap levels.

com.jme3.texture.image.MipMapImageRaster#rangeCheck(II)V
  x
    +c:"x and y must be inside the image dimensions".

com.jme3.texture.image.MipMapImageRaster#<init>(Lcom/jme3/texture/Image;I)V
  image
    +c:"Image must have MipMapSizes initialized.".

com.jme3.texture.image.MipMapImageRaster#setMipLevel(I)V
  mipLevel
    +c:Mip level must be between 0 and.

com.jme3.util.BufferUtils#clone(Ljava/nio/Buffer;)Ljava/nio/Buffer;
  buf
    +c:.

com.jme3.util.BufferUtils#clone(Ljava/nio/DoubleBuffer;)Ljava/nio/DoubleBuffer;
  buf
    +c:

com.jme3.util.BufferUtils#clone(Ljava/nio/FloatBuffer;)Ljava/nio/FloatBuffer;
  buf
    +c:

com.jme3.util.BufferUtils#clone(Ljava/nio/IntBuffer;)Ljava/nio/IntBuffer;
  buf
    +c:

com.jme3.util.BufferUtils#clone(Ljava/nio/ByteBuffer;)Ljava/nio/ByteBuffer;
  buf
    +c:

com.jme3.util.BufferUtils#clone(Ljava/nio/ShortBuffer;)Ljava/nio/ShortBuffer;
  buf
    +c:

com.jme3.util.SkyFactory#createSky(Lcom/jme3/asset/AssetManager;Lcom/jme3/texture/Texture;Lcom/jme3/math/Vector3f;Z)Lcom/jme3/scene/Spatial;
  texture
    +c:

com.jme3.util.SkyFactory#createSky(Lcom/jme3/asset/AssetManager;Lcom/jme3/texture/Texture;Lcom/jme3/math/Vector3f;Lcom/jme3/util/SkyFactory$EnvMapType;)Lcom/jme3/scene/Spatial;
  texture
    +c:

com.jme3.util.SkyFactory#createSky(Lcom/jme3/asset/AssetManager;Lcom/jme3/texture/Texture;Lcom/jme3/math/Vector3f;ZI)Lcom/jme3/scene/Spatial;
  texture
    +c:
  sphereRadius
    +d: the sky sphere's radius: for the sky to be visible, its radius must fall between the near and far planes of the camera's frustum

com.jme3.util.SkyFactory#createSky(Lcom/jme3/asset/AssetManager;Lcom/jme3/texture/Texture;Lcom/jme3/math/Vector3f;Lcom/jme3/util/SkyFactory$EnvMapType;F)Lcom/jme3/scene/Spatial;
  texture
    +c:"texture cannot be null".
  sphereRadius
    +d: the sky sphere's radius: for the sky to be visible, its radius must fall between the near and far planes of the camera's frustum

com.jme3.util.SkyFactory#createSky(Lcom/jme3/asset/AssetManager;Lcom/jme3/texture/Texture;Z)Lcom/jme3/scene/Spatial;
  texture
    +c:

com.jme3.util.SkyFactory#createSky(Lcom/jme3/asset/AssetManager;Lcom/jme3/texture/Texture;Lcom/jme3/util/SkyFactory$EnvMapType;)Lcom/jme3/scene/Spatial;
  texture
    +c:

com.jme3.util.SkyFactory#createSky(Lcom/jme3/asset/AssetManager;Lcom/jme3/texture/Texture;Lcom/jme3/texture/Texture;Lcom/jme3/texture/Texture;Lcom/jme3/texture/Texture;Lcom/jme3/texture/Texture;Lcom/jme3/texture/Texture;Lcom/jme3/math/Vector3f;F)Lcom/jme3/scene/Spatial;
  sphereRadius
    +d: the sky sphere's radius: for the sky to be visible, its radius must fall between the near and far planes of the camera's frustum

com.jme3.util.ListMap#remove(Ljava/lang/Object;)Ljava/lang/Object;
  key
    +c:

com.jme3.util.TangentBinormalGenerator#generate(Lcom/jme3/scene/Mesh;ZZ)V
  mesh
    +c:"The given mesh has no normal data!".is not supported.

com.jme3.util.TangentBinormalGenerator#processTriangles(Lcom/jme3/scene/Mesh;[I[Lcom/jme3/math/Vector3f;[Lcom/jme3/math/Vector2f;Z)Ljava/util/List;
  mesh
    +c:Can only generate tangents for  meshes with texture coordinates.

com.jme3.util.TangentBinormalGenerator#bulkPut(Lcom/jme3/scene/VertexBuffer$Format;Ljava/nio/Buffer;Ljava/nio/Buffer;)V
  format
    +c:Unrecoginized buffer format:.

com.jme3.util.TangentBinormalGenerator#putValue(Lcom/jme3/scene/VertexBuffer$Format;Ljava/nio/Buffer;Ljava/nio/Buffer;I)V
  format
    +c:Unrecoginized buffer format:.

com.jme3.util.TangentBinormalGenerator#setToleranceAngle(F)V
  angle
    +c:"The angle must be between 0 and 179 degrees.".

com.jme3.util.NativeObjectManager#registerObject(Lcom/jme3/util/NativeObject;)V
  obj
    +c:"object id must be greater than zero".

com.jme3.util.NativeObjectManager#deleteUnused(Ljava/lang/Object;)V
  rendererObject
    +c:

com.jme3.util.NativeObjectManager#deleteAllObjects(Ljava/lang/Object;)V
  rendererObject
    +c:

com.jme3.util.SafeArrayList#get(I)Ljava/lang/Object;
  index
    +c:Index:  , Size:0.

com.jme3.util.IntMap#<init>(IF)V
  initialCapacity
    +c:"initialCapacity is too large."."initialCapacity must be greater than zero.".
  loadFactor
    +c:"loadFactor must be greater than zero.".

com.jme3.util.clone.Cloner#clone(Ljava/lang/Object;Z)Ljava/lang/Object;
  object
    +c:Object is not cloneable, type:.Object is not cloneable, type:.

com.jme3.util.clone.Cloner#javaClone(Ljava/lang/Object;)Ljava/lang/Object;
  object
    +c:No public clone method found for:.Error cloning object of type:.

com.jme3.util.clone.ListCloneFunction#cloneObject(Lcom/jme3/util/clone/Cloner;Ljava/util/List;)Ljava/util/List;
  object
    +c:Clone not supported for type:.

com.jme3.util.mikktspace.MikktspaceTangentGenerator#makeIndex(II)I
  face
    +c:
  vert
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#MergeVertsFast([I[Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TmpVert;Lcom/jme3/util/mikktspace/MikkTSpaceContext;II)V
  iL_in
    +c:
  iR_in
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#generateSharedVerticesIndexListSlow([ILcom/jme3/util/mikktspace/MikkTSpaceContext;I)V
  iNrTrianglesIn
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#generateInitialVerticesIndexList([Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TriInfo;[ILcom/jme3/util/mikktspace/MikkTSpaceContext;I)I
  iNrTrianglesIn
    +c:.

com.jme3.util.mikktspace.MikktspaceTangentGenerator#build4RuleGroups([Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TriInfo;[Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$Group;[I[II)I
  pTriInfos
    +c:
  piTriListIn
    +c:
  iNrTrianglesIn
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#assignRecur([I[Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TriInfo;ILcom/jme3/util/mikktspace/MikktspaceTangentGenerator$Group;)Z
  piTriListIn
    +c:
  iMyTriIndex
    +c:
  pGroup
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#generateTSpaces([Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TSpace;[Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TriInfo;[Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$Group;I[IFLcom/jme3/util/mikktspace/MikkTSpaceContext;)Z
  psTspace
    +c:
  pTriInfos
    +c:.
  pGroups
    +c:
  iNrActiveGroups
    +c:
  piTriListIn
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#evalTspace([II[I[Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TriInfo;Lcom/jme3/util/mikktspace/MikkTSpaceContext;I)Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TSpace;
  face_indices
    +c:
  iFaces
    +c:
  piTriListIn
    +c:
  pTriInfos
    +c:
  iVertexRepresentitive
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#quickSort([IIIJ)V
  iLeft
    +c:
  iRight
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#quickSortEdges([Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$Edge;IIIJ)V
  iLeft
    +c:
  iRight
    +c:

com.jme3.util.mikktspace.MikktspaceTangentGenerator#degenPrologue([Lcom/jme3/util/mikktspace/MikktspaceTangentGenerator$TriInfo;[III)V
  pTriInfos
    +c:
  iNrTrianglesIn
    +c:.
  iTotTris
    +c:

com.jme3.util.xml.SAXUtil#parseInt(Ljava/lang/String;I)I
  i
    +c:Expected an integer, got '  '.

com.jme3.util.xml.SAXUtil#parseInt(Ljava/lang/String;)I
  i
    +c:"Expected an integer".Expected an integer, got '  '.

com.jme3.util.xml.SAXUtil#parseFloat(Ljava/lang/String;F)F
  f
    +c:Expected a decimal, got '  '.

com.jme3.util.xml.SAXUtil#parseFloat(Ljava/lang/String;)F
  f
    +c:"Expected a decimal".Expected a decimal, got '  '.

com.jme3.util.xml.SAXUtil#parseString(Ljava/lang/String;)Ljava/lang/String;
  str
    +c:"Expected a string".

com.jme3.asset.plugins.ZipLocator#setRootPath(Ljava/lang/String;)V
  rootPath
    +c:Failed to open zip file:.

com.jme3.asset.plugins.HttpZipLocator#load(Ljava/net/URL;)V
  url
    +c:"HttpZipLocator only supports HTTP(S) URLs".

com.jme3.asset.plugins.HttpZipLocator#openStream(Ljava/lang/String;)Ljava/io/InputStream;
  name
    +c:Entry not found:.

com.jme3.asset.plugins.FileLocator#setRootPath(Ljava/lang/String;)V
  rootPath
    +c:.

com.jme3.cursors.plugins.JmeCursor#setImagesData(Ljava/nio/IntBuffer;)V
  imagesData
    +d: the cursor's image(s) data. Each image data should be consecutively stored in the IntBuffer if more than one image is contained in the cursor.

com.jme3.material.plugins.J3MLoader#loadMaterialDef(Ljava/util/List;Lcom/jme3/asset/AssetManager;Lcom/jme3/asset/AssetKey;)Lcom/jme3/material/MaterialDef;
  roots
    +c:

com.jme3.material.plugins.ShaderNodeLoaderDelegate#readNodesDefinitions(Ljava/util/List;Lcom/jme3/asset/ShaderNodeDefinitionKey;)Ljava/util/List;
  key
    +c:

com.jme3.material.plugins.ShaderNodeLoaderDelegate#readShaderNodeDefinition(Ljava/util/List;Lcom/jme3/asset/ShaderNodeDefinitionKey;)V
  key
    +c:

com.jme3.material.plugins.ShaderNodeLoaderDelegate#readVariable(Lcom/jme3/util/blockparser/Statement;)Lcom/jme3/shader/ShaderNodeVariable;
  statement
    +c:"More than 3 arguments"    \\s.Duplicate variable name.

com.jme3.material.plugins.ShaderNodeLoaderDelegate#readShaderStatement(Lcom/jme3/util/blockparser/Statement;)V
  statement
    +c:"Shader statement syntax incorrect"."Shader statement syntax incorrect".

com.jme3.material.plugins.ShaderNodeLoaderDelegate#checkMappingFormat([Ljava/lang/String;Lcom/jme3/util/blockparser/Statement;)V
  vars
    +c:Not a valid expression should be '<varName>[.<swizzling>] =  <nameSpace>.<varName>[.<swizzling>][:Condition]'.

com.jme3.material.plugins.ShaderNodeLoaderDelegate#updateRightFromUniforms(Lcom/jme3/material/MatParam;Lcom/jme3/shader/VariableMapping;Ljava/util/Map;Lcom/jme3/util/blockparser/Statement;)Z
  param
    +c:is not of Array type.
  statement
    +c:Wrong multiplicity for variable    .      should be an int or a declared material parameter.

com.jme3.material.plugins.ShaderNodeLoaderDelegate#extractCondition(Ljava/lang/String;Lcom/jme3/util/blockparser/Statement;)V
  condition
    +c:Invalid condition, condition must match a Material Parameter named.

com.jme3.material.plugins.ShaderNodeLoaderDelegate#readInputMapping(Lcom/jme3/util/blockparser/Statement;)Lcom/jme3/shader/VariableMapping;
  statement
    +c:"Unexpected mapping format".is not an input variable of."Samplers can only be assigned to MatParams"."The mapping doesn't have a right variable or a right expression.".Cannot have an attribute as input in a fragment shader.Could not find a Material Parameter named.Could not find a World Parameter named.Undeclared node    . Make sure this node is declared before the current node.Cannot find output variable     form ShaderNode.

com.jme3.material.plugins.ShaderNodeLoaderDelegate#readOutputMapping(Lcom/jme3/util/blockparser/Statement;)Lcom/jme3/shader/VariableMapping;
  statement
    +c:"Unexpected mapping format"."Samplers can only be inputs".Only Global nameSpace is allowed for outputMapping, got.is not an output variable of.

com.jme3.material.plugins.ShaderNodeLoaderDelegate#fixSamplerType(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
  rightType
    +d: the right sampler type (can be multiple types separated by "|"

com.jme3.material.plugins.ShaderNodeLoaderDelegate#storeGlobal(Lcom/jme3/shader/ShaderNodeVariable;Lcom/jme3/util/blockparser/Statement;)V
  var
    +c:A global output is already defined for the vertex shader:     . vertex shader can only have one global output.

com.jme3.material.plugins.ShaderNodeLoaderDelegate#findDefinition(Lcom/jme3/util/blockparser/Statement;)Lcom/jme3/shader/ShaderNodeDefinition;
  statement
    +c:"Can't find shader node definition for: ".Couldn't find.is not a declared as Shader Node Definition.

com.jme3.material.plugins.ShaderNodeLoaderDelegate#checkTypes(Lcom/jme3/shader/VariableMapping;Lcom/jme3/util/blockparser/Statement;)V
  mapping
    +c:Type mismatch, cannot convert        .  to        .Type mismatch, cannot convert    [ ]  to    [ ].

com.jme3.material.plugins.ShaderNodeDefinitionLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  assetInfo
    +c:

com.jme3.scene.plugins.OBJLoader#quadToTriangle(Lcom/jme3/scene/plugins/OBJLoader$Face;)[Lcom/jme3/scene/plugins/OBJLoader$Face;
  f
    +c:.

com.jme3.scene.plugins.OBJLoader#loadMtlLib(Ljava/lang/String;)V
  name
    +c:Expected .mtl file! Got:.

com.jme3.scene.plugins.OBJLoader#createGeometry(Ljava/util/ArrayList;Ljava/lang/String;)Lcom/jme3/scene/Geometry;
  faceList
    +c:"No geometry data to generate mesh".

com.jme3.scene.plugins.OBJLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  info
    +c:"Model assets must be loaded using a ModelKey".

com.jme3.shader.plugins.GLSLLoader#loadNode(Ljava/io/Reader;Ljava/lang/String;)Lcom/jme3/shader/plugins/ShaderDependencyNode;
  nodeName
    +c:"Node depends on itself.".Failed to load shader node:.

com.jme3.texture.plugins.DDSLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  info
    +c:"Texture assets must be loaded using a TextureKey".

com.jme3.texture.plugins.DXTFlipper#flipDXT5Block([BI)V
  block
    +c:.

com.jme3.texture.plugins.DXTFlipper#flipDXT(Ljava/nio/ByteBuffer;IILcom/jme3/texture/Image$Format;)Ljava/nio/ByteBuffer;
  format
    +c:.

com.jme3.texture.plugins.TGALoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  info
    +c:"Texture assets must be loaded using a TextureKey".

com.jme3.texture.plugins.ImageFlipper#flipImage(Lcom/jme3/texture/Image;I)V
  img
    +c:Flipping compressed  images is unsupported.

com.jme3.texture.plugins.PFMLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  info
    +c:"Texture assets must be loaded using a TextureKey".

com.jme3.texture.plugins.HDRLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  info
    +c:"Texture assets must be loaded using a TextureKey".

com.jme3.texture.plugins.ktx.KTXLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  info
    +c:"Texture assets must be loaded using a TextureKey".

com.jme3.collision.CollideIgnoreTransformTest#castRay(Lcom/jme3/math/Ray;I)V
  expectedNumResults
    +c:Expected %d, got %d.

com.jme3.light.LightFilterTest#checkFilteredLights(I)V
  expected
    +c:.

jme3tools.optimize.TextureAtlas#addTexture(Lcom/jme3/texture/Texture;Ljava/lang/String;)Z
  texture
    +c:"Texture cannot be null!"."Texture has no asset key name!".
  mapName
    +c:

jme3tools.optimize.TextureAtlas#addTexture(Lcom/jme3/texture/Texture;Ljava/lang/String;Lcom/jme3/texture/Texture;)V
  texture
    +c:
  mapName
    +c:

jme3tools.optimize.TextureAtlas#addTexture(Lcom/jme3/texture/Texture;Ljava/lang/String;Ljava/lang/String;)V
  texture
    +c:"Texture cannot be null!"."Texture has no asset key name!".
  mapName
    +c:

jme3tools.optimize.TextureAtlas#applyCoords(Lcom/jme3/scene/Geometry;ILcom/jme3/scene/Mesh;)Z
  outMesh
    +d: The mesh to set the coords in (can be same as input).
    +c:

com.jme3.post.filters.GammaCorrectionFilter#setGamma(F)V
  gamma
    +c:"Gamma value can't be below or equal 0.".

com.jme3.renderer.ios.IosGL#glIsEnabled(I)Z
  cap
    +c:.

com.jme3.renderer.ios.IosGL#glShaderSource(I[Ljava/lang/String;Ljava/nio/IntBuffer;)V
  length
    +c:"Today is not a good day".

com.jme3.bullet.collision.shapes.ConeCollisionShape#<init>(FFI)V
  axis
    +c:"axis must be one of the PhysicsSpace.AXIS_* constants!".

com.jme3.bullet.collision.shapes.CompoundCollisionShape#addChildShape(Lcom/jme3/bullet/collision/shapes/CollisionShape;Lcom/jme3/math/Vector3f;Lcom/jme3/math/Matrix3f;)V
  shape
    +c:"CompoundCollisionShapes cannot have CompoundCollisionShapes as children!".

com.jme3.bullet.collision.shapes.CompoundCollisionShape#addChildShapeDirect(Lcom/jme3/bullet/collision/shapes/CollisionShape;Lcom/jme3/math/Vector3f;Lcom/jme3/math/Matrix3f;)V
  shape
    +c:"CompoundCollisionShapes cannot have CompoundCollisionShapes as children!".

com.jme3.bullet.joints.HingeJoint#setLimit(FFFFF)V
  _relaxationFactor
    +d: the rate at which velocity errors are corrected. This can be seen as the strength of the limits. A low value will make the limits more spongy.

com.jme3.bullet.objects.PhysicsVehicle#addWheel(Lcom/jme3/math/Vector3f;Lcom/jme3/math/Vector3f;Lcom/jme3/math/Vector3f;FFZ)Lcom/jme3/bullet/objects/VehicleWheel;
  direction
    +d: the direction of the wheel (should be -Y / 0,-1,0 for a normal car)
  axle
    +d: The axis of the wheel, pointing right in vehicle direction (should be -X / -1,0,0 for a normal car)

com.jme3.bullet.objects.PhysicsVehicle#addWheel(Lcom/jme3/scene/Spatial;Lcom/jme3/math/Vector3f;Lcom/jme3/math/Vector3f;Lcom/jme3/math/Vector3f;FFZ)Lcom/jme3/bullet/objects/VehicleWheel;
  direction
    +d: the direction of the wheel (should be -Y / 0,-1,0 for a normal car)
  axle
    +d: The axis of the wheel, pointing right in vehicle direction (should be -X / -1,0,0 for a normal car)

com.jme3.bullet.objects.PhysicsRigidBody#setMass(F)V
  mass
    +c:"Dynamic rigidbody can not have mesh collision shape!".

com.jme3.bullet.objects.PhysicsRigidBody#setCollisionShape(Lcom/jme3/bullet/collision/shapes/CollisionShape;)V
  collisionShape
    +c:"Dynamic rigidbody can not have mesh collision shape!".

com.jme3.audio.plugins.OGGLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  info
    +c:"Audio assets must be loaded using an AudioKey".

com.jme3.opencl.jocl.JoclImage#decodeImageChannelOrder(Lcom/jme3/opencl/Image$ImageChannelOrder;)I
  order
    +c:unknown image channel order:.

com.jme3.opencl.jocl.JoclImage#decodeImageChannelType(Lcom/jme3/opencl/Image$ImageChannelType;)I
  type
    +c:Unknown image channel type:.

com.jme3.opencl.jocl.JoclImage#decodeImageType(Lcom/jme3/opencl/Image$ImageType;)I
  type
    +c:Unknown or unsupported image type:.

com.jme3.opencl.jocl.JoclImage#readImage(Lcom/jme3/opencl/CommandQueue;Ljava/nio/ByteBuffer;[J[JJJ)V
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclImage#readImageAsync(Lcom/jme3/opencl/CommandQueue;Ljava/nio/ByteBuffer;[J[JJJ)Lcom/jme3/opencl/Event;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclImage#writeImage(Lcom/jme3/opencl/CommandQueue;Ljava/nio/ByteBuffer;[J[JJJ)V
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclImage#writeImageAsync(Lcom/jme3/opencl/CommandQueue;Ljava/nio/ByteBuffer;[J[JJJ)Lcom/jme3/opencl/Event;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclImage#copyTo(Lcom/jme3/opencl/CommandQueue;Lcom/jme3/opencl/Image;[J[J[J)V
  region
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclImage#copyToAsync(Lcom/jme3/opencl/CommandQueue;Lcom/jme3/opencl/Image;[J[J[J)Lcom/jme3/opencl/Event;
  region
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclImage#map(Lcom/jme3/opencl/CommandQueue;[J[JLcom/jme3/opencl/MappingAccess;)Lcom/jme3/opencl/Image$ImageMapping;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclImage#mapAsync(Lcom/jme3/opencl/CommandQueue;[J[JLcom/jme3/opencl/MappingAccess;)Lcom/jme3/opencl/Image$ImageMapping;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclImage#fillAsync(Lcom/jme3/opencl/CommandQueue;[J[JLcom/jme3/math/ColorRGBA;)Lcom/jme3/opencl/Event;
  origin
    +c:"origin and region must both be arrays of length 3".
  region
    +c:

com.jme3.opencl.jocl.JoclImage#fillAsync(Lcom/jme3/opencl/CommandQueue;[J[J[I)Lcom/jme3/opencl/Event;
  origin
    +c:"origin and region must both be arrays of length 3".
  region
    +c:
  color
    +c:"the passed color array must have length 4".

com.jme3.opencl.jocl.JoclImage#copyToBufferAsync(Lcom/jme3/opencl/CommandQueue;Lcom/jme3/opencl/Buffer;[J[JJ)Lcom/jme3/opencl/Event;
  srcRegion
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.Utils#checkError(ILjava/lang/String;)V
  error
    +c:OpenCL error in   :     UNKNOWN  (0x    ).

com.jme3.opencl.jocl.Utils#getMemoryAccessFlags(Lcom/jme3/opencl/MemoryAccess;)J
  ma
    +c:Unknown memory access:.

com.jme3.opencl.jocl.Utils#getMemoryAccessFromFlag(J)Lcom/jme3/opencl/MemoryAccess;
  flag
    +c:Unknown memory access flag:.

com.jme3.opencl.jocl.Utils#getMappingAccessFlags(Lcom/jme3/opencl/MappingAccess;)J
  ma
    +c:Unknown mapping access:.

com.jme3.opencl.jocl.JoclBuffer#copyToImageAsync(Lcom/jme3/opencl/CommandQueue;Lcom/jme3/opencl/Image;J[J[J)Lcom/jme3/opencl/Event;
  destOrigin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.jocl.JoclContext#createQueue(Lcom/jme3/opencl/Device;)Lcom/jme3/opencl/CommandQueue;
  device
    +c:.

com.jme3.opencl.jocl.JoclContext#createImage(Lcom/jme3/opencl/MemoryAccess;Lcom/jme3/opencl/Image$ImageFormat;Lcom/jme3/opencl/Image$ImageDescriptor;)Lcom/jme3/opencl/Image;
  descr
    +c:"Jocl only supports 2D and 3D images".

com.jme3.opencl.jocl.JoclContext#querySupportedFormats(Lcom/jme3/opencl/MemoryAccess;Lcom/jme3/opencl/Image$ImageType;)[Lcom/jme3/opencl/Image$ImageFormat;
  type
    +c:"Jocl only supports 2D and 3D images".

com.jme3.opencl.jocl.JoclContext#bindVertexBuffer(Lcom/jme3/scene/VertexBuffer;Lcom/jme3/opencl/MemoryAccess;)Lcom/jme3/opencl/Buffer;
  vb
    +c:

com.jme3.opencl.jocl.JoclContext#bindImage(Lcom/jme3/texture/Image;Lcom/jme3/texture/Texture$Type;ILcom/jme3/opencl/MemoryAccess;)Lcom/jme3/opencl/Image;
  image
    +c:
  textureType
    +c:"Jocl only supports 2D and 3D images".

com.jme3.opencl.jocl.JoclContext#bindPureRenderBuffer(Lcom/jme3/texture/FrameBuffer$RenderBuffer;Lcom/jme3/opencl/MemoryAccess;)Lcom/jme3/opencl/Image;
  buffer
    +c:

com.jme3.renderer.jogl.JoglGLExt#checkLimit(Ljava/nio/Buffer;)V
  buffer
    +c:"Attempting to upload empty buffer (limit = 0), that's an error"."Attempting to upload empty buffer (remaining = 0), that's an error".

com.jme3.renderer.jogl.JoglGLFbo#checkLimit(Ljava/nio/Buffer;)V
  buffer
    +c:"Attempting to upload empty buffer (limit = 0), that's an error"."Attempting to upload empty buffer (remaining = 0), that's an error".

com.jme3.renderer.jogl.TextureUtil#convertTextureFormat(Lcom/jme3/texture/Image$Format;)I
  fmt
    +c:Unrecognized format:.

com.jme3.renderer.jogl.TextureUtil#getImageFormatWithError(Lcom/jme3/texture/Image$Format;Z)Lcom/jme3/renderer/jogl/TextureUtil$GLImageFormat;
  fmt
    +c:Image format '  ' is unsupported by the video hardware.

com.jme3.renderer.jogl.TextureUtil#uploadTexture(Lcom/jme3/texture/Image;IIIZ)V
  image
    +c:
  target
    +c:
  index
    +c:

com.jme3.renderer.jogl.TextureUtil#uploadSubTexture(Lcom/jme3/texture/Image;IIIIZ)V
  image
    +c:
  target
    +c:
  index
    +c:

com.jme3.audio.lwjgl.LwjglEFX#alGenAuxiliaryEffectSlots(ILjava/nio/IntBuffer;)V
  numSlots
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglEFX#alGenEffects(ILjava/nio/IntBuffer;)V
  numEffects
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglEFX#alDeleteEffects(ILjava/nio/IntBuffer;)V
  numEffects
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglEFX#alDeleteAuxiliaryEffectSlots(ILjava/nio/IntBuffer;)V
  numEffectSlots
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglEFX#alGenFilters(ILjava/nio/IntBuffer;)V
  numFilters
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglEFX#alDeleteFilters(ILjava/nio/IntBuffer;)V
  numFilters
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglAL#alDeleteSources(ILjava/nio/IntBuffer;)V
  numSources
    +c:
  sources
    +c:.

com.jme3.audio.lwjgl.LwjglAL#alGenBuffers(ILjava/nio/IntBuffer;)V
  numBuffers
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglAL#alDeleteBuffers(ILjava/nio/IntBuffer;)V
  numBuffers
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglAL#alBufferData(IILjava/nio/ByteBuffer;II)V
  data
    +c:.
  size
    +c:

com.jme3.audio.lwjgl.LwjglAL#alSourceUnqueueBuffers(IILjava/nio/IntBuffer;)V
  numBuffers
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglAL#alSourceQueueBuffers(IILjava/nio/IntBuffer;)V
  numBuffers
    +c:
  buffers
    +c:.

com.jme3.audio.lwjgl.LwjglALC#alcGetInteger(ILjava/nio/IntBuffer;I)V
  buffer
    +c:.
  size
    +c:

com.jme3.input.lwjgl.JInputJoyInput#setJoyRumble(IF)V
  joyId
    +c:.

com.jme3.opencl.lwjgl.LwjglBuffer#copyToImageAsync(Lcom/jme3/opencl/CommandQueue;Lcom/jme3/opencl/Image;J[J[J)Lcom/jme3/opencl/Event;
  destOrigin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglProgram#getBinary(Lcom/jme3/opencl/Device;)Ljava/nio/ByteBuffer;
  device
    +c:Program was not built against the specified device.

com.jme3.opencl.lwjgl.LwjglImage#decodeImageChannelOrder(Lcom/jme3/opencl/Image$ImageChannelOrder;)I
  order
    +c:unknown image channel order:.

com.jme3.opencl.lwjgl.LwjglImage#decodeImageChannelType(Lcom/jme3/opencl/Image$ImageChannelType;)I
  type
    +c:Unknown image channel type:.

com.jme3.opencl.lwjgl.LwjglImage#decodeImageType(Lcom/jme3/opencl/Image$ImageType;)I
  type
    +c:Unknown image type:.

com.jme3.opencl.lwjgl.LwjglImage#encodeImageType(I)Lcom/jme3/opencl/Image$ImageType;
  type
    +c:Unknown image type id:.

com.jme3.opencl.lwjgl.LwjglImage#readImage(Lcom/jme3/opencl/CommandQueue;Ljava/nio/ByteBuffer;[J[JJJ)V
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#readImageAsync(Lcom/jme3/opencl/CommandQueue;Ljava/nio/ByteBuffer;[J[JJJ)Lcom/jme3/opencl/Event;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#writeImage(Lcom/jme3/opencl/CommandQueue;Ljava/nio/ByteBuffer;[J[JJJ)V
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#writeImageAsync(Lcom/jme3/opencl/CommandQueue;Ljava/nio/ByteBuffer;[J[JJJ)Lcom/jme3/opencl/Event;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#copyTo(Lcom/jme3/opencl/CommandQueue;Lcom/jme3/opencl/Image;[J[J[J)V
  region
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#copyToAsync(Lcom/jme3/opencl/CommandQueue;Lcom/jme3/opencl/Image;[J[J[J)Lcom/jme3/opencl/Event;
  region
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#map(Lcom/jme3/opencl/CommandQueue;[J[JLcom/jme3/opencl/MappingAccess;)Lcom/jme3/opencl/Image$ImageMapping;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#mapAsync(Lcom/jme3/opencl/CommandQueue;[J[JLcom/jme3/opencl/MappingAccess;)Lcom/jme3/opencl/Image$ImageMapping;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#fillAsync(Lcom/jme3/opencl/CommandQueue;[J[JLcom/jme3/math/ColorRGBA;)Lcom/jme3/opencl/Event;
  origin
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglImage#fillAsync(Lcom/jme3/opencl/CommandQueue;[J[J[I)Lcom/jme3/opencl/Event;
  origin
    +c:"origin and region must both be arrays of length 3".
  color
    +c:"the passed color array must have length 4".

com.jme3.opencl.lwjgl.LwjglImage#copyToBufferAsync(Lcom/jme3/opencl/CommandQueue;Lcom/jme3/opencl/Buffer;[J[JJ)Lcom/jme3/opencl/Event;
  srcRegion
    +c:"origin and region must both be arrays of length 3".

com.jme3.opencl.lwjgl.LwjglContext#createQueue(Lcom/jme3/opencl/Device;)Lcom/jme3/opencl/CommandQueue;
  device
    +c:.

com.jme3.opencl.lwjgl.LwjglContext#bindVertexBuffer(Lcom/jme3/scene/VertexBuffer;Lcom/jme3/opencl/MemoryAccess;)Lcom/jme3/opencl/Buffer;
  vb
    +c:

com.jme3.opencl.lwjgl.LwjglContext#bindImage(Lcom/jme3/texture/Image;Lcom/jme3/texture/Texture$Type;ILcom/jme3/opencl/MemoryAccess;)Lcom/jme3/opencl/Image;
  image
    +c:
  textureType
    +c:

com.jme3.opencl.lwjgl.LwjglContext#bindPureRenderBuffer(Lcom/jme3/texture/FrameBuffer$RenderBuffer;Lcom/jme3/opencl/MemoryAccess;)Lcom/jme3/opencl/Image;
  buffer
    +c:

com.jme3.opencl.lwjgl.Utils#checkError(ILjava/lang/String;)V
  error
    +c:OpenCL error in   :     UNKNOWN  (0x    ).

com.jme3.opencl.lwjgl.Utils#getMemoryAccessFlags(Lcom/jme3/opencl/MemoryAccess;)J
  ma
    +c:Unknown memory access:.

com.jme3.opencl.lwjgl.Utils#getMemoryAccessFromFlag(J)Lcom/jme3/opencl/MemoryAccess;
  flag
    +c:Unknown memory access flag:.

com.jme3.opencl.lwjgl.Utils#getMappingAccessFlags(Lcom/jme3/opencl/MappingAccess;)J
  ma
    +c:Unknown mapping access:.

com.jme3.renderer.lwjgl.LwjglGLFboEXT#checkLimit(Ljava/nio/Buffer;)V
  buffer
    +c:"Attempting to upload empty buffer (limit = 0), that's an error"."Attempting to upload empty buffer (remaining = 0), that's an error".

com.jme3.renderer.lwjgl.LwjglGLFboGL3#checkLimit(Ljava/nio/Buffer;)V
  buffer
    +c:"Attempting to upload empty buffer (limit = 0), that's an error"."Attempting to upload empty buffer (remaining = 0), that's an error".

com.jme3.renderer.lwjgl.LwjglGLExt#checkLimit(Ljava/nio/Buffer;)V
  buffer
    +c:"Attempting to upload empty buffer (limit = 0), that's an error"."Attempting to upload empty buffer (remaining = 0), that's an error".

com.jme3.renderer.lwjgl.LwjglGL#checkLimit(Ljava/nio/Buffer;)V
  buffer
    +c:"Attempting to upload empty buffer (limit = 0), that's an error"."Attempting to upload empty buffer (remaining = 0), that's an error".

com.jme3.network.Network#createServer(Ljava/lang/String;III)Lcom/jme3/network/Server;
  gameName
    +d: This is the name that identifies the game.  Connecting clients must use this name or be turned away.

com.jme3.network.Network#connectToServer(Ljava/lang/String;ILjava/lang/String;II)Lcom/jme3/network/Client;
  gameName
    +d: This is the name that identifies the game.  This must match the target server's name or this client will be turned away.
  version
    +d:  This is a game-specific verison that helps detect when out-of-date clients have connected to an incompatible server.  This must match the server's version of this client will be turned away.
  hostPort
    +d:  The remote TCP port on the server to which this client should send reliable messages. 
  remoteUdpPort
    +d:  The remote UDP port on the server to which this client should send 'fast'/unreliable messages.   Set to -1 if 'fast' traffic should go over TCP.  This will completely disable UDP traffic for this client.

com.jme3.network.base.DefaultClient#<init>(Ljava/lang/String;ILcom/jme3/network/kernel/Connector;Lcom/jme3/network/kernel/Connector;Lcom/jme3/network/base/ConnectorFactory;)V
  reliable
    +c:

com.jme3.network.base.DefaultClient#setPrimaryConnectors(Lcom/jme3/network/kernel/Connector;Lcom/jme3/network/kernel/Connector;Lcom/jme3/network/base/ConnectorFactory;)V
  reliable
    +c:"The reliable connector cannot be null.".

com.jme3.network.base.DefaultClient#send(ILcom/jme3/network/Message;)V
  channel
    +c:Channel is undefined:.

com.jme3.network.base.DefaultClient#configureChannels(J[I)V
  ports
    +c:

com.jme3.network.base.MessageListenerRegistry#addMessageListener(Lcom/jme3/network/MessageListener;)V
  listener
    +c:"Listener cannot be null.".

com.jme3.network.base.MessageListenerRegistry#addMessageListener(Lcom/jme3/network/MessageListener;[Ljava/lang/Class;)V
  listener
    +c:"Listener cannot be null.".

com.jme3.network.base.DefaultServer#<init>(Ljava/lang/String;ILcom/jme3/network/kernel/Kernel;Lcom/jme3/network/kernel/Kernel;)V
  reliable
    +c:"Default server reqiures a reliable kernel instance.".

com.jme3.network.base.DefaultServer#addChannel(I)I
  port
    +c:Error adding channel for port:.

com.jme3.network.base.DefaultServer#checkChannel(I)V
  channel
    +c:Channel is undefined:.

com.jme3.network.base.DefaultServer#broadcast(ILcom/jme3/network/Filter;Lcom/jme3/network/Message;)V
  channel
    +c:

com.jme3.network.base.KernelAdapter#createAndDispatch(Lcom/jme3/network/kernel/Envelope;)V
  env
    +c:Envelope contained incomplete data:.

com.jme3.network.base.MessageProtocol#messageToBuffer(Lcom/jme3/network/Message;Ljava/nio/ByteBuffer;)Ljava/nio/ByteBuffer;
  target
    +c:

com.jme3.network.base.MessageProtocol#addBuffer(Ljava/nio/ByteBuffer;)I
  buffer
    +c:

com.jme3.network.base.MessageProtocol#createMessage(Ljava/nio/ByteBuffer;)V
  buffer
    +c:Error deserializing object, class ID:.

com.jme3.network.kernel.tcp.NioEndpoint#close(Z)V
  flushData
    +c:

com.jme3.network.kernel.tcp.NioEndpoint#send(Ljava/nio/ByteBuffer;)V
  data
    +c:"Data cannot be null.".

com.jme3.network.kernel.tcp.SelectorKernel#broadcast(Lcom/jme3/network/Filter;Ljava/nio/ByteBuffer;ZZ)V
  reliable
    +c:"Unreliable send not supported by this kernel.".

com.jme3.network.kernel.udp.UdpEndpoint#send(Ljava/nio/ByteBuffer;)V
  data
    +c:

com.jme3.network.kernel.udp.UdpKernel#broadcast(Lcom/jme3/network/Filter;Ljava/nio/ByteBuffer;ZZ)V
  reliable
    +c:"Reliable send not supported by this kernel.".

com.jme3.network.rmi.ObjectStore#getExposedObject(Ljava/lang/String;Ljava/lang/Class;Z)Ljava/lang/Object;
  waitFor
    +c:Cannot find remote object named:.

com.jme3.network.rmi.ObjectStore#invokeRemoteMethod(Lcom/jme3/network/rmi/RemoteObject;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;
  method
    +c:Method not implemented by remote object owner:.

com.jme3.network.serializing.serializers.FieldSerializer#checkClass(Ljava/lang/Class;)V
  clazz
    +c:Registration error: no-argument constructor not found on:.

com.jme3.network.serializing.serializers.FieldSerializer#initialize(Ljava/lang/Class;)V
  clazz
    +c:

com.jme3.network.serializing.serializers.FieldSerializer#readObject(Ljava/nio/ByteBuffer;Ljava/lang/Class;)Ljava/lang/Object;
  c
    +c:Error creating object of type:.

com.jme3.network.serializing.serializers.FieldSerializer#writeObject(Ljava/nio/ByteBuffer;Ljava/lang/Object;)V
  buffer
    +c:
  object
    +c:The     is not registered  in the serializer!.Unable to access field:    on:.

com.jme3.network.serializing.serializers.StringSerializer#readString(Ljava/nio/ByteBuffer;)Ljava/lang/String;
  data
    +c:

com.jme3.network.serializing.serializers.StringSerializer#readObject(Ljava/nio/ByteBuffer;Ljava/lang/Class;)Ljava/lang/String;
  data
    +c:

com.jme3.network.serializing.serializers.EnumSerializer#readObject(Ljava/nio/ByteBuffer;Ljava/lang/Class;)Ljava/lang/Object;
  c
    +c:Class has no enum constants:    Ordinal:.

com.jme3.network.service.rmi.MethodInfo#invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
  target
    +c:Error invoking:   on:.Error invoking:   on:.Error invoking:   on:.

com.jme3.network.service.rmi.RmiRegistry#addRemoteClass(Lcom/jme3/network/service/rmi/ClassInfo;)V
  info
    +c:Error class already exists for ID:.

com.jme3.network.service.rmi.RmiRegistry#addRemoteObject(BSLjava/lang/String;Lcom/jme3/network/service/rmi/ClassInfo;)V
  name
    +c:Object already registered for:.

com.jme3.network.service.rpc.RpcConnection#removeHandler(SLcom/jme3/network/service/rpc/RpcHandler;)V
  handler
    +c:Handler not registered for object ID:  , handler:.

com.jme3.network.service.rpc.RpcConnection#handleMessage(Lcom/jme3/network/service/rpc/msg/RpcCallMessage;)V
  msg
    +c:Handler not found for objectID:.

com.jme3.niftygui.NiftyJmeDisplay#newNiftyJmeDisplay(Lcom/jme3/asset/AssetManager;Lcom/jme3/input/InputManager;Lcom/jme3/audio/AudioRenderer;Lcom/jme3/renderer/ViewPort;Lde/lessvoid/nifty/render/batch/BatchRenderConfiguration;)Lcom/jme3/niftygui/NiftyJmeDisplay;
  batchRenderConfiguration
    +d: the Nifty BatchRenderConfiguration that you can use to further configure batch rendering. If unsure you can simply use new BatchRenderConfiguration() in here for the default configuration which should give you good default values.

com.jme3.niftygui.RenderDeviceJme#convertBlend(Lde/lessvoid/nifty/render/BlendMode;)Lcom/jme3/material/RenderState$BlendMode;
  blendMode
    +c:.

com.jme3.niftygui.RenderImageJme#<init>(Lcom/jme3/texture/Texture2D;)V
  texture
    +c:"texture.getImage() cannot be null".

com.jme3.niftygui.SoundHandleJme#<init>(Lcom/jme3/audio/AudioRenderer;Lcom/jme3/asset/AssetManager;Ljava/lang/String;)V
  fileName
    +c:.

com.jme3.scene.plugins.fbx.FbxLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  assetInfo
    +c:

com.jme3.scene.plugins.fbx.SceneWithAnimationLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  assetInfo
    +c:

com.jme3.scene.plugins.fbx.anim.FbxAnimCurveNode#connectObjectProperty(Lcom/jme3/scene/plugins/fbx/obj/FbxObject;Ljava/lang/String;)V
  property
    +c:"!".

com.jme3.scene.plugins.fbx.anim.FbxLimbNode#createSkeleton(Lcom/jme3/scene/plugins/fbx/node/FbxNode;)Lcom/jme3/animation/Skeleton;
  skeletonHolderNode
    +c:"Limb nodes cannot be skeleton holders".

com.jme3.scene.plugins.fbx.file.FbxDump#dumpProperty(Ljava/lang/String;CLjava/lang/Object;Ljava/io/PrintStream;Ljava/util/Map;)V
  propertyType
    +c:.

com.jme3.scene.plugins.fbx.mesh.FbxLayerElement#fromElement(Lcom/jme3/scene/plugins/fbx/file/FbxElement;)Lcom/jme3/scene/plugins/fbx/mesh/FbxLayerElement;
  element
    +c:"Not a layer element".

com.jme3.scene.plugins.fbx.node.FbxNode#setWorldBindPose(Lcom/jme3/math/Matrix4f;)V
  worldBindPose
    +c:"Bind poses don't match".

com.jme3.scene.plugins.fbx.node.FbxNode#createSkeletons(Lcom/jme3/scene/plugins/fbx/node/FbxNode;)V
  fbxNode
    +c:.

com.jme3.scene.plugins.fbx.node.FbxNode#connectObject(Lcom/jme3/scene/plugins/fbx/obj/FbxObject;)V
  object
    +c:

com.jme3.scene.plugins.fbx.obj.FbxObjectFactory#createObject(Lcom/jme3/scene/plugins/fbx/file/FbxElement;Lcom/jme3/asset/AssetManager;Ljava/lang/String;)Lcom/jme3/scene/plugins/fbx/obj/FbxObject;
  assetManager
    +c:FBXObject subclass (   ,  ) forgot to call super() in their constructor.

com.jme3.scene.plugins.gltf.CustomContentManager#readExtension(Ljava/lang/String;Lcom/google/gson/JsonElement;Ljava/lang/Object;)Ljava/lang/Object;
  input
    +c:Extension loader         for extension     is incompatible with type.

com.jme3.scene.plugins.gltf.CustomContentManager#readExtras(Ljava/lang/String;Lcom/google/gson/JsonElement;Ljava/lang/Object;)Ljava/lang/Object;
  name
    +c:Extra loader       for    is incompatible with type.

com.jme3.scene.plugins.gltf.BinLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  assetInfo
    +c:".bin files cannot be loaded directly, load the associated .gltf file".

com.jme3.scene.plugins.gltf.GltfUtils#getVertexBufferFormat(I)Lcom/jme3/scene/VertexBuffer$Format;
  componentType
    +c:Illegal component type:.

com.jme3.scene.plugins.gltf.GltfUtils#getNumberOfComponents(Ljava/lang/String;)I
  type
    +c:Illegal type:.

com.jme3.scene.plugins.gltf.GltfUtils#assertNotNull(Ljava/lang/Object;Ljava/lang/String;)V
  o
    +c:.

com.jme3.scene.plugins.gltf.GltfLoader#load(Lcom/jme3/asset/AssetInfo;)Ljava/lang/Object;
  assetInfo
    +c:

com.jme3.scene.plugins.gltf.GltfLoader#loadFromStream(Lcom/jme3/asset/AssetInfo;Ljava/io/InputStream;)Ljava/lang/Object;
  assetInfo
    +c:An error occurred loading.

com.jme3.scene.plugins.gltf.GltfLoader#getBytes(ILjava/lang/String;Ljava/lang/Integer;)[B
  uri
    +c:Cannot load   , a .bin extension is required.Buffer    has no uri.

com.jme3.material.plugin.export.material.J3MRootOutputCapsule#write(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
  name
    +c:string material parameter not supported yet.

com.jme3.material.plugin.export.material.J3MRootOutputCapsule#write(ZLjava/lang/String;Z)V
  name
    +c:boolean material parameter not supported yet.

com.jme3.material.plugin.export.material.J3MExporter#save(Lcom/jme3/export/Savable;Ljava/io/OutputStream;)V
  object
    +c:"J3MExporter can only save com.jme3.material.Material class".

com.jme3.material.plugin.export.material.J3MOutputCapsule#format(Lcom/jme3/export/Savable;)Ljava/lang/String;
  value
    +c:: Not supported yet.

com.jme3.scene.plugins.IrUtils#splitByMaterial(Lcom/jme3/scene/plugins/IrMesh;)Lcom/jme3/util/IntMap;
  mesh
    +c:

com.jme3.scene.plugins.IrUtils#convertIrMeshToJmeMesh(Lcom/jme3/scene/plugins/IrMesh;)Lcom/jme3/scene/Mesh;
  mesh
    +c:

com.jme3.scene.plugins.ogre.SceneLoader#startElement(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/xml/sax/Attributes;)V
  qName
    +c:

com.jme3.scene.plugins.ogre.SkeletonLoader#startElement(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lorg/xml/sax/Attributes;)V
  qName
    +c:

com.jme3.scene.plugins.ogre.SkeletonLoader#endElement(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
  qName
    +c:.

com.jme3.export.xml.DOMOutputCapsule#write(Ljava/nio/FloatBuffer;Ljava/lang/String;Ljava/nio/FloatBuffer;)V
  value
    +c:'  ' buffer contention resulted in write data consistency.      values written when should have written.

com.jme3.export.xml.DOMOutputCapsule#write(Ljava/nio/IntBuffer;Ljava/lang/String;Ljava/nio/IntBuffer;)V
  value
    +c:'  ' buffer contention resulted in write data consistency.      values written when should have written.

com.jme3.export.xml.DOMOutputCapsule#write(Ljava/nio/ByteBuffer;Ljava/lang/String;Ljava/nio/ByteBuffer;)V
  value
    +c:'  ' buffer contention resulted in write data consistency.      values written when should have written.

com.jme3.export.xml.DOMOutputCapsule#write(Ljava/nio/ShortBuffer;Ljava/lang/String;Ljava/nio/ShortBuffer;)V
  value
    +c:'  ' buffer contention resulted in write data consistency.      values written when should have written.

com.jme3.export.xml.DOMInputCapsule#readByteArray(Ljava/lang/String;[B)[B
  name
    +c:Wrong number of bytes for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readByteArray2D(Ljava/lang/String;[[B)[[B
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readIntArray(Ljava/lang/String;[I)[I
  name
    +c:Wrong number of ints for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readIntArray2D(Ljava/lang/String;[[I)[[I
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readFloatArray(Ljava/lang/String;[F)[F
  name
    +c:Wrong number of floats for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readDoubleArray(Ljava/lang/String;[D)[D
  name
    +c:Wrong number of doubles for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readDoubleArray2D(Ljava/lang/String;[[D)[[D
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readLongArray(Ljava/lang/String;[J)[J
  name
    +c:Wrong number of longs for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readLongArray2D(Ljava/lang/String;[[J)[[J
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readShortArray(Ljava/lang/String;[S)[S
  name
    +c:Wrong number of shorts for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readShortArray2D(Ljava/lang/String;[[S)[[S
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readBooleanArray(Ljava/lang/String;[Z)[Z
  name
    +c:Wrong number of bools for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readBooleanArray2D(Ljava/lang/String;[[Z)[[Z
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readStringArray(Ljava/lang/String;[Ljava/lang/String;)[Ljava/lang/String;
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readStringArray2D(Ljava/lang/String;[[Ljava/lang/String;)[[Ljava/lang/String;
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readSavableArray(Ljava/lang/String;[Lcom/jme3/export/Savable;)[Lcom/jme3/export/Savable;
  name
    +c:Wrong number of Savables for '  '.  size says    , data contains.

com.jme3.export.xml.DOMInputCapsule#readSavableArrayList(Ljava/lang/String;Ljava/util/ArrayList;)Ljava/util/ArrayList;
  name
    +c:Wrong number of Savable arrays for '  '.  size says    , data contains.

com.jme3.export.xml.DOMInputCapsule#readSavableArrayListArray(Ljava/lang/String;[Ljava/util/ArrayList;)[Ljava/util/ArrayList;
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readSavableArrayListArray2D(Ljava/lang/String;[[Ljava/util/ArrayList;)[[Ljava/util/ArrayList;
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readFloatBufferArrayList(Ljava/lang/String;Ljava/util/ArrayList;)Ljava/util/ArrayList;
  name
    +c:

com.jme3.export.xml.DOMInputCapsule#readFloatBuffer(Ljava/lang/String;Ljava/nio/FloatBuffer;)Ljava/nio/FloatBuffer;
  name
    +c:Wrong number of float buffers for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readIntBuffer(Ljava/lang/String;Ljava/nio/IntBuffer;)Ljava/nio/IntBuffer;
  name
    +c:Wrong number of int buffers for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readByteBuffer(Ljava/lang/String;Ljava/nio/ByteBuffer;)Ljava/nio/ByteBuffer;
  name
    +c:Wrong number of byte buffers for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readShortBuffer(Ljava/lang/String;Ljava/nio/ShortBuffer;)Ljava/nio/ShortBuffer;
  name
    +c:Wrong number of short buffers for '  '.  size says    , data contains    data.

com.jme3.export.xml.DOMInputCapsule#readByteBufferArrayList(Ljava/lang/String;Ljava/util/ArrayList;)Ljava/util/ArrayList;
  name
    +c:Wrong number of short buffers for '  '.  size says    , data contains.

com.jme3.terrain.GeoMap#writeNormalArray(Ljava/nio/FloatBuffer;Lcom/jme3/math/Vector3f;)Ljava/nio/FloatBuffer;
  store
    +d: A preallocated FloatBuffer where to store the data (optional), size must be >= getWidth()*getHeight()*3
    +c:.

com.jme3.terrain.GeoMap#writeVertexArray(Ljava/nio/FloatBuffer;Lcom/jme3/math/Vector3f;Z)Ljava/nio/FloatBuffer;
  store
    +d: A preallocated FloatBuffer where to store the data (optional), size must be >= getWidth()*getHeight()*3
    +c:.

com.jme3.terrain.GeoMap#writeTexCoordArray(Ljava/nio/FloatBuffer;Lcom/jme3/math/Vector2f;Lcom/jme3/math/Vector2f;)Ljava/nio/FloatBuffer;
  store
    +c:.

com.jme3.terrain.GeoMap#writeIndexArray(Ljava/nio/IntBuffer;)Ljava/nio/IntBuffer;
  store
    +c:.

com.jme3.terrain.geomipmap.TerrainLodControl#<init>(Lcom/jme3/terrain/Terrain;Ljava/util/List;)V
  terrain
    +d: to act upon (must be a Spatial)

com.jme3.terrain.geomipmap.TerrainQuad#<init>(Ljava/lang/String;II[F)V
  patchSize
    +d: size of the individual patches (geometry). Power of 2 plus 1, must be smaller than totalSize. (eg. 33, 65...)
  heightMap
    +d: The height map to generate the terrain from (a flat height map will be generated if this is null). The size of one side of the heightmap must match the totalSize. So a 513x513 heightmap is needed for a terrain with totalSize of 513.

com.jme3.terrain.geomipmap.TerrainQuad#<init>(Ljava/lang/String;IILcom/jme3/math/Vector3f;[F)V
  size
    +d: size of this quad, can be between totalSize and patchSize

com.jme3.terrain.geomipmap.TerrainQuad#<init>(Ljava/lang/String;IILcom/jme3/math/Vector3f;[FILcom/jme3/math/Vector2f;F)V
  quadSize
    +c:size given:     Terrain quad sizes may only be (2^N + 1).

com.jme3.terrain.geomipmap.TerrainQuad#setHeight(Ljava/util/List;Ljava/util/List;Z)V
  height
    +c:"Both lists must be the same length!".

com.jme3.terrain.geomipmap.LODGeomap#writeTexCoordArray(Ljava/nio/FloatBuffer;Lcom/jme3/math/Vector2f;Lcom/jme3/math/Vector2f;FI)Ljava/nio/FloatBuffer;
  store
    +c:.

com.jme3.terrain.geomipmap.LODGeomap#writeTangentArray(Ljava/nio/FloatBuffer;Ljava/nio/FloatBuffer;Ljava/nio/FloatBuffer;Ljava/nio/FloatBuffer;Lcom/jme3/math/Vector3f;)[Ljava/nio/FloatBuffer;
  tangentStore
    +c:.
  binormalStore
    +c:.

com.jme3.terrain.geomipmap.LODGeomap#writeNormalArray(Ljava/nio/FloatBuffer;Lcom/jme3/math/Vector3f;)Ljava/nio/FloatBuffer;
  store
    +c:.

com.jme3.terrain.geomipmap.TerrainPatch#collideWith(Lcom/jme3/collision/Collidable;Lcom/jme3/collision/CollisionResults;)I
  other
    +c:TerrainPatch cannnot collide with.

com.jme3.terrain.geomipmap.UpdatedTerrainPatch#setNewLod(I)V
  newLod
    +c:newLod cannot be less than zero, was:.

com.jme3.terrain.heightmap.FaultHeightMap#<init>(IIIIFFJ)V
  iterations
    +c:"Size and iterations must be greater than 0!".

com.jme3.terrain.heightmap.RawHeightMap#<init>(Ljava/lang/String;I)V
  size
    +d: the size of the RAW (must be square).

com.jme3.terrain.heightmap.RawHeightMap#<init>(Ljava/lang/String;IIZ)V
  filename
    +c:Must supply valid filename and  size (> 0).height file not found:.

com.jme3.terrain.heightmap.RawHeightMap#<init>(Ljava/net/URL;IIZ)V
  resource
    +c:Must supply valid resource and  size (> 0).Unable to open height url:.

com.jme3.terrain.heightmap.RawHeightMap#setup(Ljava/io/InputStream;IIZ)V
  stream
    +c:Must supply valid stream and  size (> 0).

com.jme3.terrain.heightmap.RawHeightMap#setFilename(Ljava/lang/String;)V
  filename
    +c:"Must supply valid filename.".height file not found:.

com.jme3.terrain.heightmap.RawHeightMap#setHeightStream(Ljava/io/InputStream;)V
  stream
    +c:"Must supply valid stream.".

com.jme3.terrain.heightmap.HillHeightMap#<init>(IIFFJ)V
  size
    +c:Either size of the terrain is not greater that zero,  or number of iterations is not greater that zero,  or minimum or maximum radius are not greater than zero,  or minimum radius is greater than maximum radius,  or power of flattening is below one.

com.jme3.terrain.heightmap.HillHeightMap#setIterations(I)V
  iterations
    +c:"Number of iterations is not greater than zero".

com.jme3.terrain.heightmap.HillHeightMap#setMaxRadius(F)V
  maxRadius
    +c:The maximum radius is not greater than 0,  or not greater than the minimum radius.

com.jme3.terrain.heightmap.HillHeightMap#setMinRadius(F)V
  minRadius
    +c:The minimum radius is not greater than 0,  or not lower than the maximum radius.

com.jme3.terrain.heightmap.FluidSimHeightMap#<init>(IIFFFFFFJ)V
  size
    +c:Either size of the terrain is not greater that zero,  or number of iterations is not greater that zero,  or minimum height greater or equal as the maximum,  or maximum height smaller or equal as the minimum.

com.jme3.terrain.heightmap.FluidSimHeightMap#<init>(II)V
  size
    +c:Either size of the terrain is not greater that zero,  or number of iterations is not greater that zero.

com.jme3.terrain.heightmap.FluidSimHeightMap#setIterations(I)V
  iterations
    +c:"Number of iterations is not greater than zero".

com.jme3.terrain.heightmap.MidpointDisplacementHeightMap#<init>(IFFJ)V
  size
    +d: The size of the heightmap, must be 2^N+1
    +c:The size is negative or not of the form 2^N +1  (a power of two plus one).

com.jme3.terrain.heightmap.MidpointDisplacementHeightMap#<init>(IFF)V
  size
    +d: The size of the heightmap, must be 2^N+1

com.jme3.terrain.heightmap.ParticleDepositionHeightMap#<init>(IIIIIF)V
  minParticles
    +c:values must be greater than zero,  and minParticles must be greater than maxParticles.
  caldera
    +c:Caldera level must be  between 0 and 1.

com.jme3.terrain.heightmap.ParticleDepositionHeightMap#setJumps(I)V
  jumps
    +c:"jumps must be positive".

com.jme3.terrain.heightmap.ParticleDepositionHeightMap#setPeakWalk(I)V
  peakWalk
    +c:peakWalk must be greater than  zero.

com.jme3.terrain.heightmap.ParticleDepositionHeightMap#setCaldera(F)V
  caldera
    +d: the level at which a peak will be inverted. This must be between 0 and 1, as it is represented as a percentage.
    +c:Caldera level must be  between 0 and 1.

com.jme3.terrain.heightmap.ParticleDepositionHeightMap#setMinParticles(I)V
  minParticles
    +c:minParticles must be less  than the current maxParticles.

com.jme3.terrain.heightmap.CombinerHeightMap#<init>(Lcom/jme3/terrain/heightmap/AbstractHeightMap;Lcom/jme3/terrain/heightmap/AbstractHeightMap;I)V
  map1
    +c:"Height map may not be null"."The two maps must be of the same size".

com.jme3.terrain.heightmap.CombinerHeightMap#<init>(Lcom/jme3/terrain/heightmap/AbstractHeightMap;FLcom/jme3/terrain/heightmap/AbstractHeightMap;FI)V
  map1
    +c:"Height map may not be null"."The two maps must be of the same size".
  factor1
    +c:"factor1 and factor2 must add to 1.0".

com.jme3.terrain.heightmap.CombinerHeightMap#setFactors(FF)V
  factor1
    +c:"factor1 and factor2 must add to 1.0".

com.jme3.terrain.heightmap.CombinerHeightMap#setHeightMaps(Lcom/jme3/terrain/heightmap/AbstractHeightMap;Lcom/jme3/terrain/heightmap/AbstractHeightMap;)V
  map1
    +c:"Height map may not be null"."The two maps must be of the same size".

com.jme3.terrain.heightmap.CombinerHeightMap#setMode(I)V
  mode
    +c:"Invalid mode".

com.jme3.terrain.noise.ShaderUtils#spline(F[F)F
  knot
    +c:

