org.apache.lucene.analysis.ar.ArabicNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ar.ArabicStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.bg.BulgarianStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.bn.BengaliStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.bn.BengaliNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.br.BrazilianStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.charfilter.HTMLStripCharFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.charfilter.NormalizeCharMap#<init>(Lorg/apache/lucene/util/fst/FST;)V
  map
    +c:.

org.apache.lucene.analysis.charfilter.MappingCharFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.charfilter.MappingCharFilterFactory#parseString(Ljava/lang/String;)Ljava/lang/String;
  s
    +c:Invalid escaped char in [  ].Invalid escaped char in [  ].

org.apache.lucene.analysis.cjk.CJKBigramFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.cjk.CJKWidthFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ckb.SoraniNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ckb.SoraniStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.commongrams.CommonGramsFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.compound.HyphenationCompoundWordTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.compound.DictionaryCompoundWordTokenFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;Lorg/apache/lucene/analysis/CharArraySet;)V
  dictionary
    +c:"dictionary must not be null".

org.apache.lucene.analysis.compound.DictionaryCompoundWordTokenFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;Lorg/apache/lucene/analysis/CharArraySet;IIIZ)V
  dictionary
    +c:"dictionary must not be null".

org.apache.lucene.analysis.compound.DictionaryCompoundWordTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.compound.hyphenation.HyphenationTree#addPattern(Ljava/lang/String;Ljava/lang/String;)V
  ivalue
    +d: interletter weight values indicating the desirability and priority of hyphenating at a given point within the pattern. It should contain only digit characters. (i.e. '0' to '9').

org.apache.lucene.analysis.core.LetterTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;I)V
  maxTokenLen
    +d: maximum token length the tokenizer will emit. Must be greater than 0 and less than MAX_TOKEN_LENGTH_LIMIT (1024*1024)

org.apache.lucene.analysis.core.LetterTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.core.UpperCaseFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.core.WhitespaceTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.core.UnicodeWhitespaceTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;I)V
  maxTokenLen
    +d: maximum token length the tokenizer will emit. Must be greater than 0 and less than MAX_TOKEN_LENGTH_LIMIT (1024*1024)

org.apache.lucene.analysis.core.WhitespaceTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;I)V
  maxTokenLen
    +d: maximum token length the tokenizer will emit. Must be greater than 0 and less than MAX_TOKEN_LENGTH_LIMIT (1024*1024)

org.apache.lucene.analysis.core.FlattenGraphFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.core.KeywordTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.core.StopFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.core.DecimalDigitFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.core.KeywordTokenizer#<init>(I)V
  bufferSize
    +c:maxTokenLen must be greater than 0 and less than    passed:.

org.apache.lucene.analysis.core.KeywordTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;I)V
  bufferSize
    +c:maxTokenLen must be greater than 0 and less than    passed:.

org.apache.lucene.analysis.core.LowerCaseFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.core.TypeTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.cz.CzechStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.de.GermanStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.de.GermanLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.de.GermanMinimalStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.de.GermanNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.el.GreekStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.el.GreekLowerCaseFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.en.KStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.en.PorterStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.en.EnglishMinimalStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.en.EnglishPossessiveFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.es.SpanishLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.fa.PersianNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.fa.PersianCharFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.fi.FinnishLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.fr.FrenchLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.fr.FrenchMinimalStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ga.IrishLowerCaseFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.gl.GalicianMinimalStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.gl.GalicianStemmer#stem([CI)I
  s
    +c:
  len
    +c:

org.apache.lucene.analysis.gl.GalicianStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.hi.HindiNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.hi.HindiStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.hu.HungarianLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.hunspell.HunspellStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.hunspell.Dictionary#<init>(Lorg/apache/lucene/store/Directory;Ljava/lang/String;Ljava/io/InputStream;Ljava/util/List;Z)V
  affix
    +c:

org.apache.lucene.analysis.hunspell.Dictionary#lookupWord([CII)Lorg/apache/lucene/util/IntsRef;
  offset
    +c:
  length
    +c:

org.apache.lucene.analysis.hunspell.Dictionary#lookupPrefix([CII)Lorg/apache/lucene/util/IntsRef;
  offset
    +c:
  length
    +c:

org.apache.lucene.analysis.hunspell.Dictionary#lookupSuffix([CII)Lorg/apache/lucene/util/IntsRef;
  offset
    +c:
  length
    +c:

org.apache.lucene.analysis.hunspell.Dictionary#lookup(Lorg/apache/lucene/util/fst/FST;[CII)Lorg/apache/lucene/util/IntsRef;
  offset
    +c:
  length
    +c:

org.apache.lucene.analysis.hunspell.Dictionary#getDictionaryEncoding(Ljava/io/InputStream;)Ljava/lang/String;
  affix
    +c:

org.apache.lucene.analysis.hunspell.Dictionary#getFlagParsingStrategy(Ljava/lang/String;)Lorg/apache/lucene/analysis/hunspell/Dictionary$FlagParsingStrategy;
  flagLine
    +c:Illegal FLAG specification:.

org.apache.lucene.analysis.id.IndonesianStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.in.IndicNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.it.ItalianLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.lv.LatvianStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.minhash.MinHashFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;IIIZ)V
  hashCount
    +c:"hashCount must be greater than zero".
  bucketCount
    +c:"bucketCount must be greater than zero".
  hashSetSize
    +c:"hashSetSize must be greater than zero".

org.apache.lucene.analysis.miscellaneous.LimitTokenPositionFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.FingerprintFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.HyphenatedWordsFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.LimitTokenOffsetFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;IZ)V
  maxStartOffset
    +c:"maxStartOffset must be >= zero".

org.apache.lucene.analysis.miscellaneous.RemoveDuplicatesTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.ConcatenateGraphFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;ZZI)V
  preserveSep
    +d: Whether #SEP_LABEL should separate the input tokens in the concatenated token

org.apache.lucene.analysis.miscellaneous.TruncateTokenFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;I)V
  length
    +c:length parameter must be a positive number:.

org.apache.lucene.analysis.miscellaneous.CapitalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.DateRecognizerFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.TypeAsSynonymFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.LengthFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;II)V
  min
    +c:"minimum length must be greater than or equal to zero"."maximum length must not be greater than minimum length".

org.apache.lucene.analysis.miscellaneous.ProtectedTermFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.ScandinavianFoldingFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.ScandinavianNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.WordDelimiterGraphFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.CodepointCountFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.WordDelimiterFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.DelimitedTermFrequencyTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.StemmerOverrideFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.CodepointCountFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;II)V
  min
    +c:"minimum length must be greater than or equal to zero"."maximum length must not be greater than minimum length".

org.apache.lucene.analysis.miscellaneous.KeepWordFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.ConcatenatingTokenStream#<init>([Lorg/apache/lucene/analysis/TokenStream;)V
  sources
    +c:

org.apache.lucene.analysis.miscellaneous.KeywordMarkerFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.WordDelimiterGraphFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;[BILorg/apache/lucene/analysis/CharArraySet;)V
  configurationFlags
    +c:flags contains unrecognized flag:.

org.apache.lucene.analysis.miscellaneous.WordDelimiterGraphFilter#buffer(IIII)V
  startPos
    +c:
  endPos
    +c:
  startPart
    +c:
  endPart
    +c:

org.apache.lucene.analysis.miscellaneous.WordDelimiterGraphFilter#buffer([CIIII)V
  startPos
    +c:
  endPos
    +c:
  startPart
    +c:
  endPart
    +c:

org.apache.lucene.analysis.miscellaneous.LengthFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.KeywordRepeatFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.TrimFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.LimitTokenCountFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;IZ)V
  maxTokenCount
    +c:"maxTokenCount must be greater than zero".

org.apache.lucene.analysis.miscellaneous.ConcatenateGraphFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.LimitTokenCountFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.LimitTokenOffsetFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.miscellaneous.CapitalizationFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;ZLorg/apache/lucene/analysis/CharArraySet;ZLjava/util/Collection;III)V
  minWordLength
    +c:"minWordLength must be greater than or equal to zero".
  maxWordCount
    +c:"maxWordCount must be greater than zero".
  maxTokenLength
    +c:"maxTokenLength must be greater than zero".

org.apache.lucene.analysis.miscellaneous.LimitTokenPositionFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;IZ)V
  maxTokenPosition
    +c:"maxTokenPosition must be greater than zero".

org.apache.lucene.analysis.miscellaneous.TruncateTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameter(s):.

org.apache.lucene.analysis.ngram.EdgeNGramTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ngram.NGramFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ngram.EdgeNGramFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ngram.EdgeNGramTokenFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;IIZ)V
  minGram
    +c:"minGram must be greater than zero"."minGram must not be greater than maxGram".

org.apache.lucene.analysis.ngram.NGramTokenizer#init(IIZ)V
  minGram
    +c:"minGram must be greater than zero"."minGram must not be greater than maxGram".

org.apache.lucene.analysis.ngram.NGramTokenFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;IIZ)V
  minGram
    +c:"minGram must be greater than zero"."minGram must not be greater than maxGram".

org.apache.lucene.analysis.ngram.NGramTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.nl.DutchAnalyzer#<init>(Lorg/apache/lucene/analysis/CharArraySet;Lorg/apache/lucene/analysis/CharArraySet;Lorg/apache/lucene/analysis/CharArrayMap;)V
  stemOverrideDict
    +c:"can not build stem dict".

org.apache.lucene.analysis.no.NorwegianMinimalStemmer#<init>(I)V
  flags
    +c:"invalid flags".

org.apache.lucene.analysis.no.NorwegianLightStemmer#<init>(I)V
  flags
    +c:"invalid flags".

org.apache.lucene.analysis.no.NorwegianLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.no.NorwegianMinimalStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.path.ReversePathHierarchyTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;ICCI)V
  bufferSize
    +c:"bufferSize cannot be negative".
  skip
    +c:"skip cannot be negative".

org.apache.lucene.analysis.path.PathHierarchyTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.path.PathHierarchyTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;ICCI)V
  bufferSize
    +c:"bufferSize cannot be negative".
  skip
    +c:"skip cannot be negative".

org.apache.lucene.analysis.pattern.SimplePatternSplitTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;Lorg/apache/lucene/util/automaton/Automaton;)V
  dfa
    +c:"please determinize the incoming automaton first".

org.apache.lucene.analysis.pattern.PatternReplaceCharFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.pattern.SimplePatternSplitTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.pattern.SimplePatternTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;Lorg/apache/lucene/util/automaton/Automaton;)V
  dfa
    +c:"please determinize the incoming automaton first".

org.apache.lucene.analysis.pattern.PatternTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.pattern.PatternTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;Ljava/util/regex/Pattern;I)V
  group
    +c:invalid group specified: pattern only has:       capturing groups.

org.apache.lucene.analysis.pattern.SimplePatternTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.pattern.PatternReplaceFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.payloads.TokenOffsetPayloadTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.payloads.NumericPayloadTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.payloads.TypeAsPayloadTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.payloads.DelimitedPayloadTokenFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.payloads.NumericPayloadTokenFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;FLjava/lang/String;)V
  typeMatch
    +c:"typeMatch must not be null".

org.apache.lucene.analysis.pt.PortugueseStemmer#stem([CI)I
  s
    +c:
  len
    +c:

org.apache.lucene.analysis.pt.PortugueseLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.pt.PortugueseMinimalStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.pt.PortugueseStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.query.QueryAutoStopWordAnalyzer#<init>(Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/index/IndexReader;I)V
  maxDocFreq
    +d: Document frequency terms should be above in order to be stopwords

org.apache.lucene.analysis.query.QueryAutoStopWordAnalyzer#<init>(Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/index/IndexReader;Ljava/util/Collection;I)V
  maxDocFreq
    +d: Document frequency terms should be above in order to be stopwords

org.apache.lucene.analysis.reverse.ReverseStringFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ru.RussianLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.shingle.ShingleAnalyzerWrapper#<init>(Lorg/apache/lucene/analysis/Analyzer;IILjava/lang/String;ZZLjava/lang/String;)V
  minShingleSize
    +c:"Min shingle size must be >= 2"."Min shingle size must be <= max shingle size".
  maxShingleSize
    +c:"Max shingle size must be >= 2".

org.apache.lucene.analysis.shingle.FixedShingleFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;ILjava/lang/String;Ljava/lang/String;)V
  shingleSize
    +c:Shingle size must be between 2 and   , got.

org.apache.lucene.analysis.shingle.ShingleFilter#setMaxShingleSize(I)V
  maxShingleSize
    +c:"Max shingle size must be >= 2".

org.apache.lucene.analysis.shingle.ShingleFilter#setMinShingleSize(I)V
  minShingleSize
    +c:"Min shingle size must be >= 2"."Min shingle size must be <= max shingle size".

org.apache.lucene.analysis.shingle.ShingleFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.snowball.SnowballFilter#<init>(Lorg/apache/lucene/analysis/TokenStream;Ljava/lang/String;)V
  name
    +c:Invalid stemmer class specified:.

org.apache.lucene.analysis.snowball.SnowballPorterFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.sr.SerbianNormalizationFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.standard.UAX29URLEmailTokenizerImpl#yypushback(I)V
  number
    +d:  the number of characters to be read again. This number must not be greater than yylength()!

org.apache.lucene.analysis.standard.ClassicTokenizer#setMaxTokenLength(I)V
  length
    +c:"maxTokenLength must be greater than zero".

org.apache.lucene.analysis.standard.ClassicTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.standard.UAX29URLEmailTokenizer#setMaxTokenLength(I)V
  length
    +c:"maxTokenLength must be greater than zero".maxTokenLength may not exceed.

org.apache.lucene.analysis.standard.UAX29URLEmailTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.standard.ClassicFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.standard.StandardTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.sv.SwedishLightStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.synonym.SynonymFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.synonym.SynonymGraphFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.th.ThaiTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.tr.ApostropheFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameter(s):.

org.apache.lucene.analysis.tr.TurkishLowerCaseFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.util.ElisionFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.util.ClasspathResourceLoader#openResource(Ljava/lang/String;)Ljava/io/InputStream;
  resource
    +c:Resource not found:.

org.apache.lucene.analysis.util.ClasspathResourceLoader#findClass(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Class;
  cname
    +c:Cannot load class:.

org.apache.lucene.analysis.util.ClasspathResourceLoader#newInstance(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;
  cname
    +c:Cannot create instance:.

org.apache.lucene.analysis.util.FilesystemResourceLoader#<init>(Ljava/nio/file/Path;Lorg/apache/lucene/analysis/util/ResourceLoader;)V
  baseDirectory
    +c:.is not a directory.
  delegate
    +c:"delegate ResourceLoader may not be null".

org.apache.lucene.analysis.util.AnalysisSPILoader#lookupClass(Ljava/lang/String;)Ljava/lang/Class;
  name
    +c:A SPI class of type     with name '  ' does not exist.  You need to add the corresponding JAR file supporting this SPI to your classpath.  The current classpath supports the following names:.

org.apache.lucene.analysis.util.AnalysisSPILoader#newFactoryClassInstance(Ljava/lang/Class;Ljava/util/Map;)Lorg/apache/lucene/analysis/util/AbstractAnalysisFactory;
  clazz
    +c:Unexpected checked exception while calling constructor of.Factory     cannot be instantiated. This is likely due to missing Map<String,String> constructor.

org.apache.lucene.analysis.util.StemmerUtil#delete([CII)I
  pos
    +c:
  len
    +c:

org.apache.lucene.analysis.util.StemmerUtil#deleteN([CIII)I
  pos
    +c:
  len
    +c:
  nChars
    +c:

org.apache.lucene.analysis.util.RollingCharBuffer#get(I)I
  pos
    +c:..

org.apache.lucene.analysis.util.RollingCharBuffer#get(II)[C
  length
    +c:.

org.apache.lucene.analysis.util.RollingCharBuffer#freeBefore(I)V
  pos
    +c:..

org.apache.lucene.analysis.wikipedia.WikipediaTokenizer#init(ILjava/util/Set;)V
  tokenOutput
    +c:"tokenOutput must be TOKENS_ONLY, UNTOKENIZED_ONLY or BOTH".

org.apache.lucene.analysis.wikipedia.WikipediaTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.tartarus.snowball.Among#<init>(Ljava/lang/String;IILjava/lang/String;Ljava/lang/invoke/MethodHandles$Lookup;)V
  methodname
    +c:Snowball program '%s' is broken, cannot access method: boolean %s().

org.apache.lucene.analysis.icu.ICUTransformFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.icu.ICUNormalizer2FilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.icu.ICUNormalizer2CharFilter#read([CII)I
  off
    +c:"off < 0"."off >= cbuf.length".
  len
    +c:"len <= 0".

org.apache.lucene.analysis.icu.ICUNormalizer2CharFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.icu.ICUFoldingFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.icu.segmentation.ICUTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.icu.segmentation.ICUTokenizer#read(Ljava/io/Reader;[CII)I
  length
    +c:.

org.apache.lucene.analysis.ja.JapaneseBaseFormFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ja.JapaneseNumberFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ja.JapaneseReadingFormFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ja.JapaneseIterationMarkCharFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ja.JapanesePartOfSpeechStopFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ja.JapaneseIterationMarkCharFilter#sourceCharacter(II)C
  position
    +d: buffer position (should not exceed bufferPosition)

org.apache.lucene.analysis.ja.JapaneseKatakanaStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ja.dict.TokenInfoFST#findTargetArc(ILorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/util/fst/FST$Arc;ZLorg/apache/lucene/util/fst/FST$BytesReader;)Lorg/apache/lucene/util/fst/FST$Arc;
  ch
    +c:.

org.apache.lucene.analysis.morfologik.MorfologikFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ko.KoreanPartOfSpeechStopFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ko.KoreanReadingFormFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.ko.dict.TokenInfoFST#findTargetArc(ILorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/util/fst/FST$Arc;ZLorg/apache/lucene/util/fst/FST$BytesReader;)Lorg/apache/lucene/util/fst/FST$Arc;
  ch
    +c:.

org.apache.lucene.analysis.opennlp.OpenNLPSentenceBreakIterator#following(I)I
  pos
    +c:"offset out of bounds".

org.apache.lucene.analysis.opennlp.OpenNLPSentenceBreakIterator#moveToSentenceAt(III)V
  pos
    +c:..
  minSentence
    +c:.

org.apache.lucene.analysis.opennlp.OpenNLPSentenceBreakIterator#preceding(I)I
  pos
    +c:"offset out of bounds".

org.apache.lucene.analysis.opennlp.OpenNLPPOSFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.opennlp.OpenNLPChunkerFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.opennlp.OpenNLPTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.opennlp.OpenNLPLemmatizerFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.opennlp.OpenNLPTokenizer#<init>(Lorg/apache/lucene/util/AttributeFactory;Lorg/apache/lucene/analysis/opennlp/tools/NLPSentenceDetectorOp;Lorg/apache/lucene/analysis/opennlp/tools/NLPTokenizerOp;)V
  tokenizerOp
    +c:"OpenNLPTokenizer: both a Sentence Detector and a Tokenizer are required".

org.apache.lucene.analysis.opennlp.tools.OpenNLPOpsFactory#getLemmatizer(Ljava/lang/String;Ljava/lang/String;)Lorg/apache/lucene/analysis/opennlp/tools/NLPLemmatizerOp;
  dictionaryFile
    +c:
  lemmatizerModelFile
    +c:

org.apache.lucene.analysis.phonetic.BeiderMorseFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.phonetic.DaitchMokotoffSoundexFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.phonetic.DoubleMetaphoneFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.phonetic.PhoneticFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.analysis.stempel.StempelPolishStemFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.benchmark.byTask.feeds.LineDocSource#setConfig(Lorg/apache/lucene/benchmark/byTask/utils/Config;)V
  config
    +c:

org.apache.lucene.benchmark.byTask.stats.TaskStats#add(Lorg/apache/lucene/benchmark/byTask/stats/TaskStats;)V
  stat2
    +c:"different by-time msec step"."different by-time msec count".

org.apache.lucene.benchmark.byTask.tasks.CreateIndexTask#createWriterConfig(Lorg/apache/lucene/benchmark/byTask/utils/Config;Lorg/apache/lucene/benchmark/byTask/PerfRunData;Lorg/apache/lucene/index/IndexWriterConfig$OpenMode;Lorg/apache/lucene/index/IndexCommit;)Lorg/apache/lucene/index/IndexWriterConfig;
  config
    +c:

org.apache.lucene.benchmark.byTask.tasks.CreateIndexTask#configureWriter(Lorg/apache/lucene/benchmark/byTask/utils/Config;Lorg/apache/lucene/benchmark/byTask/PerfRunData;Lorg/apache/lucene/index/IndexWriterConfig$OpenMode;Lorg/apache/lucene/index/IndexCommit;)Lorg/apache/lucene/index/IndexWriter;
  config
    +c:

org.apache.lucene.benchmark.byTask.tasks.OpenReaderTask#findIndexCommit(Lorg/apache/lucene/store/Directory;Ljava/lang/String;)Lorg/apache/lucene/index/IndexCommit;
  userData
    +c:index does not contain commit with userData:.

org.apache.lucene.benchmark.byTask.tasks.TaskSequence#setRepetitions(I)V
  repetitions
    +c:

org.apache.lucene.benchmark.byTask.tasks.AnalyzerFactoryTask#setParams(Ljava/lang/String;)V
  params
    +c:Line #    : Missing 'name' param to AnalyzerFactory: '  '.

org.apache.lucene.benchmark.byTask.tasks.AnalyzerFactoryTask#lookupAnalysisClass(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Class;
  className
    +c:Can't find class '  ' or '   '.Can't find class '  '.

org.apache.lucene.benchmark.byTask.tasks.WaitTask#setParams(Ljava/lang/String;)V
  params
    +c:"you must specify the wait time, eg: 10.0s, 4.5m, 2h".

org.apache.lucene.benchmark.byTask.utils.Format#format(IFLjava/lang/String;)Ljava/lang/String;
  numFracDigits
    +d: number of digits in fraction part - must be 0 or 1 or 2.

org.apache.lucene.benchmark.byTask.utils.Format#formatPaddRight(IFLjava/lang/String;)Ljava/lang/String;
  numFracDigits
    +d: number of digits in fraction part - must be 0 or 1 or 2.

org.apache.lucene.benchmark.byTask.utils.Algorithm#taskClass(Lorg/apache/lucene/benchmark/byTask/utils/Config;Ljava/lang/String;)Ljava/lang/Class;
  taskName
    +c:not found in packages.

org.apache.lucene.benchmark.byTask.utils.AnalyzerFactory#<init>(Ljava/util/List;Lorg/apache/lucene/analysis/util/TokenizerFactory;Ljava/util/List;)V
  tokenizerFactory
    +c:.

org.apache.lucene.benchmark.byTask.utils.Config#set(Ljava/lang/String;Ljava/lang/String;)V
  name
    +c:"Cannot modify a multi value property!".

org.apache.lucene.benchmark.quality.QualityQuery#getValue(Ljava/lang/String;)Ljava/lang/String;
  name
    +d: the name whose value should be returned. 

org.apache.lucene.benchmark.quality.QualityStats#addResult(IZJ)V
  n
    +c:point    illegal after     points!.

org.apache.lucene.benchmark.quality.QualityStats#getPrecisionAt(I)D
  n
    +d: requested precision point, must be at least 1 and at most #MAX_POINTS . 
    +c:n=   - but it must be in [1,  ] range!.

org.apache.lucene.benchmark.quality.QualityStats#average([Lorg/apache/lucene/benchmark/quality/QualityStats;)Lorg/apache/lucene/benchmark/quality/QualityStats;
  stats
    +c:

org.apache.lucene.classification.KNearestNeighborClassifier#<init>(Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/search/similarities/Similarity;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/search/Query;IIILjava/lang/String;[Ljava/lang/String;)V
  textFieldNames
    +d: the name of the fields used as the inputs for the classifier, they can contain boosting indication e.g. title^10

org.apache.lucene.classification.BooleanPerceptronClassifier#<init>(Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/search/Query;Ljava/lang/Integer;Ljava/lang/Double;Ljava/lang/String;Ljava/lang/String;)V
  indexReader
    +c:
  textFieldName
    +c:term vectors need to be available for field.bias cannot be assigned since term vectors for field    do not exist.

org.apache.lucene.classification.KNearestFuzzyClassifier#<init>(Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/search/similarities/Similarity;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/search/Query;ILjava/lang/String;[Ljava/lang/String;)V
  textFieldNames
    +d: the name of the fields used as the inputs for the classifier, they can contain boosting indication e.g. title^10

org.apache.lucene.classification.document.KNearestNeighborDocumentClassifier#<init>(Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/search/similarities/Similarity;Lorg/apache/lucene/search/Query;IIILjava/lang/String;Ljava/util/Map;[Ljava/lang/String;)V
  textFieldNames
    +d: the name of the fields used as the inputs for the classifier, they can contain boosting indication e.g. title^10

org.apache.lucene.classification.document.SimpleNaiveBayesDocumentClassifier#<init>(Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/search/Query;Ljava/lang/String;Ljava/util/Map;[Ljava/lang/String;)V
  textFieldNames
    +d: the name of the fields used as the inputs for the classifier, they can contain boosting indication e.g. title^10

org.apache.lucene.classification.utils.DatasetSplitter#split(Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/analysis/Analyzer;ZLjava/lang/String;[Ljava/lang/String;)V
  termVectors
    +c:
  classFieldName
    +d:       name of the field used as the label for classification; this must be indexed with sorted doc values
    +c:

org.apache.lucene.codecs.blockterms.FixedGapTermsIndexWriter#<init>(Lorg/apache/lucene/index/SegmentWriteState;I)V
  termIndexInterval
    +c:invalid termIndexInterval:.

org.apache.lucene.codecs.blockterms.BlockTermsReader#<init>(Lorg/apache/lucene/codecs/blockterms/TermsIndexReaderBase;Lorg/apache/lucene/codecs/PostingsReaderBase;Lorg/apache/lucene/index/SegmentReadState;)V
  state
    +c:invalid docCount:     maxDoc:.

org.apache.lucene.codecs.blockterms.BlockTermsReader#terms(Ljava/lang/String;)Lorg/apache/lucene/index/Terms;
  field
    +c:.

org.apache.lucene.codecs.blockterms.BlockTermsWriter#addField(Lorg/apache/lucene/index/FieldInfo;)Lorg/apache/lucene/codecs/blockterms/BlockTermsWriter$TermsWriter;
  field
    +c:.

org.apache.lucene.codecs.blocktreeords.OrdsSegmentTermsEnum#pushFrame(Lorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/codecs/blocktreeords/FSTOrdsOutputs$Output;I)Lorg/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame;
  length
    +c:

org.apache.lucene.codecs.blocktreeords.OrdsSegmentTermsEnum#pushFrame(Lorg/apache/lucene/util/fst/FST$Arc;JIJ)Lorg/apache/lucene/codecs/blocktreeords/OrdsSegmentTermsEnumFrame;
  length
    +c:.
  termOrd
    +c:.

org.apache.lucene.codecs.blocktreeords.OrdsSegmentTermsEnum#seekExact(Lorg/apache/lucene/util/BytesRef;)Z
  target
    +c:..

org.apache.lucene.codecs.blocktreeords.OrdsSegmentTermsEnum#seekCeil(Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/index/TermsEnum$SeekStatus;
  target
    +c:..

org.apache.lucene.codecs.blocktreeords.OrdsSegmentTermsEnum#seekExact(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/index/TermState;)V
  target
    +c:
  otherState
    +c:.

org.apache.lucene.codecs.blocktreeords.OrdsSegmentTermsEnum#seekExact(J)V
  targetOrd
    +c:targetOrd out of bounds (got:   , numTerms=   )..

org.apache.lucene.codecs.blocktreeords.OrdsBlockTreeTermsWriter#write(Lorg/apache/lucene/index/Fields;Lorg/apache/lucene/codecs/NormsProducer;)V
  fields
    +c:

org.apache.lucene.codecs.blocktreeords.OrdsBlockTreeTermsWriter#encodeOutput(JZZ)J
  fp
    +c:.

org.apache.lucene.codecs.blocktreeords.OrdsBlockTreeTermsReader#<init>(Lorg/apache/lucene/codecs/PostingsReaderBase;Lorg/apache/lucene/index/SegmentReadState;)V
  state
    +c:invalid docCount:     maxDoc:.

org.apache.lucene.codecs.blocktreeords.OrdsBlockTreeTermsReader#terms(Ljava/lang/String;)Lorg/apache/lucene/index/Terms;
  field
    +c:.

org.apache.lucene.codecs.blocktreeords.FSTOrdsOutputs$Output#<init>(Lorg/apache/lucene/util/BytesRef;JJ)V
  startOrd
    +c:.
  endOrd
    +c:.

org.apache.lucene.codecs.bloom.FuzzySet#hashFunctionForVersion(I)Lorg/apache/lucene/codecs/bloom/HashFunction;
  version
    +c:Version    is too old, expected at least.Version    is too new, expected at most.

org.apache.lucene.codecs.bloom.FuzzySet#mayContainValue(I)Lorg/apache/lucene/codecs/bloom/FuzzySet$ContainsResult;
  positiveHash
    +c:.

org.apache.lucene.codecs.memory.FSTTermsReader#checkFieldSummary(Lorg/apache/lucene/index/SegmentInfo;Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/codecs/memory/FSTTermsReader$TermsReader;Lorg/apache/lucene/codecs/memory/FSTTermsReader$TermsReader;)V
  field
    +c:invalid docCount:     maxDoc:.invalid sumDocFreq:     docCount:.invalid sumTotalTermFreq:     sumDocFreq:.
  previous
    +c:duplicate fields:.

org.apache.lucene.codecs.memory.FSTTermsReader#terms(Ljava/lang/String;)Lorg/apache/lucene/index/Terms;
  field
    +c:.

org.apache.lucene.codecs.memory.FSTOrdTermsReader#checkFieldSummary(Lorg/apache/lucene/index/SegmentInfo;Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/codecs/memory/FSTOrdTermsReader$TermsReader;Lorg/apache/lucene/codecs/memory/FSTOrdTermsReader$TermsReader;)V
  field
    +c:invalid docCount:     maxDoc:     (blockIn=  ).invalid sumDocFreq:     docCount:     (blockIn=  ).invalid sumTotalTermFreq:     sumDocFreq:     (blockIn=  ).
  previous
    +c:duplicate fields:      (blockIn=  ).

org.apache.lucene.codecs.memory.FSTOrdTermsReader#terms(Ljava/lang/String;)Lorg/apache/lucene/index/Terms;
  field
    +c:.

org.apache.lucene.codecs.simpletext.SimpleTextSegmentInfoFormat#read(Lorg/apache/lucene/store/Directory;Ljava/lang/String;[BLorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/index/SegmentInfo;
  segmentID
    +c:file mismatch, expected:     , got:.

org.apache.lucene.codecs.simpletext.SimpleTextStoredFieldsWriter#writeField(Lorg/apache/lucene/index/FieldInfo;Lorg/apache/lucene/index/IndexableField;)V
  field
    +c:field     is stored but does not have binaryValue, stringValue nor numericValue.

org.apache.lucene.codecs.simpletext.SimpleTextStoredFieldsWriter#finish(Lorg/apache/lucene/index/FieldInfos;I)V
  numDocs
    +c:mergeFields produced an invalid result: docCount is    but only saw    file=   ; now aborting this merge to prevent index corruption.

org.apache.lucene.codecs.simpletext.SimpleTextLiveDocsFormat#readLiveDocs(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentCommitInfo;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/util/Bits;
  info
    +c:.

org.apache.lucene.codecs.simpletext.SimpleTextTermVectorsWriter#addPosition(IIILorg/apache/lucene/util/BytesRef;)V
  payload
    +c:.

org.apache.lucene.codecs.simpletext.SimpleTextTermVectorsWriter#finish(Lorg/apache/lucene/index/FieldInfos;I)V
  numDocs
    +c:mergeVectors produced an invalid result: mergedDocs is    but vec numDocs is    file=   ; now aborting this merge to prevent index corruption.

org.apache.lucene.analysis.CharArraySet#unmodifiableSet(Lorg/apache/lucene/analysis/CharArraySet;)Lorg/apache/lucene/analysis/CharArraySet;
  set
    +c:"Given set is null".

org.apache.lucene.analysis.CharArrayMap#unmodifiableMap(Lorg/apache/lucene/analysis/CharArrayMap;)Lorg/apache/lucene/analysis/CharArrayMap;
  map
    +c:"Given map is null".

org.apache.lucene.analysis.CharacterUtils#newCharacterBuffer(I)Lorg/apache/lucene/analysis/CharacterUtils$CharacterBuffer;
  bufferSize
    +d: the internal char buffer size, must be >= 2
    +c:"buffersize must be >= 2".

org.apache.lucene.analysis.CharacterUtils#toLowerCase([CII)V
  buffer
    +c:
  offset
    +c:
  limit
    +c:

org.apache.lucene.analysis.CharacterUtils#toUpperCase([CII)V
  buffer
    +c:
  offset
    +c:
  limit
    +c:

org.apache.lucene.analysis.CharacterUtils#toCodePoints([CII[II)I
  srcLen
    +c:"srcLen must be >= 0".

org.apache.lucene.analysis.CharacterUtils#toChars([III[CI)I
  srcLen
    +c:"srcLen must be >= 0".

org.apache.lucene.analysis.CharacterUtils#fill(Lorg/apache/lucene/analysis/CharacterUtils$CharacterBuffer;Ljava/io/Reader;I)Z
  buffer
    +c:.
  numChars
    +c:"numChars must be >= 2 and <= the buffer size".

org.apache.lucene.analysis.CharacterUtils#fill(Lorg/apache/lucene/analysis/CharacterUtils$CharacterBuffer;Ljava/io/Reader;)Z
  buffer
    +c:

org.apache.lucene.analysis.standard.StandardTokenizerImpl#yypushback(I)V
  number
    +d:  the number of characters to be read again. This number must not be greater than yylength()!

org.apache.lucene.analysis.standard.StandardTokenizer#setMaxTokenLength(I)V
  length
    +c:"maxTokenLength must be greater than zero".maxTokenLength may not exceed.

org.apache.lucene.analysis.tokenattributes.OffsetAttributeImpl#setOffset(II)V
  startOffset
    +c:startOffset must be non-negative, and endOffset must be >= startOffset; got  startOffset=  ,endOffset=.

org.apache.lucene.analysis.tokenattributes.PositionLengthAttributeImpl#setPositionLength(I)V
  positionLength
    +c:Position length must be 1 or greater; got.

org.apache.lucene.analysis.tokenattributes.PositionIncrementAttributeImpl#setPositionIncrement(I)V
  positionIncrement
    +c:Position increment must be zero or greater; got.

org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl#setPositionIncrement(I)V
  positionIncrement
    +c:Increment must be zero or greater:.

org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl#setPositionLength(I)V
  positionLength
    +c:Position length must be 1 or greater: got.

org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl#setOffset(II)V
  startOffset
    +c:startOffset must be non-negative, and endOffset must be >= startOffset; got  startOffset=  ,endOffset=.

org.apache.lucene.analysis.tokenattributes.PackedTokenAttributeImpl#setTermFrequency(I)V
  termFrequency
    +c:Term frequency must be 1 or greater; got.

org.apache.lucene.analysis.tokenattributes.TermFrequencyAttributeImpl#setTermFrequency(I)V
  termFrequency
    +c:Term frequency must be 1 or greater; got.

org.apache.lucene.codecs.CodecUtil#writeHeader(Lorg/apache/lucene/store/DataOutput;Ljava/lang/String;I)V
  codec
    +d: String to identify this file. It should be simple ASCII, less than 128 characters in length.
    +c:codec must be simple ASCII, less than 128 characters in length [got   ].

org.apache.lucene.codecs.CodecUtil#writeIndexHeader(Lorg/apache/lucene/store/DataOutput;Ljava/lang/String;I[BLjava/lang/String;)V
  codec
    +d: String to identify the format of this file. It should be simple ASCII, less than 128 characters in length.
    +c:
  id
    +c:Invalid id:.
  suffix
    +d: auxiliary suffix information for the file. It should be simple ASCII, less than 256 characters in length.
    +c:suffix must be simple ASCII, less than 256 characters in length [got   ].

org.apache.lucene.codecs.CodecUtil#checkHeader(Lorg/apache/lucene/store/DataInput;Ljava/lang/String;II)I
  in
    +c:codec header mismatch: actual header=    vs expected header=.
  codec
    +c:
  minVersion
    +c:
  maxVersion
    +c:

org.apache.lucene.codecs.CodecUtil#checkHeaderNoMagic(Lorg/apache/lucene/store/DataInput;Ljava/lang/String;II)I
  codec
    +c:codec mismatch: actual codec=    vs expected codec=.
  minVersion
    +c:.
  maxVersion
    +c:.

org.apache.lucene.codecs.CodecUtil#checkIndexHeader(Lorg/apache/lucene/store/DataInput;Ljava/lang/String;II[BLjava/lang/String;)I
  in
    +c:
  codec
    +c:
  minVersion
    +c:
  maxVersion
    +c:
  expectedID
    +c:
  expectedSuffix
    +c:

org.apache.lucene.codecs.CodecUtil#verifyAndCopyIndexHeader(Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/store/DataOutput;[B)V
  in
    +c:compound sub-files must have a valid codec header and footer: file is too small (    bytes).compound sub-files must have a valid codec header and footer: codec header mismatch: actual header=    vs expected header=.
  expectedID
    +c:

org.apache.lucene.codecs.CodecUtil#readIndexHeader(Lorg/apache/lucene/store/IndexInput;)[B
  in
    +c:codec header mismatch: actual header=    vs expected header=.

org.apache.lucene.codecs.CodecUtil#readFooter(Lorg/apache/lucene/store/IndexInput;)[B
  in
    +c:misplaced codec footer (file truncated?): length=    but footerLength==.

org.apache.lucene.codecs.CodecUtil#checkIndexHeaderID(Lorg/apache/lucene/store/DataInput;[B)[B
  expectedID
    +c:file mismatch, expected id=    , got=.

org.apache.lucene.codecs.CodecUtil#checkIndexHeaderSuffix(Lorg/apache/lucene/store/DataInput;Ljava/lang/String;)Ljava/lang/String;
  expectedSuffix
    +c:file mismatch, expected suffix=  , got=.

org.apache.lucene.codecs.CodecUtil#checkFooter(Lorg/apache/lucene/store/ChecksumIndexInput;)J
  in
    +c:checksum failed (hardware problem?) : expected=      actual=.

org.apache.lucene.codecs.CodecUtil#checkFooter(Lorg/apache/lucene/store/ChecksumIndexInput;Ljava/lang/Throwable;)V
  in
    +c:

org.apache.lucene.codecs.CodecUtil#retrieveChecksum(Lorg/apache/lucene/store/IndexInput;)J
  in
    +c:misplaced codec footer (file truncated?): length=    but footerLength==.

org.apache.lucene.codecs.CodecUtil#checksumEntireFile(Lorg/apache/lucene/store/IndexInput;)J
  input
    +c:misplaced codec footer (file truncated?): length=     but footerLength==.

org.apache.lucene.codecs.CodecUtil#readCRC(Lorg/apache/lucene/store/IndexInput;)J
  input
    +c:Illegal CRC-32 checksum:.

org.apache.lucene.codecs.CodecUtil#writeCRC(Lorg/apache/lucene/store/IndexOutput;)V
  output
    +c:Illegal CRC-32 checksum:     (resource=  ).

org.apache.lucene.codecs.BlockTermState#copyFrom(Lorg/apache/lucene/index/TermState;)V
  _other
    +c:.

org.apache.lucene.codecs.blocktree.Stats#endBlock(Lorg/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame;)V
  frame
    +c:.

org.apache.lucene.codecs.blocktree.BlockTreeTermsReader#<init>(Lorg/apache/lucene/codecs/PostingsReaderBase;Lorg/apache/lucene/index/SegmentReadState;)V
  state
    +c:invalid docCount:     maxDoc:.

org.apache.lucene.codecs.blocktree.BlockTreeTermsReader#readBytesRef(Lorg/apache/lucene/store/IndexInput;)Lorg/apache/lucene/util/BytesRef;
  in
    +c:invalid bytes length:.

org.apache.lucene.codecs.blocktree.BlockTreeTermsReader#terms(Ljava/lang/String;)Lorg/apache/lucene/index/Terms;
  field
    +c:.

org.apache.lucene.codecs.blocktree.BlockTreeTermsWriter#<init>(Lorg/apache/lucene/index/SegmentWriteState;Lorg/apache/lucene/codecs/PostingsWriterBase;II)V
  minItemsInBlock
    +c:

org.apache.lucene.codecs.blocktree.BlockTreeTermsWriter#validateSettings(II)V
  minItemsInBlock
    +c:minItemsInBlock must be >= 2; got.maxItemsInBlock must be >= minItemsInBlock; got maxItemsInBlock=   minItemsInBlock=.maxItemsInBlock must be at least 2*(minItemsInBlock-1); got maxItemsInBlock=   minItemsInBlock=.

org.apache.lucene.codecs.blocktree.BlockTreeTermsWriter#write(Lorg/apache/lucene/index/Fields;Lorg/apache/lucene/codecs/NormsProducer;)V
  fields
    +c:

org.apache.lucene.codecs.blocktree.BlockTreeTermsWriter#encodeOutput(JZZ)J
  fp
    +c:.

org.apache.lucene.codecs.blocktree.FieldReader#<init>(Lorg/apache/lucene/codecs/blocktree/BlockTreeTermsReader;Lorg/apache/lucene/index/FieldInfo;JLorg/apache/lucene/util/BytesRef;JJIJILorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/util/BytesRef;)V
  numTerms
    +c:.

org.apache.lucene.codecs.blocktree.FieldReader#intersect(Lorg/apache/lucene/util/automaton/CompiledAutomaton;Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/index/TermsEnum;
  compiled
    +c:"please use CompiledAutomaton.getTermsEnum instead".

org.apache.lucene.codecs.compressing.CompressingTermVectorsWriter#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentInfo;Ljava/lang/String;Lorg/apache/lucene/store/IOContext;Ljava/lang/String;Lorg/apache/lucene/codecs/compressing/CompressionMode;II)V
  directory
    +c:.
  segmentSuffix
    +c:..

org.apache.lucene.codecs.compressing.CompressingTermVectorsWriter#startTerm(Lorg/apache/lucene/util/BytesRef;I)V
  freq
    +c:.

org.apache.lucene.codecs.compressing.CompressingTermVectorsWriter#finish(Lorg/apache/lucene/index/FieldInfos;I)V
  numDocs
    +c:Wrote    docs, finish called with numDocs=.

org.apache.lucene.codecs.compressing.CompressingTermVectorsWriter#addProx(ILorg/apache/lucene/store/DataInput;Lorg/apache/lucene/store/DataInput;)V
  positions
    +c:.
  offsets
    +c:.

org.apache.lucene.codecs.compressing.CompressingTermVectorsWriter#merge(Lorg/apache/lucene/index/MergeState;)I
  mergeState
    +c:

org.apache.lucene.codecs.compressing.CompressingStoredFieldsReader#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentInfo;Ljava/lang/String;Lorg/apache/lucene/index/FieldInfos;Lorg/apache/lucene/store/IOContext;Ljava/lang/String;Lorg/apache/lucene/codecs/compressing/CompressionMode;)V
  segmentSuffix
    +c:..

org.apache.lucene.codecs.compressing.CompressingStoredFieldsReader#document(I)Lorg/apache/lucene/codecs/compressing/CompressingStoredFieldsReader$SerializedDocument;
  docID
    +c:.

org.apache.lucene.codecs.compressing.CompressingStoredFieldsReader#visitDocument(ILorg/apache/lucene/index/StoredFieldVisitor;)V
  docID
    +c:

org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentInfo;Ljava/lang/String;Lorg/apache/lucene/store/IOContext;Ljava/lang/String;Lorg/apache/lucene/codecs/compressing/CompressionMode;III)V
  directory
    +c:.
  segmentSuffix
    +c:..

org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter#writeField(Lorg/apache/lucene/index/FieldInfo;Lorg/apache/lucene/index/IndexableField;)V
  info
    +c:
  field
    +c:field     is stored but does not have binaryValue, stringValue nor numericValue.

org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter#finish(Lorg/apache/lucene/index/FieldInfos;I)V
  numDocs
    +c:Wrote    docs, finish called with numDocs=.

org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter#merge(Lorg/apache/lucene/index/MergeState;)I
  mergeState
    +c:

org.apache.lucene.codecs.compressing.CompressingTermVectorsReader#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentInfo;Ljava/lang/String;Lorg/apache/lucene/index/FieldInfos;Lorg/apache/lucene/store/IOContext;Ljava/lang/String;Lorg/apache/lucene/codecs/compressing/CompressionMode;)V
  segmentSuffix
    +c:..

org.apache.lucene.codecs.compressing.CompressingTermVectorsReader#get(I)Lorg/apache/lucene/index/Fields;
  doc
    +c:docBase=   ,chunkDocs=   ,doc=.

org.apache.lucene.codecs.compressing.CompressingStoredFieldsFormat#<init>(Ljava/lang/String;Ljava/lang/String;Lorg/apache/lucene/codecs/compressing/CompressionMode;III)V
  chunkSize
    +c:"chunkSize must be >= 1".
  maxDocsPerChunk
    +c:"maxDocsPerChunk must be >= 1".
  blockSize
    +c:"blockSize must be >= 1".

org.apache.lucene.codecs.compressing.CompressingTermVectorsFormat#<init>(Ljava/lang/String;Ljava/lang/String;Lorg/apache/lucene/codecs/compressing/CompressionMode;II)V
  chunkSize
    +c:"chunkSize must be >= 1".
  blockSize
    +c:"blockSize must be >= 1".

org.apache.lucene.codecs.compressing.CompressingStoredFieldsIndexWriter#<init>(Lorg/apache/lucene/store/IndexOutput;I)V
  blockSize
    +c:"blockSize must be positive".

org.apache.lucene.codecs.compressing.CompressingStoredFieldsIndexWriter#writeIndex(IJ)V
  startPointer
    +c:.

org.apache.lucene.codecs.compressing.CompressingStoredFieldsIndexWriter#finish(IJ)V
  numDocs
    +c:Expected    docs, but got.

org.apache.lucene.codecs.compressing.CompressingStoredFieldsIndexReader#<init>(Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/index/SegmentInfo;)V
  fieldsIndexIn
    +c:Corrupted bitsPerDocBase:.Corrupted bitsPerStartPointer:.

org.apache.lucene.codecs.compressing.CompressingStoredFieldsIndexReader#getStartPointer(I)J
  docID
    +c:docID out of range [0-  ]:.

org.apache.lucene.codecs.lucene50.Lucene50PostingsWriter#startDoc(II)V
  docID
    +c:docs out of order (   <=     )..

org.apache.lucene.codecs.lucene50.Lucene50PostingsWriter#addPosition(ILorg/apache/lucene/util/BytesRef;II)V
  position
    +c:position=   is too large (> IndexWriter.MAX_POSITION=   ).position=   is < 0.
  startOffset
    +c:.
  endOffset
    +c:

org.apache.lucene.codecs.lucene50.Lucene50PostingsWriter#finishTerm(Lorg/apache/lucene/codecs/BlockTermState;)V
  _state
    +c:

org.apache.lucene.codecs.lucene50.Lucene50PostingsReader#init(Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/index/SegmentReadState;)V
  termsIn
    +c:

org.apache.lucene.codecs.lucene50.Lucene50LiveDocsFormat#readLiveDocs(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentCommitInfo;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/util/Bits;
  info
    +c:bits.deleted=         info.delcount=.

org.apache.lucene.codecs.lucene50.Lucene50LiveDocsFormat#writeLiveDocs(Lorg/apache/lucene/util/Bits;Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentCommitInfo;ILorg/apache/lucene/store/IOContext;)V
  info
    +c:bits.deleted=     info.delcount=    newdelcount=.

org.apache.lucene.codecs.lucene60.Lucene60PointsWriter#<init>(Lorg/apache/lucene/index/SegmentWriteState;ID)V
  writeState
    +c:.

org.apache.lucene.codecs.lucene60.Lucene60PointsWriter#merge(Lorg/apache/lucene/index/MergeState;)V
  mergeState
    +c:

org.apache.lucene.codecs.lucene60.Lucene60PointsReader#getValues(Ljava/lang/String;)Lorg/apache/lucene/index/PointValues;
  fieldName
    +c:field=\  \ is unrecognized.field=\  \ did not index point values.

org.apache.lucene.codecs.lucene70.Lucene70SegmentInfoFormat#write(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentInfo;Lorg/apache/lucene/store/IOContext;)V
  si
    +c:invalid major version: should be >= 7 but got:      segment=.invalid files: expected segment=   , got=.

org.apache.lucene.document.Field#<init>(Ljava/lang/String;Lorg/apache/lucene/index/IndexableFieldType;)V
  name
    +c:"name must not be null".
  type
    +c:"type must not be null".

org.apache.lucene.document.Field#<init>(Ljava/lang/String;Ljava/io/Reader;Lorg/apache/lucene/index/IndexableFieldType;)V
  name
    +c:"name must not be null".
  reader
    +c:"reader must not be null".
  type
    +c:"type must not be null"."fields with a Reader value cannot be stored"."non-tokenized fields must use String values".

org.apache.lucene.document.Field#<init>(Ljava/lang/String;Lorg/apache/lucene/analysis/TokenStream;Lorg/apache/lucene/index/IndexableFieldType;)V
  name
    +c:"name must not be null".
  tokenStream
    +c:"tokenStream must not be null".
  type
    +c:"TokenStream fields must be indexed and tokenized"."TokenStream fields cannot be stored".

org.apache.lucene.document.Field#<init>(Ljava/lang/String;Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/index/IndexableFieldType;)V
  name
    +c:"name must not be null".
  bytes
    +c:"bytes must not be null".
  type
    +c:"type must not be null".

org.apache.lucene.document.Field#<init>(Ljava/lang/String;Ljava/lang/String;Lorg/apache/lucene/index/IndexableFieldType;)V
  name
    +c:"name must not be null".
  value
    +c:"value must not be null".
  type
    +c:"type must not be null".it doesn't make sense to have a field that  is neither indexed nor stored.

org.apache.lucene.document.Field#setStringValue(Ljava/lang/String;)V
  value
    +c:"value must not be null".

org.apache.lucene.document.Field#setBytesValue([B)V
  value
    +c:

org.apache.lucene.document.Field#setBytesValue(Lorg/apache/lucene/util/BytesRef;)V
  value
    +c:"value must not be null".

org.apache.lucene.document.LatLonPoint#setLocationValue(DD)V
  latitude
    +d: latitude value: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude value: must be within standard +/-180 coordinate bounds.

org.apache.lucene.document.LatLonPoint#<init>(Ljava/lang/String;DD)V
  latitude
    +d: latitude value: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude value: must be within standard +/-180 coordinate bounds.

org.apache.lucene.document.LatLonPoint#checkCompatible(Lorg/apache/lucene/index/FieldInfo;)V
  fieldInfo
    +c:field=\   \ was indexed with numDims=    but this point type has numDims=   , is the field really a LatLonPoint?.field=\   \ was indexed with bytesPerDim=    but this point type has bytesPerDim=   , is the field really a LatLonPoint?.

org.apache.lucene.document.LatLonPoint#newBoxQuery(Ljava/lang/String;DDDD)Lorg/apache/lucene/search/Query;
  minLatitude
    +d: latitude lower bound: must be within standard +/-90 coordinate bounds.
  maxLatitude
    +d: latitude upper bound: must be within standard +/-90 coordinate bounds.
  minLongitude
    +d: longitude lower bound: must be within standard +/-180 coordinate bounds.
  maxLongitude
    +d: longitude upper bound: must be within standard +/-180 coordinate bounds.

org.apache.lucene.document.LatLonPoint#newDistanceQuery(Ljava/lang/String;DDD)Lorg/apache/lucene/search/Query;
  latitude
    +d: latitude at the center: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude at the center: must be within standard +/-180 coordinate bounds.
  radiusMeters
    +d: maximum distance from the center in meters: must be non-negative and finite.

org.apache.lucene.document.LongPoint#setLongValues([J)V
  point
    +c:this field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.LongPoint#<init>(Ljava/lang/String;[J)V
  point
    +c:

org.apache.lucene.document.FloatPoint#setFloatValues([F)V
  point
    +c:this field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.FloatPoint#<init>(Ljava/lang/String;[F)V
  point
    +c:

org.apache.lucene.document.FeatureField#<init>(Ljava/lang/String;Ljava/lang/String;F)V
  featureValue
    +d: The value of the feature, must be a positive, finite, normal float.

org.apache.lucene.document.FeatureField#setFeatureValue(F)V
  featureValue
    +c:featureValue must be finite, got:    for feature    on field.featureValue must be a positive normal float, got:   for feature    on field    which is less than the minimum positive normal float:.

org.apache.lucene.document.FeatureField#newLogQuery(Ljava/lang/String;Ljava/lang/String;FF)Lorg/apache/lucene/search/Query;
  weight
    +d:        weight to give to this feature, must be in (0,64]
    +c:weight must be in (0,   ], got:.
  scalingFactor
    +d: scaling factor applied before taking the logarithm, must be in [1, +Infinity)
    +c:scalingFactor must be >= 1, got:.

org.apache.lucene.document.FeatureField#newSaturationQuery(Ljava/lang/String;Ljava/lang/String;FF)Lorg/apache/lucene/search/Query;
  weight
    +d:      weight to give to this feature, must be in (0,64]
  pivot
    +d:       feature value that would give a score contribution equal to weight/2, must be in (0, +Infinity)

org.apache.lucene.document.FeatureField#newSaturationQuery(Ljava/lang/String;Ljava/lang/String;FLjava/lang/Float;)Lorg/apache/lucene/search/Query;
  weight
    +c:weight must be in (0,   ], got:.
  pivot
    +c:pivot must be > 0, got:.

org.apache.lucene.document.FeatureField#newSigmoidQuery(Ljava/lang/String;Ljava/lang/String;FFF)Lorg/apache/lucene/search/Query;
  weight
    +d:      weight to give to this feature, must be in (0,64]
    +c:weight must be in (0,   ], got:.
  pivot
    +d:       feature value that would give a score contribution equal to weight/2, must be in (0, +Infinity)
    +c:pivot must be > 0, got:.
  exp
    +d:         exponent, higher values make the function grow slower before 'pivot' and faster after 'pivot', must be in (0, +Infinity)
    +c:exp must be > 0, got:.

org.apache.lucene.document.DoublePoint#setDoubleValues([D)V
  point
    +c:this field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.DoublePoint#<init>(Ljava/lang/String;[D)V
  point
    +c:

org.apache.lucene.document.IntRange#getType(I)Lorg/apache/lucene/document/FieldType;
  dimensions
    +c:"IntRange does not support greater than 4 dimensions".

org.apache.lucene.document.IntRange#setRangeValues([I[I)V
  min
    +c:field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.IntRange#checkArgs([I[I)V
  min
    +c:"min/max range values cannot be null or empty"."min/max ranges must agree"."IntRange does not support greater than 4 dimensions".

org.apache.lucene.document.IntRange#verifyAndEncode([I[I[B)V
  min
    +c:invalid min value (   )  in IntRange.min value (    ) is greater than max value (    ).
  max
    +c:invalid max value (   )  in IntRange.

org.apache.lucene.document.DateTools#stringToDate(Ljava/lang/String;)Ljava/util/Date;
  dateString
    +c:Input is not a valid date string:.

org.apache.lucene.document.DateTools#round(JLorg/apache/lucene/document/DateTools$Resolution;)J
  resolution
    +c:unknown resolution.

org.apache.lucene.document.LongRange#getType(I)Lorg/apache/lucene/document/FieldType;
  dimensions
    +c:"LongRange does not support greater than 4 dimensions".

org.apache.lucene.document.LongRange#setRangeValues([J[J)V
  min
    +c:field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.LongRange#checkArgs([J[J)V
  min
    +c:"min/max range values cannot be null or empty"."min/max ranges must agree"."LongRange does not support greater than 4 dimensions".

org.apache.lucene.document.LongRange#verifyAndEncode([J[J[B)V
  min
    +c:invalid min value (   )  in LongRange.min value (    ) is greater than max value (    ).
  max
    +c:invalid max value (   )  in LongRange.

org.apache.lucene.document.FieldType#setIndexOptions(Lorg/apache/lucene/index/IndexOptions;)V
  value
    +c:"IndexOptions must not be null".

org.apache.lucene.document.FieldType#setDimensions(III)V
  dataDimensionCount
    +c:dataDimensionCount must be >= 0; got.dataDimensionCount must be <=    ; got.when dimensionNumBytes is 0, dataDimensionCount must be 0; got.
  indexDimensionCount
    +c:indexDimensionCount must be >= 0; got.indexDimensionCount must be <= dataDimensionCount:   ; got.when dataDimensionCount is 0, indexDimensionCount must be 0; got.when dataDimensionCount is > 0, indexDimensionCount must be > 0; got.
  dimensionNumBytes
    +c:dimensionNumBytes must be >= 0; got.dimensionNumBytes must be <=    ; got.when dataDimensionCount is 0, dimensionNumBytes must be 0; got.

org.apache.lucene.document.FieldType#setDocValuesType(Lorg/apache/lucene/index/DocValuesType;)V
  type
    +c:"DocValuesType must not be null".

org.apache.lucene.document.LatLonDocValuesField#<init>(Ljava/lang/String;DD)V
  latitude
    +d: latitude value: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude value: must be within standard +/-180 coordinate bounds.

org.apache.lucene.document.LatLonDocValuesField#setLocationValue(DD)V
  latitude
    +d: latitude value: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude value: must be within standard +/-180 coordinate bounds.

org.apache.lucene.document.LatLonDocValuesField#checkCompatible(Lorg/apache/lucene/index/FieldInfo;)V
  fieldInfo
    +c:field=\   \ was indexed with docValuesType=    but this type has docValuesType=   , is the field really a LatLonDocValuesField?.

org.apache.lucene.document.LatLonDocValuesField#newDistanceSort(Ljava/lang/String;DD)Lorg/apache/lucene/search/SortField;
  latitude
    +d: latitude at the center: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude at the center: must be within standard +/-180 coordinate bounds.

org.apache.lucene.document.LatLonDocValuesField#newSlowDistanceQuery(Ljava/lang/String;DDD)Lorg/apache/lucene/search/Query;
  latitude
    +d: latitude at the center: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude at the center: must be within standard +/-180 coordinate bounds.
  radiusMeters
    +d: maximum distance from the center in meters: must be non-negative and finite.

org.apache.lucene.document.IntPoint#setIntValues([I)V
  point
    +c:this field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.IntPoint#<init>(Ljava/lang/String;[I)V
  point
    +c:

org.apache.lucene.document.NumericDocValuesField#<init>(Ljava/lang/String;Ljava/lang/Long;)V
  value
    +d: 64-bit long value or null if the existing fields value should be removed on update

org.apache.lucene.document.BinaryPoint#<init>(Ljava/lang/String;[[B)V
  point
    +c:

org.apache.lucene.document.BinaryPoint#<init>(Ljava/lang/String;[BLorg/apache/lucene/index/IndexableFieldType;)V
  packedPoint
    +c:packedPoint is length=    but type.pointDimensionCount()=    and type.pointNumBytes()=.

org.apache.lucene.document.BinaryPoint#newSetQuery(Ljava/lang/String;[[B)Lorg/apache/lucene/search/Query;
  values
    +c:

org.apache.lucene.document.DoubleRange#getType(I)Lorg/apache/lucene/document/FieldType;
  dimensions
    +c:"DoubleRange does not support greater than 4 dimensions".

org.apache.lucene.document.DoubleRange#setRangeValues([D[D)V
  min
    +c:field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.DoubleRange#checkArgs([D[D)V
  min
    +c:"min/max range values cannot be null or empty"."min/max ranges must agree"."DoubleRange does not support greater than 4 dimensions".

org.apache.lucene.document.DoubleRange#verifyAndEncode([D[D[B)V
  min
    +c:invalid min value (   )  in DoubleRange.min value (    ) is greater than max value (    ).
  max
    +c:invalid max value (   )  in DoubleRange.

org.apache.lucene.document.FloatRange#getType(I)Lorg/apache/lucene/document/FieldType;
  dimensions
    +c:"FloatRange does not support greater than 4 dimensions".

org.apache.lucene.document.FloatRange#setRangeValues([F[F)V
  min
    +c:field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.FloatRange#checkArgs([F[F)V
  min
    +c:"min/max range values cannot be null or empty"."min/max ranges must agree"."FloatRange does not support greater than 4 dimensions".

org.apache.lucene.document.FloatRange#verifyAndEncode([F[F[B)V
  min
    +c:invalid min value (   )  in FloatRange.min value (    ) is greater than max value (    ).
  max
    +c:invalid max value (   )  in FloatRange.

org.apache.lucene.geo.Polygon#<init>([D[D[Lorg/apache/lucene/geo/Polygon;)V
  polyLats
    +c:"polyLats must not be null"."polyLats and polyLons must be equal length"."polyLats and polyLons must be equal length"."at least 4 polygon points required".first and last points of the polygon must be the same (it must close itself): polyLats[0]=   polyLats[   ]=.
  polyLons
    +c:"polyLons must not be null".first and last points of the polygon must be the same (it must close itself): polyLons[0]=   polyLons[   ]=.
  holes
    +c:"holes must not be null"."holes may not contain holes: polygons may not nest.".

org.apache.lucene.geo.GeoUtils#checkLatitude(D)V
  latitude
    +c:invalid latitude   ; must be between    and.

org.apache.lucene.geo.GeoUtils#checkLongitude(D)V
  longitude
    +c:invalid longitude   ; must be between    and.

org.apache.lucene.geo.GeoUtils#distanceQuerySortKey(D)D
  radius
    +c:.

org.apache.lucene.geo.GeoUtils#relate(DDDDDDDD)Lorg/apache/lucene/index/PointValues$Relation;
  maxLon
    +c:"Box crosses the dateline".

org.apache.lucene.geo.GeoEncodingUtils#encodeLatitude(D)I
  latitude
    +d: latitude value: must be within standard +/-90 coordinate bounds.

org.apache.lucene.geo.GeoEncodingUtils#encodeLatitudeCeil(D)I
  latitude
    +d: latitude value: must be within standard +/-90 coordinate bounds.

org.apache.lucene.geo.GeoEncodingUtils#encodeLongitude(D)I
  longitude
    +d: longitude value: must be within standard +/-180 coordinate bounds.

org.apache.lucene.geo.GeoEncodingUtils#encodeLongitudeCeil(D)I
  longitude
    +d: longitude value: must be within standard +/-180 coordinate bounds.

org.apache.lucene.geo.GeoEncodingUtils#decodeLatitude(I)D
  encoded
    +c:

org.apache.lucene.geo.GeoEncodingUtils#decodeLongitude(I)D
  encoded
    +c:

org.apache.lucene.index.SegmentWriteState#<init>(Lorg/apache/lucene/util/InfoStream;Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentInfo;Lorg/apache/lucene/index/FieldInfos;Lorg/apache/lucene/index/BufferedUpdates;Lorg/apache/lucene/store/IOContext;Ljava/lang/String;)V
  segmentSuffix
    +c:.

org.apache.lucene.index.SegmentWriteState#assertSegmentSuffix(Ljava/lang/String;)Z
  segmentSuffix
    +c:.

org.apache.lucene.index.ParallelLeafReader#<init>(Z[Lorg/apache/lucene/index/LeafReader;[Lorg/apache/lucene/index/LeafReader;)V
  storedFieldsReaders
    +c:"There must be at least one main reader if storedFieldsReaders are used.".

org.apache.lucene.index.LeafMetaData#<init>(ILorg/apache/lucene/util/Version;Lorg/apache/lucene/search/Sort;)V
  createdVersionMajor
    +c:createdVersionMajor is in the future:.createdVersionMajor must be >= 6, got:."minVersion must be set when createdVersionMajor is >= 7".
  minVersion
    +c:minVersion must be >= 7.0.0:.

org.apache.lucene.index.SegmentInfos#<init>(I)V
  indexCreatedVersionMajor
    +c:indexCreatedVersionMajor is in the future:.indexCreatedVersionMajor must be >= 6, got:.

org.apache.lucene.index.SegmentInfos#generationFromSegmentsFileName(Ljava/lang/String;)J
  fileName
    +c:fileName \  \ is not a segments file.

org.apache.lucene.index.SegmentInfos#readCommit(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/store/ChecksumIndexInput;J)Lorg/apache/lucene/index/SegmentInfos;
  input
    +c:.Creation version [   .x] can't be greater than the version that wrote the segment infos: [   ].This index was initially created with Lucene    .x while the current version is     and Lucene only supports reading the current and previous major versions.invalid segment count:.invalid deletion count:     vs maxDoc=.invalid deletion count:     vs maxDoc=.invalid deletion count:       vs maxDoc=.segments file recorded minSegmentLuceneVersion=     but segment=    has older version=.segments file recorded indexCreatedVersionMajor=     but segment=    has older version=.segments infos must record minVersion with indexCreatedVersionMajor=.Too many documents: an index cannot exceed     but readers have total maxDoc=.

org.apache.lucene.index.SegmentInfos#setNextWriteGeneration(J)V
  generation
    +c:cannot decrease generation to    from current generation.

org.apache.lucene.index.SegmentInfos#setVersion(J)V
  newVersion
    +c:newVersion (=  ) cannot be less than current version (=   ).

org.apache.lucene.index.SegmentInfos#applyMergeChanges(Lorg/apache/lucene/index/MergePolicy$OneMerge;Z)V
  merge
    +c:"All segments must record the minVersion for indices created on or after Lucene 7".
  dropSegment
    +c:

org.apache.lucene.index.SegmentInfos#add(Lorg/apache/lucene/index/SegmentCommitInfo;)V
  si
    +c:"All segments must record the minVersion for indices created on or after Lucene 7".

org.apache.lucene.index.TieredMergePolicy#setMaxMergeAtOnce(I)Lorg/apache/lucene/index/TieredMergePolicy;
  v
    +c:maxMergeAtOnce must be > 1 (got   ).

org.apache.lucene.index.TieredMergePolicy#setMaxMergeAtOnceExplicit(I)Lorg/apache/lucene/index/TieredMergePolicy;
  v
    +c:maxMergeAtOnceExplicit must be > 1 (got   ).

org.apache.lucene.index.TieredMergePolicy#setMaxMergedSegmentMB(D)Lorg/apache/lucene/index/TieredMergePolicy;
  v
    +c:maxMergedSegmentMB must be >=0 (got    ).

org.apache.lucene.index.TieredMergePolicy#setDeletesPctAllowed(D)Lorg/apache/lucene/index/TieredMergePolicy;
  v
    +c:indexPctDeletedTarget must be >= 20.0 and <= 50 (got   ).

org.apache.lucene.index.TieredMergePolicy#setFloorSegmentMB(D)Lorg/apache/lucene/index/TieredMergePolicy;
  v
    +c:floorSegmentMB must be > 0.0 (got    ).

org.apache.lucene.index.TieredMergePolicy#setForceMergeDeletesPctAllowed(D)Lorg/apache/lucene/index/TieredMergePolicy;
  v
    +c:forceMergeDeletesPctAllowed must be between 0.0 and 100.0 inclusive (got   ).

org.apache.lucene.index.TieredMergePolicy#setSegmentsPerTier(D)Lorg/apache/lucene/index/TieredMergePolicy;
  v
    +c:segmentsPerTier must be >= 2.0 (got   ).

org.apache.lucene.index.LegacySortedDocValuesWrapper#advance(I)I
  target
    +c:cannot advance backwards: docID=   target=.

org.apache.lucene.index.ConcurrentMergeScheduler#setMaxMergesAndThreads(II)V
  maxMergeCount
    +c:"both maxMergeCount and maxThreadCount must be AUTO_DETECT_MERGES_AND_THREADS"."maxMergeCount should be at least 1".
  maxThreadCount
    +d: the max # simultaneous merge threads that should be running at once.  This must be <= maxMergeCount
    +c:"both maxMergeCount and maxThreadCount must be AUTO_DETECT_MERGES_AND_THREADS"."maxThreadCount should be at least 1".maxThreadCount should be <= maxMergeCount (=   ).

org.apache.lucene.index.ConcurrentMergeScheduler#merge(Lorg/apache/lucene/index/IndexWriter;Lorg/apache/lucene/index/MergeTrigger;Z)V
  writer
    +c:.

org.apache.lucene.index.ConcurrentMergeScheduler#handleMergeException(Lorg/apache/lucene/store/Directory;Ljava/lang/Throwable;)V
  exc
    +c:.

org.apache.lucene.index.OrdinalMap#build(Lorg/apache/lucene/index/IndexReader$CacheKey;[Lorg/apache/lucene/index/TermsEnum;[JF)Lorg/apache/lucene/index/OrdinalMap;
  subs
    +d: TermsEnums that support TermsEnum#ord() . They need not be dense (e.g. can be FilteredTermsEnums}.
    +c:"subs and weights must have the same length".

org.apache.lucene.index.SoftDeletesRetentionMergePolicy#numDeletesToMerge(Lorg/apache/lucene/index/SegmentCommitInfo;ILorg/apache/lucene/util/IOSupplier;)I
  info
    +c:.

org.apache.lucene.index.CheckIndex#checkIndex(Ljava/util/List;)Lorg/apache/lucene/index/CheckIndex$Status;
  onlySegments
    +d: list of specific segment names to check <p>As this method checks every byte in the specified segments, on a large index it can take quite a long time to run. 

org.apache.lucene.index.CheckIndex#testSort(Lorg/apache/lucene/index/CodecReader;Lorg/apache/lucene/search/Sort;Ljava/io/PrintStream;Z)Lorg/apache/lucene/index/CheckIndex$Status$IndexSortStatus;
  sort
    +c:segment has indexSort=   but docID=    sorts after docID=.

org.apache.lucene.index.CheckIndex#testLiveDocs(Lorg/apache/lucene/index/CodecReader;Ljava/io/PrintStream;Z)Lorg/apache/lucene/index/CheckIndex$Status$LiveDocStatus;
  reader
    +c:

org.apache.lucene.index.CheckIndex#checkImpacts(Lorg/apache/lucene/index/Impacts;I)V
  impacts
    +c:
  lastTarget
    +c:getDocIdUpTo returned     on level 0, which is less than the target.Decreasing return for getDocIdUpTo: level      returned     but level      returned     for target.

org.apache.lucene.index.CheckIndex#testPoints(Lorg/apache/lucene/index/CodecReader;Ljava/io/PrintStream;Z)Lorg/apache/lucene/index/CheckIndex$Status$PointsStatus;
  reader
    +c:

org.apache.lucene.index.CheckIndex#testStoredFields(Lorg/apache/lucene/index/CodecReader;Ljava/io/PrintStream;Z)Lorg/apache/lucene/index/CheckIndex$Status$StoredFieldStatus;
  reader
    +c:docCount=     but saw      undeleted docs.

org.apache.lucene.index.CheckIndex#exorciseIndex(Lorg/apache/lucene/index/CheckIndex$Status;)V
  result
    +c:"can only exorcise an index that was fully checked (this status checked a subset of segments)".

org.apache.lucene.index.CheckIndex#main([Ljava/lang/String;)V
  args
    +c:

org.apache.lucene.index.CheckIndex#parseOptions([Ljava/lang/String;)Lorg/apache/lucene/index/CheckIndex$Options;
  args
    +c:"ERROR: missing name for -segment option"."ERROR: missing value for -dir-impl option".ERROR: unexpected extra argument '    '.

org.apache.lucene.index.MultiTermsEnum#reset([Lorg/apache/lucene/index/MultiTermsEnum$TermsEnumIndex;)Lorg/apache/lucene/index/TermsEnum;
  termsEnumsIndex
    +c:.

org.apache.lucene.index.MultiTermsEnum#seekExact(Lorg/apache/lucene/util/BytesRef;)Z
  term
    +c:.

org.apache.lucene.index.MultiTermsEnum#seekCeil(Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/index/TermsEnum$SeekStatus;
  term
    +c:

org.apache.lucene.index.MultiTermsEnum#postings(Lorg/apache/lucene/index/PostingsEnum;I)Lorg/apache/lucene/index/PostingsEnum;
  reuse
    +c:
  flags
    +c:

org.apache.lucene.index.MultiTermsEnum#impacts(I)Lorg/apache/lucene/index/ImpactsEnum;
  flags
    +c:

org.apache.lucene.index.LegacySortedSetDocValuesWrapper#advance(I)I
  target
    +c:cannot advance backwards: docID=   target=.

org.apache.lucene.index.MultiTerms#<init>([Lorg/apache/lucene/index/Terms;[Lorg/apache/lucene/index/ReaderSlice;)V
  subs
    +c:.

org.apache.lucene.index.MultiTerms#getTermPostingsEnum(Lorg/apache/lucene/index/IndexReader;Ljava/lang/String;Lorg/apache/lucene/util/BytesRef;I)Lorg/apache/lucene/index/PostingsEnum;
  field
    +c:.
  term
    +c:.

org.apache.lucene.index.IndexWriterConfig#setIndexWriter(Lorg/apache/lucene/index/IndexWriter;)Lorg/apache/lucene/index/IndexWriterConfig;
  writer
    +c:"do not share IndexWriterConfig instances across IndexWriters".

org.apache.lucene.index.IndexWriterConfig#setOpenMode(Lorg/apache/lucene/index/IndexWriterConfig$OpenMode;)Lorg/apache/lucene/index/IndexWriterConfig;
  openMode
    +c:"openMode must not be null".

org.apache.lucene.index.IndexWriterConfig#setIndexDeletionPolicy(Lorg/apache/lucene/index/IndexDeletionPolicy;)Lorg/apache/lucene/index/IndexWriterConfig;
  delPolicy
    +c:"indexDeletionPolicy must not be null".

org.apache.lucene.index.IndexWriterConfig#setSimilarity(Lorg/apache/lucene/search/similarities/Similarity;)Lorg/apache/lucene/index/IndexWriterConfig;
  similarity
    +c:"similarity must not be null".

org.apache.lucene.index.IndexWriterConfig#setMergeScheduler(Lorg/apache/lucene/index/MergeScheduler;)Lorg/apache/lucene/index/IndexWriterConfig;
  mergeScheduler
    +c:"mergeScheduler must not be null".

org.apache.lucene.index.IndexWriterConfig#setCodec(Lorg/apache/lucene/codecs/Codec;)Lorg/apache/lucene/index/IndexWriterConfig;
  codec
    +c:"codec must not be null".

org.apache.lucene.index.IndexWriterConfig#setIndexerThreadPool(Lorg/apache/lucene/index/DocumentsWriterPerThreadPool;)Lorg/apache/lucene/index/IndexWriterConfig;
  threadPool
    +c:"threadPool must not be null".

org.apache.lucene.index.IndexWriterConfig#setFlushPolicy(Lorg/apache/lucene/index/FlushPolicy;)Lorg/apache/lucene/index/IndexWriterConfig;
  flushPolicy
    +c:"flushPolicy must not be null".

org.apache.lucene.index.IndexWriterConfig#setRAMPerThreadHardLimitMB(I)Lorg/apache/lucene/index/IndexWriterConfig;
  perThreadHardLimitMB
    +c:"PerThreadHardLimit must be greater than 0 and less than 2048MB".

org.apache.lucene.index.IndexWriterConfig#setInfoStream(Lorg/apache/lucene/util/InfoStream;)Lorg/apache/lucene/index/IndexWriterConfig;
  infoStream
    +c:Cannot set InfoStream implementation to null.  To disable logging use InfoStream.NO_OUTPUT.

org.apache.lucene.index.IndexWriterConfig#setInfoStream(Ljava/io/PrintStream;)Lorg/apache/lucene/index/IndexWriterConfig;
  printStream
    +c:"printStream must not be null".

org.apache.lucene.index.FieldInfo#update(ZZZLorg/apache/lucene/index/IndexOptions;III)V
  omitNorms
    +c:
  indexOptions
    +c:IndexOptions must not be null (field: \  \).cannot change field \  \ from index options=   to inconsistent index options=.
  dataDimensionCount
    +c:cannot change field \  \ from points dataDimensionCount=  , indexDimensionCount=  , numBytes=   to inconsistent dataDimensionCount=  , indexDimensionCount=  , numBytes=.
  indexDimensionCount
    +c:
  dimensionNumBytes
    +c:

org.apache.lucene.index.FieldInfo#setPointDimensions(III)V
  dataDimensionCount
    +c:point data dimension count must be >= 0; got    for field=\  \.point data dimension count must be < PointValues.MAX_DIMENSIONS (=    ); got    for field=\  \.point index dimension count must be <= point data dimension count (=   ); got    for field=\  \.cannot change point data dimension count from     to    for field=\  \.
  indexDimensionCount
    +c:cannot change point index dimension count from     to    for field=\  \.
  numBytes
    +c:point numBytes must be >= 0; got    for field=\  \.point numBytes must be <= PointValues.MAX_NUM_BYTES (=    ); got    for field=\  \.cannot change point numBytes from     to    for field=\  \.

org.apache.lucene.index.FieldInfo#setDocValuesType(Lorg/apache/lucene/index/DocValuesType;)V
  type
    +c:DocValuesType must not be null (field: \  \).cannot change DocValues type from     to    for field \  \.

org.apache.lucene.index.FieldInfo#setIndexOptions(Lorg/apache/lucene/index/IndexOptions;)V
  newIndexOptions
    +c:cannot change field \  \ from index options=    to inconsistent index options=.

org.apache.lucene.index.OrdTermState#copyFrom(Lorg/apache/lucene/index/TermState;)V
  other
    +c:.

org.apache.lucene.index.ReaderManager#<init>(Lorg/apache/lucene/index/IndexWriter;ZZ)V
  applyAllDeletes
    +d: If true, all buffered deletes will be applied (made visible) in the IndexSearcher / DirectoryReader . If false, the deletes may or may not be applied, but remain buffered (in IndexWriter) so that they will be applied in the future. Applying deletes can be costly, so if your app can tolerate deleted documents being returned you might gain some performance by passing false. See DirectoryReader#openIfChanged(DirectoryReader,IndexWriter,boolean) .

org.apache.lucene.index.MergeRateLimiter#setMBPerSec(D)V
  mbPerSec
    +c:mbPerSec must be positive; got:.

org.apache.lucene.index.MergeRateLimiter#pause(J)J
  bytes
    +c:

org.apache.lucene.index.StandardDirectoryReader#open(Lorg/apache/lucene/index/IndexWriter;Lorg/apache/lucene/index/SegmentInfos;ZZ)Lorg/apache/lucene/index/DirectoryReader;
  writer
    +c:
  infos
    +c:

org.apache.lucene.index.StandardDirectoryReader#doOpenIfChanged(Lorg/apache/lucene/index/IndexCommit;)Lorg/apache/lucene/index/DirectoryReader;
  commit
    +c:

org.apache.lucene.index.PersistentSnapshotDeletionPolicy#<init>(Lorg/apache/lucene/index/IndexDeletionPolicy;Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/IndexWriterConfig$OpenMode;)V
  mode
    +c:"no snapshots stored in this directory".

org.apache.lucene.index.LiveIndexWriterConfig#setRAMBufferSizeMB(D)Lorg/apache/lucene/index/LiveIndexWriterConfig;
  ramBufferSizeMB
    +c:"ramBufferSize should be > 0.0 MB when enabled"."at least one of ramBufferSize and maxBufferedDocs must be enabled".

org.apache.lucene.index.LiveIndexWriterConfig#setMaxBufferedDocs(I)Lorg/apache/lucene/index/LiveIndexWriterConfig;
  maxBufferedDocs
    +c:"maxBufferedDocs must at least be 2 when enabled"."at least one of ramBufferSize and maxBufferedDocs must be enabled".

org.apache.lucene.index.LiveIndexWriterConfig#setMergePolicy(Lorg/apache/lucene/index/MergePolicy;)Lorg/apache/lucene/index/LiveIndexWriterConfig;
  mergePolicy
    +c:"mergePolicy must not be null".

org.apache.lucene.index.AutomatonTermsEnum#<init>(Lorg/apache/lucene/index/TermsEnum;Lorg/apache/lucene/util/automaton/CompiledAutomaton;)V
  compiled
    +c:"please use CompiledAutomaton.getTermsEnum instead".

org.apache.lucene.index.AutomatonTermsEnum#nextSeekTerm(Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/util/BytesRef;
  term
    +c:

org.apache.lucene.index.SegmentInfo#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/util/Version;Lorg/apache/lucene/util/Version;Ljava/lang/String;IZLorg/apache/lucene/codecs/Codec;Ljava/util/Map;[BLjava/util/Map;Lorg/apache/lucene/search/Sort;)V
  dir
    +c:.
  id
    +c:invalid id:.

org.apache.lucene.index.SegmentInfo#setCodec(Lorg/apache/lucene/codecs/Codec;)V
  codec
    +c:."codec must be non-null".

org.apache.lucene.index.SegmentInfo#setMaxDoc(I)V
  maxDoc
    +c:maxDoc was already set: this.maxDoc=   vs maxDoc=.

org.apache.lucene.index.MultiPostingsEnum#advance(I)I
  target
    +c:.

org.apache.lucene.index.ParallelCompositeReader#prepareLeafReaders([Lorg/apache/lucene/index/CompositeReader;[Lorg/apache/lucene/index/CompositeReader;)[Lorg/apache/lucene/index/LeafReader;
  storedFieldsReaders
    +c:"There must be at least one main reader if storedFieldsReaders are used.".

org.apache.lucene.index.ParallelCompositeReader#validate([Lorg/apache/lucene/index/CompositeReader;I[I)V
  maxDoc
    +c:All readers must have same maxDoc:   !=."All leaf readers must have same corresponding subReader maxDoc".
  leafMaxDoc
    +c:"All readers must have same number of leaf readers".

org.apache.lucene.index.SoftDeletesDirectoryReaderWrapper#wrap(Lorg/apache/lucene/index/LeafReader;Ljava/lang/String;)Lorg/apache/lucene/index/LeafReader;
  reader
    +c:.

org.apache.lucene.index.DocValues#checkField(Lorg/apache/lucene/index/LeafReader;Ljava/lang/String;[Lorg/apache/lucene/index/DocValuesType;)V
  field
    +c:unexpected docvalues type     for field '  '    (expected=  (expected one of     ).  Re-index with correct docvalues type.

org.apache.lucene.index.SegmentCommitInfo#setDelCount(I)V
  delCount
    +c:invalid delCount=   (maxDoc=   )..

org.apache.lucene.index.SegmentCommitInfo#setSoftDelCount(I)V
  softDelCount
    +c:invalid softDelCount=   (maxDoc=   )..

org.apache.lucene.index.FieldInfos#fieldInfo(I)Lorg/apache/lucene/index/FieldInfo;
  fieldNumber
    +c:Illegal field number:.

org.apache.lucene.index.LegacyBinaryDocValuesWrapper#advance(I)I
  target
    +c:cannot advance backwards: docID=   target=.

org.apache.lucene.index.MultiBits#get(I)Z
  doc
    +c:.

org.apache.lucene.index.IndexFileNames#fileNameFromGeneration(Ljava/lang/String;Ljava/lang/String;J)Ljava/lang/String;
  gen
    +c:.

org.apache.lucene.index.IndexFileNames#segmentFileName(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
  ext
    +c:.

org.apache.lucene.index.IndexFileNames#parseGeneration(Ljava/lang/String;)J
  filename
    +c:.

org.apache.lucene.index.TermStates#<init>(Lorg/apache/lucene/index/IndexReaderContext;Lorg/apache/lucene/index/TermState;IIJ)V
  state
    +c:
  ord
    +c:
  docFreq
    +c:
  totalTermFreq
    +c:

org.apache.lucene.index.TermStates#build(Lorg/apache/lucene/index/IndexReaderContext;Lorg/apache/lucene/index/Term;Z)Lorg/apache/lucene/index/TermStates;
  context
    +c:.

org.apache.lucene.index.TermStates#register(Lorg/apache/lucene/index/TermState;IIJ)V
  state
    +c:
  ord
    +c:
  docFreq
    +c:
  totalTermFreq
    +c:

org.apache.lucene.index.TermStates#register(Lorg/apache/lucene/index/TermState;I)V
  state
    +c:.
  ord
    +c:..

org.apache.lucene.index.TermStates#accumulateStatistics(IJ)V
  docFreq
    +c:.
  totalTermFreq
    +c:.

org.apache.lucene.index.TermStates#get(Lorg/apache/lucene/index/LeafReaderContext;)Lorg/apache/lucene/index/TermState;
  ctx
    +c:.

org.apache.lucene.index.LegacyNumericDocValuesWrapper#advance(I)I
  target
    +c:.

org.apache.lucene.index.SnapshotDeletionPolicy#releaseGen(J)V
  gen
    +c:commit gen=   is not currently snapshotted.

org.apache.lucene.index.MergePolicy$OneMergeProgress#pauseNanos(JLorg/apache/lucene/index/MergePolicy$OneMergeProgress$PauseReason;Ljava/util/function/BooleanSupplier;)V
  condition
    +d: The pause condition that should return false if immediate return from this method is needed. Other threads can wake up any sleeping thread by calling #wakeup , but it'd fall to sleep for the remainder of the requested time if this condition 

org.apache.lucene.index.MergePolicy$OneMergeProgress#setMergeThread(Ljava/lang/Thread;)V
  owner
    +c:.

org.apache.lucene.index.SegmentReader#<init>(Lorg/apache/lucene/index/SegmentCommitInfo;ILorg/apache/lucene/store/IOContext;)V
  si
    +c:.

org.apache.lucene.index.SegmentReader#<init>(Lorg/apache/lucene/index/SegmentCommitInfo;Lorg/apache/lucene/index/SegmentReader;Lorg/apache/lucene/util/Bits;Lorg/apache/lucene/util/Bits;IZ)V
  liveDocs
    +c:maxDoc=     but liveDocs.size()=.
  hardLiveDocs
    +c:
  numDocs
    +c:numDocs=   but maxDoc=.
  isNRT
    +c:

org.apache.lucene.index.IndexWriter#setMaxDocs(I)V
  maxDocs
    +c:maxDocs must be <= IndexWriter.MAX_DOCS=  ; got:.

org.apache.lucene.index.IndexWriter#getReader(ZZ)Lorg/apache/lucene/index/DirectoryReader;
  applyAllDeletes
    +c:
  writeAllDeletes
    +c:"applyAllDeletes must be true when writeAllDeletes=true".

org.apache.lucene.index.IndexWriter#numDeletedDocs(Lorg/apache/lucene/index/SegmentCommitInfo;)I
  info
    +c:.

org.apache.lucene.index.IndexWriter#ensureOpen(Z)V
  failIfClosing
    +c:"this IndexWriter is closed".

org.apache.lucene.index.IndexWriter#softUpdateDocuments(Lorg/apache/lucene/index/Term;Ljava/lang/Iterable;[Lorg/apache/lucene/document/Field;)J
  term
    +c:"term must not be null".
  softDeletes
    +c:"at least one soft delete must be present".

org.apache.lucene.index.IndexWriter#tryDeleteDocument(Lorg/apache/lucene/index/IndexReader;I)J
  readerIn
    +c:
  docID
    +c:

org.apache.lucene.index.IndexWriter#tryUpdateDocValue(Lorg/apache/lucene/index/IndexReader;I[Lorg/apache/lucene/document/Field;)J
  readerIn
    +c:
  docID
    +c:

org.apache.lucene.index.IndexWriter#softUpdateDocument(Lorg/apache/lucene/index/Term;Ljava/lang/Iterable;[Lorg/apache/lucene/document/Field;)J
  term
    +c:"term must not be null".
  softDeletes
    +c:"at least one soft delete must be present".

org.apache.lucene.index.IndexWriter#updateNumericDocValue(Lorg/apache/lucene/index/Term;Ljava/lang/String;J)J
  field
    +c:"can only update existing numeric-docvalues fields!".cannot update docvalues field involved in the index sort, field=  , sort=.

org.apache.lucene.index.IndexWriter#updateBinaryDocValue(Lorg/apache/lucene/index/Term;Ljava/lang/String;Lorg/apache/lucene/util/BytesRef;)J
  field
    +c:"can only update existing binary-docvalues fields!".
  value
    +c:cannot update a field to a null value:.

org.apache.lucene.index.IndexWriter#forceMerge(I)V
  maxNumSegments
    +c:

org.apache.lucene.index.IndexWriter#forceMerge(IZ)V
  maxNumSegments
    +c:maxNumSegments must be >= 1; got.background merge hit exception:.

org.apache.lucene.index.IndexWriter#maybeMerge(Lorg/apache/lucene/index/MergePolicy;Lorg/apache/lucene/index/MergeTrigger;I)V
  trigger
    +c:
  maxNumSegments
    +c:

org.apache.lucene.index.IndexWriter#publishFrozenUpdates(Lorg/apache/lucene/index/FrozenBufferedUpdates;)J
  packet
    +c:.

org.apache.lucene.index.IndexWriter#addIndexes([Lorg/apache/lucene/store/Directory;)J
  dirs
    +c:

org.apache.lucene.index.IndexWriter#merge(Lorg/apache/lucene/index/MergePolicy$OneMerge;)V
  merge
    +c:

org.apache.lucene.index.IndexWriter#registerMerge(Lorg/apache/lucene/index/MergePolicy$OneMerge;)Z
  merge
    +c:.merge is aborted:...

org.apache.lucene.index.IndexWriter#mergeInit(Lorg/apache/lucene/index/MergePolicy$OneMerge;)V
  merge
    +c:

org.apache.lucene.index.IndexWriter#addMergeException(Lorg/apache/lucene/index/MergePolicy$OneMerge;)V
  merge
    +c:.

org.apache.lucene.index.IndexWriter#onTragicEvent(Ljava/lang/Throwable;Ljava/lang/String;)V
  tragedy
    +c:..

org.apache.lucene.index.IndexWriter#createCompoundFile(Lorg/apache/lucene/util/InfoStream;Lorg/apache/lucene/store/TrackingDirectoryWrapper;Lorg/apache/lucene/index/SegmentInfo;Lorg/apache/lucene/store/IOContext;Lorg/apache/lucene/util/IOUtils$IOConsumer;)V
  directory
    +c:"pass a clean trackingdir for CFS creation".

org.apache.lucene.index.IndexWriter#numDeletesToMerge(Lorg/apache/lucene/index/SegmentCommitInfo;)I
  info
    +c:.

org.apache.lucene.index.LegacySortedNumericDocValuesWrapper#advance(I)I
  target
    +c:cannot advance backwards: docID=     target=.

org.apache.lucene.search.SortedNumericSortField#<init>(Ljava/lang/String;Lorg/apache/lucene/search/SortField$Type;ZLorg/apache/lucene/search/SortedNumericSelector$Type;)V
  type
    +c:.
  selector
    +c:.

org.apache.lucene.search.TotalHits#<init>(JLorg/apache/lucene/search/TotalHits$Relation;)V
  value
    +c:value must be >= 0, got.

org.apache.lucene.search.SearcherManager#<init>(Lorg/apache/lucene/index/IndexWriter;ZZLorg/apache/lucene/search/SearcherFactory;)V
  applyAllDeletes
    +d: If true, all buffered deletes will be applied (made visible) in the IndexSearcher / DirectoryReader . If false, the deletes may or may not be applied, but remain buffered (in IndexWriter) so that they will be applied in the future. Applying deletes can be costly, so if your app can tolerate deleted documents being returned you might gain some performance by passing false. See DirectoryReader#openIfChanged(DirectoryReader,IndexWriter,boolean) .

org.apache.lucene.search.SearcherManager#<init>(Lorg/apache/lucene/index/DirectoryReader;Lorg/apache/lucene/search/SearcherFactory;)V
  reader
    +c:

org.apache.lucene.search.SearcherManager#refreshIfNeeded(Lorg/apache/lucene/search/IndexSearcher;)Lorg/apache/lucene/search/IndexSearcher;
  referenceToRefresh
    +c:

org.apache.lucene.search.SearcherManager#getSearcher(Lorg/apache/lucene/search/SearcherFactory;Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/index/IndexReader;)Lorg/apache/lucene/search/IndexSearcher;
  reader
    +c:SearcherFactory must wrap exactly the provided reader (got      but expected   ).

org.apache.lucene.search.SynonymQuery#<init>([Lorg/apache/lucene/index/Term;)V
  terms
    +c:.

org.apache.lucene.search.WildcardQuery#<init>(Lorg/apache/lucene/index/Term;I)V
  maxDeterminizedStates
    +d: maximum number of states in the resulting automata.  If the automata would need more than this many states TooComplextToDeterminizeException is thrown.  Higher number require more space but can process more complex automata.

org.apache.lucene.search.AutomatonQuery#<init>(Lorg/apache/lucene/index/Term;Lorg/apache/lucene/util/automaton/Automaton;I)V
  maxDeterminizedStates
    +d: maximum number of states in the resulting automata.  If the automata would need more than this many states TooComplextToDeterminizeException is thrown.  Higher number require more space but can process more complex automata.

org.apache.lucene.search.AutomatonQuery#<init>(Lorg/apache/lucene/index/Term;Lorg/apache/lucene/util/automaton/Automaton;IZ)V
  maxDeterminizedStates
    +d: maximum number of states in the resulting automata.  If the automata would need more than this many states TooComplextToDeterminizeException is thrown.  Higher number require more space but can process more complex automata.

org.apache.lucene.search.TermStatistics#<init>(Lorg/apache/lucene/util/BytesRef;JJ)V
  docFreq
    +c:docFreq must be positive, docFreq:.
  totalTermFreq
    +c:totalTermFreq must be positive, totalTermFreq:.totalTermFreq must be at least docFreq, totalTermFreq:   , docFreq:.

org.apache.lucene.search.IndexOrDocValuesQuery#<init>(Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/Query;)V
  dvQuery
    +d: a query whose scorer is cheap to create that can quickly check whether a given document matches

org.apache.lucene.search.MultiCollectorManager#<init>([Lorg/apache/lucene/search/CollectorManager;)V
  collectorManagers
    +c:"There must be at least one collector".

org.apache.lucene.search.LRUQueryCache#onMiss(Ljava/lang/Object;Lorg/apache/lucene/search/Query;)V
  query
    +c:.

org.apache.lucene.search.LRUQueryCache#get(Lorg/apache/lucene/search/Query;Lorg/apache/lucene/index/LeafReaderContext;Lorg/apache/lucene/index/IndexReader$CacheHelper;)Lorg/apache/lucene/search/DocIdSet;
  key
    +c:..

org.apache.lucene.search.LRUQueryCache#putIfAbsent(Lorg/apache/lucene/search/Query;Lorg/apache/lucene/index/LeafReaderContext;Lorg/apache/lucene/search/DocIdSet;Lorg/apache/lucene/index/IndexReader$CacheHelper;)V
  query
    +c:..

org.apache.lucene.search.BooleanQuery#setMaxClauseCount(I)V
  maxClauseCount
    +c:"maxClauseCount must be >= 1".

org.apache.lucene.search.SortedSetSelector#wrap(Lorg/apache/lucene/index/SortedSetDocValues;Lorg/apache/lucene/search/SortedSetSelector$Type;)Lorg/apache/lucene/index/SortedDocValues;
  sortedSet
    +c:fields containing more than     unique terms are unsupported.
  selector
    +c:.

org.apache.lucene.search.PhraseQuery#termPositionsCost(Lorg/apache/lucene/index/TermsEnum;)F
  termsEnum
    +c:

org.apache.lucene.search.SearcherFactory#newSearcher(Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/index/IndexReader;)Lorg/apache/lucene/search/IndexSearcher;
  previousReader
    +d: the reader previously used to create a new searcher. This can be null if unknown or if the given reader is the initially opened reader. If this reader is non-null it can be used to find newly opened segments compared to the new reader to warm the searcher up before returning.

org.apache.lucene.search.Sort#setSort([Lorg/apache/lucene/search/SortField;)V
  fields
    +c:"There must be at least 1 sort field".

org.apache.lucene.search.ImpactsDISI#setMinCompetitiveScore(F)V
  minCompetitiveScore
    +c:.

org.apache.lucene.search.ImpactsDISI#advanceTarget(I)I
  target
    +c:.

org.apache.lucene.search.DisjunctionMaxQuery#<init>(Ljava/util/Collection;F)V
  tieBreakerMultiplier
    +d:  the score of each non-maximum disjunct for a document is multiplied by this weight and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that 10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique word in the lower scored field (i.e., one that is not in any higher scored field.
    +c:"tieBreakerMultiplier must be in [0, 1]".

org.apache.lucene.search.SortField#<init>(Ljava/lang/String;Lorg/apache/lucene/search/SortField$Type;)V
  type
    +c:

org.apache.lucene.search.SortField#<init>(Ljava/lang/String;Lorg/apache/lucene/search/SortField$Type;Z)V
  type
    +c:

org.apache.lucene.search.SortField#setMissingValue(Ljava/lang/Object;)V
  missingValue
    +c:"For STRING type, missing value must be either STRING_FIRST or STRING_LAST".Missing values for Type.INT can only be of type java.lang.Integer, but got.Missing values for Type.LONG can only be of type java.lang.Long, but got.Missing values for Type.FLOAT can only be of type java.lang.Float, but got.Missing values for Type.DOUBLE can only be of type java.lang.Double, but got.

org.apache.lucene.search.SortField#<init>(Ljava/lang/String;Lorg/apache/lucene/search/FieldComparatorSource;)V
  field
    +d: Name of field to sort by; cannot be null.

org.apache.lucene.search.SortField#<init>(Ljava/lang/String;Lorg/apache/lucene/search/FieldComparatorSource;Z)V
  field
    +d: Name of field to sort by; cannot be null.

org.apache.lucene.search.SortField#getComparator(II)Lorg/apache/lucene/search/FieldComparator;
  sortPos
    +d: position of this SortField within Sort .  The comparator is primary if sortPos==0, secondary if sortPos==1, etc.  Some comparators can optimize themselves when they are the primary sort.

org.apache.lucene.search.SortedNumericSelector#wrap(Lorg/apache/lucene/index/SortedNumericDocValues;Lorg/apache/lucene/search/SortedNumericSelector$Type;Lorg/apache/lucene/search/SortField$Type;)Lorg/apache/lucene/index/NumericDocValues;
  selector
    +c:.
  numericType
    +c:"numericType must be a numeric type".

org.apache.lucene.search.ControlledRealTimeReopenThread#<init>(Lorg/apache/lucene/index/IndexWriter;Lorg/apache/lucene/search/ReferenceManager;DD)V
  targetMaxStaleSec
    +d: Maximum time until a new reader must be opened; this sets the upper bound on how slowly reopens may occur, when no caller is waiting for a specific generation to become visible.
  targetMinStaleSec
    +d: Mininum time until a new reader can be opened; this sets the lower bound on how quickly reopens may occur, when a caller is waiting for a specific generation to become visible.
    +c:targetMaxScaleSec (=   ) < targetMinStaleSec (=  ).

org.apache.lucene.search.SortedSetSortField#<init>(Ljava/lang/String;ZLorg/apache/lucene/search/SortedSetSelector$Type;)V
  selector
    +c:.

org.apache.lucene.search.SortedSetSortField#setMissingValue(Ljava/lang/Object;)V
  missingValue
    +c:"For SORTED_SET type, missing value must be either STRING_FIRST or STRING_LAST".

org.apache.lucene.search.FuzzyQuery#<init>(Lorg/apache/lucene/index/Term;IIIZ)V
  maxEdits
    +c:maxEdits must be between 0 and.
  prefixLength
    +c:"prefixLength cannot be negative.".
  maxExpansions
    +c:"maxExpansions must be positive.".

org.apache.lucene.search.CollectionStatistics#<init>(Ljava/lang/String;JJJJ)V
  maxDoc
    +c:maxDoc must be positive, maxDoc:.
  docCount
    +c:docCount must be positive, docCount:.docCount must not exceed maxDoc, docCount:   , maxDoc:.
  sumTotalTermFreq
    +c:sumTotalTermFreq must be positive, sumTotalTermFreq:.sumTotalTermFreq must be at least sumDocFreq, sumTotalTermFreq:   , sumDocFreq:.
  sumDocFreq
    +c:sumDocFreq must be positive, sumDocFreq:.sumDocFreq must be at least docCount, sumDocFreq:   , docCount:.

org.apache.lucene.search.LeafSimScorer#score(IF)F
  doc
    +c:

org.apache.lucene.search.LeafSimScorer#explain(ILorg/apache/lucene/search/Explanation;)Lorg/apache/lucene/search/Explanation;
  doc
    +c:

org.apache.lucene.search.BoostQuery#<init>(Lorg/apache/lucene/search/Query;F)V
  boost
    +c:boost must be a positive float, got.

org.apache.lucene.search.IndexSearcher#<init>(Lorg/apache/lucene/index/IndexReaderContext;Ljava/util/concurrent/ExecutorService;)V
  context
    +c:.

org.apache.lucene.search.IndexSearcher#searchAfter(Lorg/apache/lucene/search/ScoreDoc;Lorg/apache/lucene/search/Query;I)Lorg/apache/lucene/search/TopDocs;
  after
    +c:after.doc exceeds the number of documents in the reader: after.doc=    limit=.

org.apache.lucene.search.IndexSearcher#searchAfter(Lorg/apache/lucene/search/ScoreDoc;Lorg/apache/lucene/search/Query;ILorg/apache/lucene/search/Sort;)Lorg/apache/lucene/search/TopDocs;
  after
    +c:

org.apache.lucene.search.IndexSearcher#searchAfter(Lorg/apache/lucene/search/ScoreDoc;Lorg/apache/lucene/search/Query;ILorg/apache/lucene/search/Sort;Z)Lorg/apache/lucene/search/TopFieldDocs;
  after
    +c:after must be a FieldDoc; got.

org.apache.lucene.search.IndexSearcher#collectionStatistics(Ljava/lang/String;)Lorg/apache/lucene/search/CollectionStatistics;
  field
    +c:.

org.apache.lucene.search.TermQuery#<init>(Lorg/apache/lucene/index/Term;Lorg/apache/lucene/index/TermStates;)V
  states
    +c:.

org.apache.lucene.search.PrefixQuery#<init>(Lorg/apache/lucene/index/Term;)V
  prefix
    +c:"prefix must not be null".

org.apache.lucene.search.UsageTrackingQueryCachingPolicy#onUse(Lorg/apache/lucene/search/Query;)V
  query
    +c:..

org.apache.lucene.search.UsageTrackingQueryCachingPolicy#frequency(Lorg/apache/lucene/search/Query;)I
  query
    +c:..

org.apache.lucene.search.SearcherLifetimeManager#record(Lorg/apache/lucene/search/IndexSearcher;)J
  searcher
    +c:the provided searcher has the same underlying reader version yet the searcher instance differs from before (new=   vs old=.

org.apache.lucene.search.TopDocs#tieBreakLessThan(Lorg/apache/lucene/search/TopDocs$ShardRef;Lorg/apache/lucene/search/ScoreDoc;Lorg/apache/lucene/search/TopDocs$ShardRef;Lorg/apache/lucene/search/ScoreDoc;)Z
  first
    +c:
  second
    +c:
  secondDoc
    +c:

org.apache.lucene.search.TopDocs#merge(I[Lorg/apache/lucene/search/TopDocs;)Lorg/apache/lucene/search/TopDocs;
  shardHits
    +c:

org.apache.lucene.search.TopDocs#merge(II[Lorg/apache/lucene/search/TopDocs;Z)Lorg/apache/lucene/search/TopDocs;
  start
    +c:
  shardHits
    +c:
  setShardIndex
    +c:

org.apache.lucene.search.TopDocs#merge(Lorg/apache/lucene/search/Sort;I[Lorg/apache/lucene/search/TopFieldDocs;)Lorg/apache/lucene/search/TopFieldDocs;
  sort
    +c:
  shardHits
    +c:

org.apache.lucene.search.TopDocs#merge(Lorg/apache/lucene/search/Sort;II[Lorg/apache/lucene/search/TopFieldDocs;Z)Lorg/apache/lucene/search/TopFieldDocs;
  sort
    +c:"sort must be non-null when merging field-docs".
  start
    +c:
  shardHits
    +c:
  setShardIndex
    +c:

org.apache.lucene.search.SortRescorer#explain(Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/Explanation;I)Lorg/apache/lucene/search/Explanation;
  searcher
    +c:

org.apache.lucene.search.FuzzyTermsEnum#<init>(Lorg/apache/lucene/index/Terms;Lorg/apache/lucene/util/AttributeSource;Lorg/apache/lucene/index/Term;IIZ)V
  maxEdits
    +c:max edits must be 0..   , inclusive; got:.
  prefixLength
    +c:"prefixLength cannot be less than 0".

org.apache.lucene.search.FuzzyTermsEnum#getAutomatonEnum(ILorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/index/TermsEnum;
  editDistance
    +c:.

org.apache.lucene.search.ConjunctionDISI#intersectScorers(Ljava/util/Collection;)Lorg/apache/lucene/search/DocIdSetIterator;
  scorers
    +c:"Cannot make a ConjunctionDISI of less than 2 iterators".

org.apache.lucene.search.ConjunctionDISI#intersectIterators(Ljava/util/List;)Lorg/apache/lucene/search/DocIdSetIterator;
  iterators
    +c:"Cannot make a ConjunctionDISI of less than 2 iterators".

org.apache.lucene.search.ConjunctionDISI#intersectSpans(Ljava/util/List;)Lorg/apache/lucene/search/DocIdSetIterator;
  spanList
    +c:"Cannot make a ConjunctionDISI of less than 2 iterators".

org.apache.lucene.search.ConjunctionDISI#<init>(Ljava/util/List;)V
  iterators
    +c:.

org.apache.lucene.search.ConjunctionDISI#doNext(I)I
  doc
    +c:.

org.apache.lucene.search.similarities.BM25Similarity#<init>(FF)V
  k1
    +c:illegal k1 value:   , must be a non-negative finite value.
  b
    +c:illegal b value:   , must be between 0 and 1.

org.apache.lucene.search.similarities.NormalizationZ#<init>(F)V
  z
    +c:illegal z value:   , must be in the range (0 .. 0.5).

org.apache.lucene.search.similarities.NormalizationH3#<init>(F)V
  mu
    +c:illegal mu value:   , must be a non-negative finite value.

org.apache.lucene.search.similarities.DFRSimilarity#<init>(Lorg/apache/lucene/search/similarities/BasicModel;Lorg/apache/lucene/search/similarities/AfterEffect;Lorg/apache/lucene/search/similarities/Normalization;)V
  basicModel
    +c:"null parameters not allowed.".

org.apache.lucene.search.similarities.NormalizationH2#<init>(F)V
  c
    +c:illegal c value:   , must be a non-negative finite value.

org.apache.lucene.search.similarities.DistributionSPL#score(Lorg/apache/lucene/search/similarities/BasicStats;DD)D
  lambda
    +c:.

org.apache.lucene.search.similarities.NormalizationH1#<init>(F)V
  c
    +c:illegal c value:   , must be a non-negative finite value.

org.apache.lucene.search.similarities.LMDirichletSimilarity#<init>(Lorg/apache/lucene/search/similarities/LMSimilarity$CollectionModel;F)V
  mu
    +c:illegal mu value:   , must be a non-negative finite value.

org.apache.lucene.search.similarities.LMDirichletSimilarity#<init>(F)V
  mu
    +c:illegal mu value:   , must be a non-negative finite value.

org.apache.lucene.search.similarities.LMJelinekMercerSimilarity#<init>(Lorg/apache/lucene/search/similarities/LMSimilarity$CollectionModel;F)V
  lambda
    +c:"lambda must be in the range (0 .. 1]".

org.apache.lucene.search.similarities.LMJelinekMercerSimilarity#<init>(F)V
  lambda
    +c:"lambda must be in the range (0 .. 1]".

org.apache.lucene.search.spans.SpanPositionRangeQuery#acceptPosition(Lorg/apache/lucene/search/spans/Spans;)Lorg/apache/lucene/search/spans/FilterSpans$AcceptStatus;
  spans
    +c:.

org.apache.lucene.search.spans.TermSpans#<init>(Lorg/apache/lucene/search/LeafSimScorer;Lorg/apache/lucene/index/PostingsEnum;Lorg/apache/lucene/index/Term;F)V
  positionsCost
    +c:.

org.apache.lucene.search.spans.TermSpans#advance(I)I
  target
    +c:.

org.apache.lucene.search.spans.SpanOrQuery#addClause(Lorg/apache/lucene/search/spans/SpanQuery;)V
  clause
    +c:"Clauses must have same field.".

org.apache.lucene.search.spans.SpanTermQuery#termPositionsCost(Lorg/apache/lucene/index/TermsEnum;)F
  termsEnum
    +c:

org.apache.lucene.search.spans.SpanFirstQuery#acceptPosition(Lorg/apache/lucene/search/spans/Spans;)Lorg/apache/lucene/search/spans/FilterSpans$AcceptStatus;
  spans
    +c:.

org.apache.lucene.search.spans.NearSpansUnordered#positionsOrdered(Lorg/apache/lucene/search/spans/Spans;Lorg/apache/lucene/search/spans/Spans;)Z
  spans2
    +c:

org.apache.lucene.search.spans.SpanNotQuery#<init>(Lorg/apache/lucene/search/spans/SpanQuery;Lorg/apache/lucene/search/spans/SpanQuery;II)V
  include
    +c:"Clauses must have same field.".

org.apache.lucene.store.IOContext#<init>(Lorg/apache/lucene/store/FlushInfo;)V
  flushInfo
    +c:.

org.apache.lucene.store.IOContext#<init>(Lorg/apache/lucene/store/IOContext$Context;Lorg/apache/lucene/store/MergeInfo;)V
  context
    +c:.

org.apache.lucene.store.MMapDirectory#<init>(Ljava/nio/file/Path;Lorg/apache/lucene/store/LockFactory;I)V
  maxChunkSize
    +c:"Maximum chunk size for mmap must be >0".

org.apache.lucene.store.MMapDirectory#setUseUnmap(Z)V
  useUnmapHack
    +c:.

org.apache.lucene.store.MMapDirectory#map(Ljava/lang/String;Ljava/nio/channels/FileChannel;JJ)[Ljava/nio/ByteBuffer;
  length
    +c:RandomAccessFile too big for chunk size:.

org.apache.lucene.store.InputStreamDataInput#readBytes([BII)V
  b
    +c:
  offset
    +c:
  len
    +c:

org.apache.lucene.store.RAMDirectory#fileLength(Ljava/lang/String;)J
  name
    +c:.

org.apache.lucene.store.RAMDirectory#deleteFile(Ljava/lang/String;)V
  name
    +c:.

org.apache.lucene.store.RAMDirectory#createOutput(Ljava/lang/String;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/store/IndexOutput;
  name
    +c:.

org.apache.lucene.store.RAMDirectory#rename(Ljava/lang/String;Ljava/lang/String;)V
  source
    +c:.file was unexpectedly replaced:.
  dest
    +c:.

org.apache.lucene.store.RAMDirectory#openInput(Ljava/lang/String;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/store/IndexInput;
  name
    +c:.

org.apache.lucene.store.ByteArrayDataOutput#writeBytes([BII)V
  length
    +c:.

org.apache.lucene.store.FileSwitchDirectory#rename(Ljava/lang/String;Ljava/lang/String;)V
  dest
    +c:"source and dest are in different directories".

org.apache.lucene.store.ByteBuffersDataOutput#<init>(IILjava/util/function/IntFunction;Ljava/util/function/Consumer;)V
  minBitsPerBlock
    +c:Invalid arguments: %s %s.

org.apache.lucene.store.ByteBuffersDataOutput#writeBytes([BII)V
  length
    +c:.

org.apache.lucene.store.ByteBuffersDataOutput#writeBytes([BI)V
  length
    +c:

org.apache.lucene.store.ByteBuffersDataOutput#writeString(Ljava/lang/String;)V
  v
    +c:

org.apache.lucene.store.RAMInputStream#<init>(Ljava/lang/String;Lorg/apache/lucene/store/RAMFile;J)V
  length
    +c:RAMInputStream too large length=  :.

org.apache.lucene.store.RAMInputStream#slice(Ljava/lang/String;JJ)Lorg/apache/lucene/store/IndexInput;
  offset
    +c:
  sliceLength
    +c:slice()    out of bounds:.

org.apache.lucene.store.ByteArrayIndexInput#seek(J)V
  pos
    +c:.

org.apache.lucene.store.ByteArrayIndexInput#slice(Ljava/lang/String;JJ)Lorg/apache/lucene/store/ByteArrayIndexInput;
  offset
    +c:slice(offset=%s, length=%s) is out of bounds: %s.

org.apache.lucene.store.ByteBuffersDataInput#<init>(Ljava/util/List;)V
  buffers
    +c:

org.apache.lucene.store.ByteBuffersDataInput#seek(J)V
  position
    +c:.

org.apache.lucene.store.ByteBuffersDataInput#slice(JJ)Lorg/apache/lucene/store/ByteBuffersDataInput;
  offset
    +c:slice(offset=%s, length=%s) is out of bounds: %s.

org.apache.lucene.store.SingleInstanceLockFactory#obtainLock(Lorg/apache/lucene/store/Directory;Ljava/lang/String;)Lorg/apache/lucene/store/Lock;
  lockName
    +c:lock instance already obtained: (dir=  , lockName=  ).

org.apache.lucene.store.SleepingLockWrapper#<init>(Lorg/apache/lucene/store/Directory;JJ)V
  lockWaitTimeout
    +c:lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got   ).
  pollInterval
    +c:pollInterval must be a non-negative number (got   ).

org.apache.lucene.store.ByteBuffersDirectory#deleteFile(Ljava/lang/String;)V
  name
    +c:.

org.apache.lucene.store.ByteBuffersDirectory#fileLength(Ljava/lang/String;)J
  name
    +c:.

org.apache.lucene.store.ByteBuffersDirectory#createOutput(Ljava/lang/String;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/store/IndexOutput;
  name
    +c:File already exists:.

org.apache.lucene.store.ByteBuffersDirectory#rename(Ljava/lang/String;Ljava/lang/String;)V
  source
    +c:.File was unexpectedly replaced:.
  dest
    +c:.

org.apache.lucene.store.ByteBuffersDirectory#openInput(Ljava/lang/String;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/store/IndexInput;
  name
    +c:.

org.apache.lucene.store.RAMOutputStream#writeBytes([BII)V
  b
    +c:.

org.apache.lucene.store.NRTCachingDirectory#rename(Ljava/lang/String;Ljava/lang/String;)V
  dest
    +c:target file    already exists.

org.apache.lucene.store.NRTCachingDirectory#unCache(Ljava/lang/String;)V
  fileName
    +c:.

org.apache.lucene.util.UnicodeUtil#codePointCount(Lorg/apache/lucene/util/BytesRef;)I
  utf8
    +c:

org.apache.lucene.util.UnicodeUtil#UTF8toUTF32(Lorg/apache/lucene/util/BytesRef;[I)I
  utf8
    +c:

org.apache.lucene.util.UnicodeUtil#newString([III)Ljava/lang/String;
  codePoints
    +c:
  offset
    +c:
  count
    +c:.

org.apache.lucene.util.UnicodeUtil#UTF8toUTF16([BII[C)I
  utf8
    +c:
  offset
    +c:
  length
    +c:

org.apache.lucene.util.BitDocIdSet#<init>(Lorg/apache/lucene/util/BitSet;J)V
  cost
    +c:cost must be >= 0, got.

org.apache.lucene.util.SentinelIntSet#<init>(II)V
  size
    +d:  The minimum number of elements this set should be able to hold without rehashing (i.e. the slots are guaranteed not to change)

org.apache.lucene.util.SentinelIntSet#getSlot(I)I
  key
    +c:.

org.apache.lucene.util.SentinelIntSet#find(I)I
  key
    +c:.

org.apache.lucene.util.FrequencyTrackingRingBuffer#<init>(II)V
  maxSize
    +c:"maxSize must be at least 2".

org.apache.lucene.util.RecyclingByteBlockAllocator#recycleByteBlocks([[BII)V
  start
    +c:
  end
    +c:

org.apache.lucene.util.RecyclingByteBlockAllocator#freeBlocks(I)I
  num
    +c:.

org.apache.lucene.util.VirtualMethod#<init>(Ljava/lang/Class;Ljava/lang/String;[Ljava/lang/Class;)V
  baseClass
    +c:VirtualMethod instances must be singletons and therefore  assigned to static final members in the same class, they use as baseClass ctor param.has no such method:.

org.apache.lucene.util.VirtualMethod#reflectImplementationDistance(Ljava/lang/Class;)I
  subclazz
    +c:is not a subclass of.

org.apache.lucene.util.RecyclingIntBlockAllocator#recycleIntBlocks([[III)V
  start
    +c:
  end
    +c:

org.apache.lucene.util.RecyclingIntBlockAllocator#freeBlocks(I)I
  num
    +c:.

org.apache.lucene.util.Version#parse(Ljava/lang/String;)Lorg/apache/lucene/util/Version;
  version
    +c:Version is not in form major.minor.bugfix(.prerelease) (got:   ).Version is not in form major.minor.bugfix(.prerelease) (got:   ).Invalid value      for prerelease; should be 1 or 2 (got:   ).Version is not in form major.minor.bugfix(.prerelease) (got:   ).

org.apache.lucene.util.Version#<init>(IIII)V
  major
    +c:Illegal major version:.
  minor
    +c:Illegal minor version:.
  bugfix
    +c:Illegal bugfix version:.
  prerelease
    +c:Illegal prerelease version:.Prerelease version only supported with major release (got prerelease:   , minor:   , bugfix:   ).

org.apache.lucene.util.BytesRef#<init>(Ljava/lang/CharSequence;)V
  text
    +d: This must be well-formed unicode text, with no unpaired surrogates.

org.apache.lucene.util.BytesRef#bytesEquals(Lorg/apache/lucene/util/BytesRef;)Z
  other
    +d: Another BytesRef, should not be null.

org.apache.lucene.util.RamUsageEstimator#shallowSizeOfInstance(Ljava/lang/Class;)J
  clazz
    +c:"This method does not work with array classes.".

org.apache.lucene.util.SparseFixedBitSet#<init>(I)V
  length
    +c:"length needs to be >= 1".

org.apache.lucene.util.SparseFixedBitSet#get(I)Z
  i
    +c:.

org.apache.lucene.util.SparseFixedBitSet#set(I)V
  i
    +c:.

org.apache.lucene.util.SparseFixedBitSet#clear(I)V
  i
    +c:.

org.apache.lucene.util.SparseFixedBitSet#clear(II)V
  from
    +c:.
  to
    +c:.

org.apache.lucene.util.SparseFixedBitSet#nextSetBit(I)I
  i
    +c:.

org.apache.lucene.util.SparseFixedBitSet#prevSetBit(I)I
  i
    +c:.

org.apache.lucene.util.CommandLineUtil#newFSDirectory(Ljava/lang/String;Ljava/nio/file/Path;Lorg/apache/lucene/store/LockFactory;)Lorg/apache/lucene/store/FSDirectory;
  clazzName
    +c:implementation not found:.is not a     implementation.constructor with     as parameter not found.Error creating    instance.

org.apache.lucene.util.CommandLineUtil#adjustDirectoryClassName(Ljava/lang/String;)Ljava/lang/String;
  clazzName
    +c:The     implementation must not be null or empty.

org.apache.lucene.util.IntBlockPool#reset(ZZ)V
  zeroFillBuffers
    +d: if true the buffers are filled with <tt>0</tt>. This should be set to true if this pool is used with SliceWriter .

org.apache.lucene.util.IOUtils#rethrowAlways(Ljava/lang/Throwable;)Ljava/lang/Error;
  th
    +d: The throwable to rethrow, <strong>must not be null</strong>.
    +c:"rethrow argument must not be null."..

org.apache.lucene.util.IOUtils#reThrow(Ljava/lang/Throwable;)V
  th
    +c:

org.apache.lucene.util.IOUtils#reThrowUnchecked(Ljava/lang/Throwable;)V
  th
    +c:.

org.apache.lucene.util.IOUtils#fsync(Ljava/nio/file/Path;Z)V
  isDir
    +c:

org.apache.lucene.util.FutureArrays#checkFromToIndex(III)V
  fromIndex
    +c:fromIndex    > toIndex.
  length
    +c:Range [  ,   ) out-of-bounds for length.

org.apache.lucene.util.BitSetIterator#getFixedBitSetOrNull(Lorg/apache/lucene/search/DocIdSetIterator;)Lorg/apache/lucene/util/FixedBitSet;
  iterator
    +c:

org.apache.lucene.util.BitSetIterator#getSparseFixedBitSetOrNull(Lorg/apache/lucene/search/DocIdSetIterator;)Lorg/apache/lucene/util/SparseFixedBitSet;
  iterator
    +c:

org.apache.lucene.util.BitSetIterator#<init>(Lorg/apache/lucene/util/BitSet;J)V
  cost
    +c:cost must be >= 0, got.

org.apache.lucene.util.NumericUtils#subtract(II[B[B[B)V
  bytesPerDim
    +c:
  dim
    +c:

org.apache.lucene.util.NumericUtils#add(II[B[B[B)V
  bytesPerDim
    +c:a + b overflows bytesPerDim=.

org.apache.lucene.util.NumericUtils#bigIntToSortableBytes(Ljava/math/BigInteger;I[BI)V
  bigInt
    +c:
  bigIntSize
    +c:BigInteger:    requires more than    bytes storage.

org.apache.lucene.util.MathUtil#log(JI)I
  base
    +c:"base must be > 1".

org.apache.lucene.util.LongBitSet#bits2words(J)I
  numBits
    +c:numBits must be 0 ..   ; got:.

org.apache.lucene.util.LongBitSet#<init>([JJ)V
  storedBits
    +c:The given long array is too small  to hold    bits.

org.apache.lucene.util.LongBitSet#get(J)Z
  index
    +c:.

org.apache.lucene.util.LongBitSet#set(J)V
  index
    +c:.

org.apache.lucene.util.LongBitSet#getAndSet(J)Z
  index
    +c:.

org.apache.lucene.util.LongBitSet#clear(J)V
  index
    +c:.

org.apache.lucene.util.LongBitSet#getAndClear(J)Z
  index
    +c:.

org.apache.lucene.util.LongBitSet#nextSetBit(J)J
  index
    +c:.

org.apache.lucene.util.LongBitSet#prevSetBit(J)J
  index
    +c:.

org.apache.lucene.util.LongBitSet#or(Lorg/apache/lucene/util/LongBitSet;)V
  other
    +c:.

org.apache.lucene.util.LongBitSet#xor(Lorg/apache/lucene/util/LongBitSet;)V
  other
    +c:.

org.apache.lucene.util.LongBitSet#flip(JJ)V
  startIndex
    +c:.
  endIndex
    +c:.

org.apache.lucene.util.LongBitSet#flip(J)V
  index
    +c:.

org.apache.lucene.util.LongBitSet#set(JJ)V
  startIndex
    +c:.
  endIndex
    +c:.

org.apache.lucene.util.LongBitSet#clear(JJ)V
  startIndex
    +c:.
  endIndex
    +c:.

org.apache.lucene.util.ByteBlockPool#reset(ZZ)V
  zeroFillBuffers
    +d: if true the buffers are filled with <tt>0</tt>. This should be set to true if this pool is used with slices.

org.apache.lucene.util.ByteBlockPool#setBytesRef(Lorg/apache/lucene/util/BytesRef;I)V
  term
    +c:.

org.apache.lucene.util.BytesRefHash#get(ILorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/util/BytesRef;
  bytesID
    +c:.

org.apache.lucene.util.BytesRefHash#add(Lorg/apache/lucene/util/BytesRef;)I
  bytes
    +c:bytes can be at most    in length; got.

org.apache.lucene.util.BytesRefHash#addByPoolOffset(I)I
  offset
    +c:

org.apache.lucene.util.BytesRefHash#byteStart(I)I
  bytesID
    +c:.

org.apache.lucene.util.NamedSPILoader#checkServiceName(Ljava/lang/String;)V
  name
    +c:Illegal service name: '  ' is too long (must be < 128 chars).Illegal service name: '  ' must be simple ascii alphanumeric.

org.apache.lucene.util.NamedSPILoader#lookup(Ljava/lang/String;)Lorg/apache/lucene/util/NamedSPILoader$NamedSPI;
  name
    +c:An SPI class of type     with name '  ' does not exist.   You need to add the corresponding JAR file supporting this SPI to your classpath.   The current classpath supports the following names:.

org.apache.lucene.util.ArrayUtil#parseInt([CIII)I
  chars
    +c:
  len
    +c:"chars length is 0"."can't convert to an int".
  radix
    +c:

org.apache.lucene.util.ArrayUtil#oversize(II)I
  minTargetSize
    +c:invalid array size.requested array size    exceeds maximum array in java (  ).

org.apache.lucene.util.ArrayUtil#grownull
  minSize
    +c:.

org.apache.lucene.util.ArrayUtil#grow([SI)[S
  minSize
    +c:.

org.apache.lucene.util.ArrayUtil#grow([FI)[F
  minSize
    +c:.

org.apache.lucene.util.ArrayUtil#grow([DI)[D
  minSize
    +c:.

org.apache.lucene.util.ArrayUtil#grow([II)[I
  minSize
    +c:.

org.apache.lucene.util.ArrayUtil#grow([JI)[J
  minSize
    +c:.

org.apache.lucene.util.ArrayUtil#grow([BI)[B
  minSize
    +c:.

org.apache.lucene.util.ArrayUtil#grow([CI)[C
  minSize
    +c:.

org.apache.lucene.util.PagedBytes#<init>(I)V
  blockBits
    +c:.

org.apache.lucene.util.PagedBytes#copy(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/util/BytesRef;)V
  bytes
    +c:.

org.apache.lucene.util.PagedBytes#copyUsingLengthPrefix(Lorg/apache/lucene/util/BytesRef;)J
  bytes
    +c:max length is 32767 (got    ).block size    is too small to store length     bytes.

org.apache.lucene.util.FutureObjects#checkIndex(II)I
  length
    +c:Index    out-of-bounds for length.

org.apache.lucene.util.FutureObjects#checkFromToIndex(III)I
  length
    +c:Range [  ,   ) out-of-bounds for length.

org.apache.lucene.util.FutureObjects#checkFromIndexSize(III)I
  length
    +c:Range [  ,    +   ) out-of-bounds for length.

org.apache.lucene.util.SmallFloat#longToInt4(J)I
  i
    +c:Only supports positive values, got.

org.apache.lucene.util.SmallFloat#intToByte4(I)B
  i
    +c:Only supports positive values, got.

org.apache.lucene.util.FixedBitSet#<init>([JI)V
  storedBits
    +c:The given long array is too small  to hold    bits.

org.apache.lucene.util.FixedBitSet#get(I)Z
  index
    +c:.

org.apache.lucene.util.FixedBitSet#set(I)V
  index
    +c:.

org.apache.lucene.util.FixedBitSet#getAndSet(I)Z
  index
    +c:.

org.apache.lucene.util.FixedBitSet#clear(I)V
  index
    +c:.

org.apache.lucene.util.FixedBitSet#getAndClear(I)Z
  index
    +c:.

org.apache.lucene.util.FixedBitSet#nextSetBit(I)I
  index
    +c:.

org.apache.lucene.util.FixedBitSet#prevSetBit(I)I
  index
    +c:.

org.apache.lucene.util.FixedBitSet#or([JI)V
  otherNumWords
    +c:.

org.apache.lucene.util.FixedBitSet#xor([JI)V
  otherNumWords
    +c:.

org.apache.lucene.util.FixedBitSet#flip(II)V
  startIndex
    +c:.
  endIndex
    +c:.

org.apache.lucene.util.FixedBitSet#flip(I)V
  index
    +c:.

org.apache.lucene.util.FixedBitSet#set(II)V
  startIndex
    +c:.
  endIndex
    +c:.

org.apache.lucene.util.FixedBitSet#clear(II)V
  startIndex
    +c:.
  endIndex
    +c:.

org.apache.lucene.util.OfflineSorter#<init>(Lorg/apache/lucene/store/Directory;Ljava/lang/String;Ljava/util/Comparator;Lorg/apache/lucene/util/OfflineSorter$BufferSize;IILjava/util/concurrent/ExecutorService;I)V
  ramBufferSize
    +c::.
  maxTempfiles
    +c:"maxTempFiles must be >= 2".
  valueLength
    +c:valueLength must be 1 ..    ; got:.
  maxPartitionsInRAM
    +c:maxPartitionsInRAM must be > 0; got.

org.apache.lucene.util.OfflineSorter#sort(Ljava/lang/String;)Ljava/lang/String;
  inputFileName
    +c:

org.apache.lucene.util.SPIClassIterator#<init>(Ljava/lang/Class;Ljava/lang/ClassLoader;)V
  clazz
    +c:Error loading SPI profiles for type     from classpath.

org.apache.lucene.util.AttributeSource#addAttribute(Ljava/lang/Class;)Lorg/apache/lucene/util/Attribute;
  attClass
    +c:addAttribute() only accepts an interface that extends Attribute, but     does not fulfil this contract.

org.apache.lucene.util.AttributeSource#restoreState(Lorg/apache/lucene/util/AttributeSource$State;)V
  state
    +c:State contains AttributeImpl of type        that is not in in this AttributeSource.

org.apache.lucene.util.QueryBuilder#createBooleanQuery(Ljava/lang/String;Ljava/lang/String;)Lorg/apache/lucene/search/Query;
  field
    +c:
  queryText
    +c:

org.apache.lucene.util.QueryBuilder#createBooleanQuery(Ljava/lang/String;Ljava/lang/String;Lorg/apache/lucene/search/BooleanClause$Occur;)Lorg/apache/lucene/search/Query;
  field
    +c:
  queryText
    +c:
  operator
    +c:"invalid operator: only SHOULD or MUST are allowed".

org.apache.lucene.util.QueryBuilder#createPhraseQuery(Ljava/lang/String;Ljava/lang/String;)Lorg/apache/lucene/search/Query;
  field
    +c:
  queryText
    +c:

org.apache.lucene.util.QueryBuilder#createPhraseQuery(Ljava/lang/String;Ljava/lang/String;I)Lorg/apache/lucene/search/Query;
  field
    +c:
  queryText
    +c:
  phraseSlop
    +c:

org.apache.lucene.util.QueryBuilder#createMinShouldMatchQuery(Ljava/lang/String;Ljava/lang/String;F)Lorg/apache/lucene/search/Query;
  field
    +c:
  queryText
    +c:
  fraction
    +c:"fraction should be >= 0 and <= 1".

org.apache.lucene.util.QueryBuilder#createFieldQuery(Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/search/BooleanClause$Occur;Ljava/lang/String;Ljava/lang/String;ZI)Lorg/apache/lucene/search/Query;
  analyzer
    +c:
  operator
    +c:.
  field
    +c:
  queryText
    +c:
  quoted
    +c:
  phraseSlop
    +c:

org.apache.lucene.util.QueryBuilder#createFieldQuery(Lorg/apache/lucene/analysis/TokenStream;Lorg/apache/lucene/search/BooleanClause$Occur;Ljava/lang/String;ZI)Lorg/apache/lucene/search/Query;
  operator
    +c:.
  field
    +c:
  quoted
    +c:
  phraseSlop
    +c:

org.apache.lucene.util.QueryBuilder#analyzeTerm(Ljava/lang/String;Lorg/apache/lucene/analysis/TokenStream;)Lorg/apache/lucene/search/Query;
  stream
    +c:.

org.apache.lucene.util.QueryBuilder#analyzeGraphPhrase(Lorg/apache/lucene/analysis/TokenStream;Ljava/lang/String;I)Lorg/apache/lucene/search/Query;
  field
    +c:
  phraseSlop
    +c:

org.apache.lucene.util.automaton.CompiledAutomaton#floor(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/util/BytesRefBuilder;)Lorg/apache/lucene/util/BytesRef;
  input
    +c:

org.apache.lucene.util.automaton.FiniteStringsIterator#<init>(Lorg/apache/lucene/util/automaton/Automaton;II)V
  endState
    +d: The state where each path should stop or -1 if only accepted states should be final.

org.apache.lucene.util.automaton.RegExp#toAutomaton(I)Lorg/apache/lucene/util/automaton/Automaton;
  maxDeterminizedStates
    +d: maximum number of states in the resulting automata.  If the automata would need more than this many states TooComplextToDeterminizeException is thrown.  Higher number require more space but can process more complex regexes.
    +c:

org.apache.lucene.util.automaton.RegExp#toAutomaton(Lorg/apache/lucene/util/automaton/AutomatonProvider;I)Lorg/apache/lucene/util/automaton/Automaton;
  automaton_provider
    +c:
  maxDeterminizedStates
    +d: maximum number of states in the resulting automata.  If the automata would need more than this many states TooComplextToDeterminizeException is thrown.  Higher number require more space but can process more complex regexes.
    +c:

org.apache.lucene.util.automaton.RegExp#toAutomaton(Ljava/util/Map;I)Lorg/apache/lucene/util/automaton/Automaton;
  automata
    +c:
  maxDeterminizedStates
    +d: maximum number of states in the resulting automata.  If the automata would need more than this many states TooComplexToDeterminizeException is thrown.  Higher number require more space but can process more complex regexes.
    +c:

org.apache.lucene.util.automaton.RegExp#makeCharRange(II)Lorg/apache/lucene/util/automaton/RegExp;
  from
    +c:invalid range: from (  ) cannot be > to (  ).

org.apache.lucene.util.automaton.Automata#makeBinaryInterval(Lorg/apache/lucene/util/BytesRef;ZLorg/apache/lucene/util/BytesRef;Z)Lorg/apache/lucene/util/automaton/Automaton;
  min
    +c:"minInclusive must be true when min is null (open ended)"..
  minInclusive
    +c:
  max
    +c:"maxInclusive must be true when max is null (open ended)".
  maxInclusive
    +c:

org.apache.lucene.util.automaton.Automata#makeDecimalInterval(III)Lorg/apache/lucene/util/automaton/Automaton;
  min
    +c:
  max
    +c:
  digits
    +d: if > 0, use fixed number of digits (strings must be prefixed by 0's to obtain the right length) - otherwise, the number of digits is not fixed (any number of leading 0s is accepted)
    +c:

org.apache.lucene.util.automaton.Automata#makeStringUnion(Ljava/util/Collection;)Lorg/apache/lucene/util/automaton/Automaton;
  utf8Strings
    +d: The input strings, UTF-8 encoded. The collection must be in sorted order.

org.apache.lucene.util.automaton.LevenshteinAutomata#<init>([IIZ)V
  alphaMax
    +c:alphaMax exceeded by symbol     in word.

org.apache.lucene.util.automaton.LevenshteinAutomata#toAutomaton(I)Lorg/apache/lucene/util/automaton/Automaton;
  n
    +c:

org.apache.lucene.util.automaton.LevenshteinAutomata#toAutomaton(ILjava/lang/String;)Lorg/apache/lucene/util/automaton/Automaton;
  n
    +c:
  prefix
    +c:.

org.apache.lucene.util.automaton.Automaton#addTransition(III)V
  source
    +c:

org.apache.lucene.util.automaton.Automaton#addTransition(IIII)V
  source
    +c:from state (  ) already had transitions added.

org.apache.lucene.util.automaton.Automaton#addEpsilon(II)V
  source
    +c:

org.apache.lucene.util.automaton.Automaton#getNumTransitions(I)I
  state
    +c:.

org.apache.lucene.util.automaton.Automaton#initTransition(ILorg/apache/lucene/util/automaton/Transition;)I
  state
    +c:.

org.apache.lucene.util.automaton.Automaton#getNextTransition(Lorg/apache/lucene/util/automaton/Transition;)V
  t
    +c:..

org.apache.lucene.util.automaton.Automaton#step(II)I
  state
    +c:.
  label
    +c:.

org.apache.lucene.util.automaton.LimitedFiniteStringsIterator#<init>(Lorg/apache/lucene/util/automaton/Automaton;I)V
  limit
    +c:limit must be -1 (which means no limit), or > 0; got:.

org.apache.lucene.util.automaton.Operations#complement(Lorg/apache/lucene/util/automaton/Automaton;I)Lorg/apache/lucene/util/automaton/Automaton;
  a
    +c:
  maxDeterminizedStates
    +c:

org.apache.lucene.util.automaton.Operations#minus(Lorg/apache/lucene/util/automaton/Automaton;Lorg/apache/lucene/util/automaton/Automaton;I)Lorg/apache/lucene/util/automaton/Automaton;
  maxDeterminizedStates
    +c:

org.apache.lucene.util.automaton.Operations#sameLanguage(Lorg/apache/lucene/util/automaton/Automaton;Lorg/apache/lucene/util/automaton/Automaton;)Z
  a1
    +c:
  a2
    +c:

org.apache.lucene.util.automaton.Operations#hasDeadStates(Lorg/apache/lucene/util/automaton/Automaton;)Z
  a
    +c:

org.apache.lucene.util.automaton.Operations#subsetOf(Lorg/apache/lucene/util/automaton/Automaton;Lorg/apache/lucene/util/automaton/Automaton;)Z
  a1
    +c:"a1 must be deterministic"..
  a2
    +c:"a2 must be deterministic"..

org.apache.lucene.util.automaton.Operations#determinize(Lorg/apache/lucene/util/automaton/Automaton;I)Lorg/apache/lucene/util/automaton/Automaton;
  a
    +c:
  maxDeterminizedStates
    +c:.

org.apache.lucene.util.automaton.Operations#run(Lorg/apache/lucene/util/automaton/Automaton;Ljava/lang/String;)Z
  a
    +c:.

org.apache.lucene.util.automaton.Operations#run(Lorg/apache/lucene/util/automaton/Automaton;Lorg/apache/lucene/util/IntsRef;)Z
  a
    +c:.

org.apache.lucene.util.automaton.Operations#removeDeadStates(Lorg/apache/lucene/util/automaton/Automaton;)Lorg/apache/lucene/util/automaton/Automaton;
  a
    +c:

org.apache.lucene.util.automaton.Operations#getCommonPrefix(Lorg/apache/lucene/util/automaton/Automaton;)Ljava/lang/String;
  a
    +c:"input automaton must be deterministic".

org.apache.lucene.util.automaton.Operations#getSingleton(Lorg/apache/lucene/util/automaton/Automaton;)Lorg/apache/lucene/util/IntsRef;
  a
    +c:"input automaton must be deterministic".

org.apache.lucene.util.automaton.Operations#getCommonSuffixBytesRef(Lorg/apache/lucene/util/automaton/Automaton;I)Lorg/apache/lucene/util/BytesRef;
  a
    +c:
  maxDeterminizedStates
    +c:

org.apache.lucene.util.automaton.DaciukMihovAutomatonBuilder#add(Lorg/apache/lucene/util/CharsRef;)V
  current
    +c:This builder doesn't allow terms that are larger than 1,000 characters, got...

org.apache.lucene.util.bkd.BKDReader#<init>(Lorg/apache/lucene/store/IndexInput;)V
  in
    +c:minPackedValue      is > maxPackedValue      for dim=.

org.apache.lucene.util.bkd.BKDReader#visitDocValues([I[B[B[BLorg/apache/lucene/store/IndexInput;[IILorg/apache/lucene/index/PointValues$IntersectVisitor;)V
  in
    +c:
  count
    +c:

org.apache.lucene.util.bkd.BKDWriter#<init>(ILorg/apache/lucene/store/Directory;Ljava/lang/String;IIIIDJZZJI)V
  numDataDims
    +c:
  numIndexDims
    +c:
  maxPointsInLeafNode
    +c:maxMBSortInHeap=   only allows for maxPointsSortInHeap=   , but this is less than maxPointsInLeafNode=  ; either increase maxMBSortInHeap or decrease maxPointsInLeafNode.
  maxMBSortInHeap
    +c:
  totalPointCount
    +c:
  longOrds
    +c:.

org.apache.lucene.util.bkd.BKDWriter#verifyParams(IIIDJ)V
  numDataDims
    +c:numDataDims must be 1 ..    (got:   ).
  numIndexDims
    +c:numIndexDims must be 1 ..    (got:   ).
  maxPointsInLeafNode
    +c:maxPointsInLeafNode must be > 0; got.maxPointsInLeafNode must be <= ArrayUtil.MAX_ARRAY_LENGTH (=    ); got.
  maxMBSortInHeap
    +c:maxMBSortInHeap must be >= 0.0 (got:   ).
  totalPointCount
    +c:totalPointCount must be >=0 (got:   ).

org.apache.lucene.util.bkd.BKDWriter#add([BI)V
  packedValue
    +c:packedValue should be length=   (got:    ).

org.apache.lucene.util.bkd.OfflinePointReader#<init>(Lorg/apache/lucene/store/Directory;Ljava/lang/String;IJJZZ)V
  start
    +c:requested slice is beyond the length of this file: start=   length=   bytesPerDoc=      fileLength=     tempFileName=.

org.apache.lucene.util.bkd.OfflinePointReader#markOrds(JLorg/apache/lucene/util/LongBitSet;)V
  count
    +c:only    points remain, but    were requested.
  ordBitSet
    +c:.

org.apache.lucene.util.bkd.OfflinePointReader#split(JLorg/apache/lucene/util/LongBitSet;Lorg/apache/lucene/util/bkd/PointWriter;Lorg/apache/lucene/util/bkd/PointWriter;Z)J
  count
    +c:.

org.apache.lucene.util.bkd.OfflinePointWriter#append([BJI)V
  packedValue
    +c:.
  ord
    +c:.

org.apache.lucene.util.bkd.OfflinePointWriter#getReader(JJ)Lorg/apache/lucene/util/bkd/PointReader;
  start
    +c:
  length
    +c:

org.apache.lucene.util.bkd.OfflinePointWriter#getSharedReader(JJLjava/util/List;)Lorg/apache/lucene/util/bkd/PointReader;
  start
    +c:.
  length
    +c:.

org.apache.lucene.util.bkd.HeapPointWriter#copyFrom(Lorg/apache/lucene/util/bkd/HeapPointWriter;)V
  other
    +c:docIDs.length=    other.nextWrite=.

org.apache.lucene.util.bkd.HeapPointWriter#readPackedValue(I[B)V
  bytes
    +c:.

org.apache.lucene.util.bkd.HeapPointWriter#getPackedValueSlice(ILorg/apache/lucene/util/BytesRef;)V
  result
    +c:.

org.apache.lucene.util.bkd.HeapPointWriter#writePackedValue(I[B)V
  bytes
    +c:.

org.apache.lucene.util.bkd.HeapPointWriter#append([BJI)V
  packedValue
    +c:.
  ord
    +c:.

org.apache.lucene.util.bkd.HeapPointWriter#getReader(JJ)Lorg/apache/lucene/util/bkd/PointReader;
  start
    +c:
  length
    +c:

org.apache.lucene.util.fst.IntSequenceOutputs#common(Lorg/apache/lucene/util/IntsRef;Lorg/apache/lucene/util/IntsRef;)Lorg/apache/lucene/util/IntsRef;
  output1
    +c:.
  output2
    +c:.

org.apache.lucene.util.fst.IntSequenceOutputs#subtract(Lorg/apache/lucene/util/IntsRef;Lorg/apache/lucene/util/IntsRef;)Lorg/apache/lucene/util/IntsRef;
  output
    +c:.
  inc
    +c:..

org.apache.lucene.util.fst.IntSequenceOutputs#add(Lorg/apache/lucene/util/IntsRef;Lorg/apache/lucene/util/IntsRef;)Lorg/apache/lucene/util/IntsRef;
  prefix
    +c:..
  output
    +c:..

org.apache.lucene.util.fst.IntSequenceOutputs#write(Lorg/apache/lucene/util/IntsRef;Lorg/apache/lucene/store/DataOutput;)V
  prefix
    +c:.

org.apache.lucene.util.fst.NoOutputs#common(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
  output1
    +c:.
  output2
    +c:.

org.apache.lucene.util.fst.NoOutputs#subtract(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
  output
    +c:.
  inc
    +c:.

org.apache.lucene.util.fst.NoOutputs#add(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
  prefix
    +c:.
  output
    +c:.

org.apache.lucene.util.fst.NoOutputs#merge(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
  first
    +c:.
  second
    +c:.

org.apache.lucene.util.fst.BytesRefFSTEnum#seekExact(Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/util/fst/BytesRefFSTEnum$InputOutput;
  target
    +c:.

org.apache.lucene.util.fst.PairOutputs#common(Lorg/apache/lucene/util/fst/PairOutputs$Pair;Lorg/apache/lucene/util/fst/PairOutputs$Pair;)Lorg/apache/lucene/util/fst/PairOutputs$Pair;
  pair1
    +c:.
  pair2
    +c:.

org.apache.lucene.util.fst.PairOutputs#subtract(Lorg/apache/lucene/util/fst/PairOutputs$Pair;Lorg/apache/lucene/util/fst/PairOutputs$Pair;)Lorg/apache/lucene/util/fst/PairOutputs$Pair;
  output
    +c:.
  inc
    +c:.

org.apache.lucene.util.fst.PairOutputs#add(Lorg/apache/lucene/util/fst/PairOutputs$Pair;Lorg/apache/lucene/util/fst/PairOutputs$Pair;)Lorg/apache/lucene/util/fst/PairOutputs$Pair;
  prefix
    +c:.
  output
    +c:.

org.apache.lucene.util.fst.PairOutputs#write(Lorg/apache/lucene/util/fst/PairOutputs$Pair;Lorg/apache/lucene/store/DataOutput;)V
  output
    +c:.

org.apache.lucene.util.fst.PairOutputs#outputToString(Lorg/apache/lucene/util/fst/PairOutputs$Pair;)Ljava/lang/String;
  output
    +c:.

org.apache.lucene.util.fst.CharSequenceOutputs#common(Lorg/apache/lucene/util/CharsRef;Lorg/apache/lucene/util/CharsRef;)Lorg/apache/lucene/util/CharsRef;
  output1
    +c:.
  output2
    +c:.

org.apache.lucene.util.fst.CharSequenceOutputs#subtract(Lorg/apache/lucene/util/CharsRef;Lorg/apache/lucene/util/CharsRef;)Lorg/apache/lucene/util/CharsRef;
  output
    +c:.
  inc
    +c:..

org.apache.lucene.util.fst.CharSequenceOutputs#add(Lorg/apache/lucene/util/CharsRef;Lorg/apache/lucene/util/CharsRef;)Lorg/apache/lucene/util/CharsRef;
  prefix
    +c:..
  output
    +c:..

org.apache.lucene.util.fst.CharSequenceOutputs#write(Lorg/apache/lucene/util/CharsRef;Lorg/apache/lucene/store/DataOutput;)V
  prefix
    +c:.

org.apache.lucene.util.fst.FST#<init>(Lorg/apache/lucene/store/DataInput;Lorg/apache/lucene/util/fst/Outputs;I)V
  maxBlockBits
    +c:maxBlockBits should be 1 .. 30; got.

org.apache.lucene.util.fst.FST#finish(J)V
  newStartNode
    +c:.

org.apache.lucene.util.fst.FST#addNode(Lorg/apache/lucene/util/fst/Builder;Lorg/apache/lucene/util/fst/Builder$UnCompiledNode;)J
  builder
    +c:
  nodeIn
    +c:

org.apache.lucene.util.fst.FST#readLastTargetArc(Lorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/util/fst/FST$BytesReader;)Lorg/apache/lucene/util/fst/FST$Arc;
  follow
    +c:.
  arc
    +c:.

org.apache.lucene.util.fst.FST#readNextArc(Lorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/util/fst/FST$BytesReader;)Lorg/apache/lucene/util/fst/FST$Arc;
  arc
    +c:"cannot readNextArc when arc.isLast()=true".

org.apache.lucene.util.fst.FST#readNextArcLabel(Lorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/util/fst/FST$BytesReader;)I
  arc
    +c:.

org.apache.lucene.util.fst.FST#readNextRealArc(Lorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/util/fst/FST$BytesReader;)Lorg/apache/lucene/util/fst/FST$Arc;
  arc
    +c:.

org.apache.lucene.util.fst.Builder#add(Lorg/apache/lucene/util/IntsRef;Ljava/lang/Object;)V
  input
    +c:.
  output
    +c:..

org.apache.lucene.util.fst.ByteSequenceOutputs#common(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/util/BytesRef;
  output1
    +c:.
  output2
    +c:.

org.apache.lucene.util.fst.ByteSequenceOutputs#subtract(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/util/BytesRef;
  output
    +c:.
  inc
    +c:..

org.apache.lucene.util.fst.ByteSequenceOutputs#add(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/util/BytesRef;
  prefix
    +c:..
  output
    +c:..

org.apache.lucene.util.fst.ByteSequenceOutputs#write(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/store/DataOutput;)V
  prefix
    +c:.

org.apache.lucene.util.fst.IntsRefFSTEnum#seekExact(Lorg/apache/lucene/util/IntsRef;)Lorg/apache/lucene/util/fst/IntsRefFSTEnum$InputOutput;
  target
    +c:.

org.apache.lucene.util.fst.PositiveIntOutputs#common(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long;
  output1
    +c:..
  output2
    +c:..

org.apache.lucene.util.fst.PositiveIntOutputs#subtract(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long;
  output
    +c:.
  inc
    +c:.

org.apache.lucene.util.fst.PositiveIntOutputs#add(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long;
  prefix
    +c:.
  output
    +c:.

org.apache.lucene.util.fst.PositiveIntOutputs#write(Ljava/lang/Long;Lorg/apache/lucene/store/DataOutput;)V
  output
    +c:.

org.apache.lucene.util.fst.Util#get(Lorg/apache/lucene/util/fst/FST;Lorg/apache/lucene/util/BytesRef;)Ljava/lang/Object;
  fst
    +c:.

org.apache.lucene.util.fst.Util#toBytesRef(Lorg/apache/lucene/util/IntsRef;Lorg/apache/lucene/util/BytesRefBuilder;)Lorg/apache/lucene/util/BytesRef;
  input
    +c:

org.apache.lucene.util.packed.PackedDataInput#readLong(I)J
  bitsPerValue
    +c:.

org.apache.lucene.util.packed.PackedLongValues#get(J)J
  index
    +c:.

org.apache.lucene.util.packed.DirectWriter#add(J)V
  l
    +c:.

org.apache.lucene.util.packed.DirectWriter#getInstance(Lorg/apache/lucene/store/DataOutput;JI)Lorg/apache/lucene/util/packed/DirectWriter;
  bitsPerValue
    +c:Unsupported bitsPerValue   . Did you use bitsRequired?.

org.apache.lucene.util.packed.DirectWriter#bitsRequired(J)I
  maxValue
    +d: the maximum value that should be representable.

org.apache.lucene.util.packed.DirectWriter#unsignedBitsRequired(J)I
  maxValue
    +d: the maximum value that should be representable.

org.apache.lucene.util.packed.BlockPackedWriter#<init>(Lorg/apache/lucene/store/DataOutput;I)V
  blockSize
    +d: the number of values of a single block, must be a power of 2

org.apache.lucene.util.packed.BlockPackedReader#<init>(Lorg/apache/lucene/store/IndexInput;IIJZ)V
  in
    +c:Corrupted Block#.

org.apache.lucene.util.packed.BlockPackedReader#get(J)J
  index
    +c:.

org.apache.lucene.util.packed.BlockPackedReaderIterator#<init>(Lorg/apache/lucene/store/DataInput;IIJ)V
  blockSize
    +d: the number of values of a block, must be equal to the block size of the BlockPackedWriter which has been used to write the stream
  valueCount
    +c:

org.apache.lucene.util.packed.BlockPackedReaderIterator#reset(Lorg/apache/lucene/store/DataInput;J)V
  valueCount
    +c:.

org.apache.lucene.util.packed.BlockPackedReaderIterator#skip(J)V
  count
    +c:...

org.apache.lucene.util.packed.BlockPackedReaderIterator#next(I)Lorg/apache/lucene/util/LongsRef;
  count
    +c:.

org.apache.lucene.util.packed.MonotonicBlockPackedWriter#<init>(Lorg/apache/lucene/store/DataOutput;I)V
  blockSize
    +d: the number of values of a single block, must be a power of 2

org.apache.lucene.util.packed.MonotonicBlockPackedWriter#add(J)V
  l
    +c:.

org.apache.lucene.util.packed.PackedDataOutput#writeLong(JI)V
  value
    +c:
  bitsPerValue
    +c:

org.apache.lucene.util.packed.MonotonicBlockPackedReader#get(J)J
  index
    +c:.

org.apache.lucene.util.packed.DirectMonotonicWriter#<init>(Lorg/apache/lucene/store/IndexOutput;Lorg/apache/lucene/store/IndexOutput;JI)V
  blockShift
    +c:blockShift must be in [3-30], got.

org.apache.lucene.util.packed.DirectMonotonicWriter#add(J)V
  v
    +c:Values do not come in order:    ,.

org.apache.lucene.util.packed.PagedMutable#newMutable(II)Lorg/apache/lucene/util/packed/PackedInts$Mutable;
  bitsPerValue
    +c:.

org.apache.lucene.util.packed.DirectReader#getInstance(Lorg/apache/lucene/store/RandomAccessInput;IJ)Lorg/apache/lucene/util/LongValues;
  bitsPerValue
    +c:unsupported bitsPerValue:.

org.apache.lucene.util.packed.PackedInts#checkVersion(I)V
  version
    +c:Version is too old, should be at least    (got   ).Version is too new, should be at most    (got   ).

org.apache.lucene.util.packed.PackedInts#getDecoder(Lorg/apache/lucene/util/packed/PackedInts$Format;II)Lorg/apache/lucene/util/packed/PackedInts$Decoder;
  version
    +c:

org.apache.lucene.util.packed.PackedInts#getEncoder(Lorg/apache/lucene/util/packed/PackedInts$Format;II)Lorg/apache/lucene/util/packed/PackedInts$Encoder;
  version
    +c:

org.apache.lucene.util.packed.PackedInts#getReaderNoHeader(Lorg/apache/lucene/store/DataInput;Lorg/apache/lucene/util/packed/PackedInts$Format;III)Lorg/apache/lucene/util/packed/PackedInts$Reader;
  format
    +c:Unknown Writer format:.
  version
    +c:

org.apache.lucene.util.packed.PackedInts#getReader(Lorg/apache/lucene/store/DataInput;)Lorg/apache/lucene/util/packed/PackedInts$Reader;
  in
    +c:

org.apache.lucene.util.packed.PackedInts#getReaderIteratorNoHeader(Lorg/apache/lucene/store/DataInput;Lorg/apache/lucene/util/packed/PackedInts$Format;IIII)Lorg/apache/lucene/util/packed/PackedInts$ReaderIterator;
  version
    +c:

org.apache.lucene.util.packed.PackedInts#getReaderIterator(Lorg/apache/lucene/store/DataInput;I)Lorg/apache/lucene/util/packed/PackedInts$ReaderIterator;
  in
    +c:

org.apache.lucene.util.packed.PackedInts#getDirectReaderNoHeader(Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/util/packed/PackedInts$Format;III)Lorg/apache/lucene/util/packed/PackedInts$Reader;
  format
    +c:Unknwown format:.
  version
    +c:

org.apache.lucene.util.packed.PackedInts#getDirectReader(Lorg/apache/lucene/store/IndexInput;)Lorg/apache/lucene/util/packed/PackedInts$Reader;
  in
    +c:

org.apache.lucene.util.packed.PackedInts#getMutable(IIF)Lorg/apache/lucene/util/packed/PackedInts$Mutable;
  valueCount
    +c:

org.apache.lucene.util.packed.PackedInts#getMutable(IILorg/apache/lucene/util/packed/PackedInts$Format;)Lorg/apache/lucene/util/packed/PackedInts$Mutable;
  valueCount
    +c:.
  format
    +c:.

org.apache.lucene.util.packed.PackedInts#getWriterNoHeader(Lorg/apache/lucene/store/DataOutput;Lorg/apache/lucene/util/packed/PackedInts$Format;III)Lorg/apache/lucene/util/packed/PackedInts$Writer;
  mem
    +d:          how much memory (in bytes) can be used to speed up serialization

org.apache.lucene.util.packed.PackedInts#getWriter(Lorg/apache/lucene/store/DataOutput;IIF)Lorg/apache/lucene/util/packed/PackedInts$Writer;
  valueCount
    +c:.

org.apache.lucene.util.packed.PackedInts#bitsRequired(J)I
  maxValue
    +d: the maximum value that should be representable.
    +c:maxValue must be non-negative (got:   ).

org.apache.lucene.util.packed.PackedInts#copy(Lorg/apache/lucene/util/packed/PackedInts$Reader;ILorg/apache/lucene/util/packed/PackedInts$Mutable;III)V
  src
    +c:
  srcPos
    +c:
  dest
    +c:
  destPos
    +c:
  len
    +c:

org.apache.lucene.util.packed.PackedInts#copy(Lorg/apache/lucene/util/packed/PackedInts$Reader;ILorg/apache/lucene/util/packed/PackedInts$Mutable;II[J)V
  src
    +c:
  srcPos
    +c:
  dest
    +c:
  destPos
    +c:
  buf
    +c:.

org.apache.lucene.util.packed.PackedInts#checkBlockSize(III)I
  blockSize
    +c:blockSize must be >=    and <=   , got.blockSize must be a power of two, got.

org.apache.lucene.util.packed.PackedInts#numBlocks(JI)I
  size
    +c:"size is too large for this block size".

org.apache.lucene.expressions.SimpleBindings#getDoubleValuesSource(Ljava/lang/String;)Lorg/apache/lucene/search/DoubleValuesSource;
  name
    +c:Invalid reference '  '.

org.apache.lucene.expressions.js.JavascriptCompiler#compile(Ljava/lang/String;Ljava/util/Map;Ljava/lang/ClassLoader;)Lorg/apache/lucene/expressions/Expression;
  parent
    +d: a  ClassLoader that should be used as the parent of the loaded class. It must contain all classes referred to by the given  functions .
    +c:"A parent ClassLoader must be given.".

org.apache.lucene.facet.LongValueFacetCounts#<init>(Ljava/lang/String;Lorg/apache/lucene/search/LongValuesSource;Lorg/apache/lucene/facet/FacetsCollector;Z)V
  multiValued
    +c:"can only compute multi-valued facets directly from doc values (when valueSource is null)".

org.apache.lucene.facet.LongValueFacetCounts#getTopChildren(ILjava/lang/String;[Ljava/lang/String;)Lorg/apache/lucene/facet/FacetResult;
  dim
    +c:invalid dim \  \; should be \  \.
  path
    +c:"path.length should be 0".

org.apache.lucene.facet.FacetField#<init>(Ljava/lang/String;[Ljava/lang/String;)V
  path
    +c:"path must have at least one element".

org.apache.lucene.facet.FacetField#verifyLabel(Ljava/lang/String;)V
  label
    +c:empty or null components not allowed; got:.

org.apache.lucene.facet.FacetsCollector#search(Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/Query;ILorg/apache/lucene/search/Sort;Lorg/apache/lucene/search/Collector;)Lorg/apache/lucene/search/TopFieldDocs;
  sort
    +c:"sort must not be null".

org.apache.lucene.facet.FacetsCollector#search(Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/Query;ILorg/apache/lucene/search/Sort;ZLorg/apache/lucene/search/Collector;)Lorg/apache/lucene/search/TopFieldDocs;
  sort
    +c:"sort must not be null".

org.apache.lucene.facet.FacetsCollector#searchAfter(Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/ScoreDoc;Lorg/apache/lucene/search/Query;ILorg/apache/lucene/search/Sort;Lorg/apache/lucene/search/Collector;)Lorg/apache/lucene/search/TopDocs;
  sort
    +c:"sort must not be null".

org.apache.lucene.facet.FacetsCollector#searchAfter(Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/ScoreDoc;Lorg/apache/lucene/search/Query;ILorg/apache/lucene/search/Sort;ZLorg/apache/lucene/search/Collector;)Lorg/apache/lucene/search/TopDocs;
  sort
    +c:"sort must not be null".

org.apache.lucene.facet.FacetsCollector#doSearch(Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/ScoreDoc;Lorg/apache/lucene/search/Query;ILorg/apache/lucene/search/Sort;ZLorg/apache/lucene/search/Collector;)Lorg/apache/lucene/search/TopDocs;
  after
    +c:after.doc exceeds the number of documents in the reader: after.doc=    limit=.after must be a FieldDoc; got.

org.apache.lucene.facet.MultiFacets#getTopChildren(ILjava/lang/String;[Ljava/lang/String;)Lorg/apache/lucene/facet/FacetResult;
  dim
    +c:invalid dim \  \.

org.apache.lucene.facet.MultiFacets#getSpecificValue(Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Number;
  dim
    +c:invalid dim \  \.

org.apache.lucene.facet.FacetsConfig#build(Lorg/apache/lucene/facet/taxonomy/TaxonomyWriter;Lorg/apache/lucene/document/Document;)Lorg/apache/lucene/document/Document;
  taxoWriter
    +c:

org.apache.lucene.facet.FacetsConfig#pathToString([Ljava/lang/String;I)Ljava/lang/String;
  length
    +c:"each path component must have length > 0 (got: \"\")".

org.apache.lucene.facet.FacetsConfig#stringToPath(Ljava/lang/String;)[Ljava/lang/String;
  s
    +c:

org.apache.lucene.facet.range.LongRangeCounter$LongRangeNode#addOutputs(ILorg/apache/lucene/facet/range/LongRange;)V
  range
    +c:

org.apache.lucene.facet.range.DoubleRange#<init>(Ljava/lang/String;DZDZ)V
  minIn
    +c:"min cannot be NaN".
  maxIn
    +c:"max cannot be NaN".

org.apache.lucene.facet.sortedset.ConcurrentSortedSetDocValuesFacetCounts#getTopChildren(ILjava/lang/String;[Ljava/lang/String;)Lorg/apache/lucene/facet/FacetResult;
  topN
    +c:topN must be > 0 (got:   ).
  dim
    +c:dimension \  \ was not indexed.
  path
    +c:"path should be 0 length".

org.apache.lucene.facet.sortedset.ConcurrentSortedSetDocValuesFacetCounts#getSpecificValue(Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Number;
  path
    +c:"path must be length=1".

org.apache.lucene.facet.sortedset.SortedSetDocValuesFacetCounts#getTopChildren(ILjava/lang/String;[Ljava/lang/String;)Lorg/apache/lucene/facet/FacetResult;
  topN
    +c:topN must be > 0 (got:   ).
  dim
    +c:dimension \  \ was not indexed.
  path
    +c:"path should be 0 length".

org.apache.lucene.facet.sortedset.SortedSetDocValuesFacetCounts#getSpecificValue(Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Number;
  path
    +c:"path must be length=1".

org.apache.lucene.facet.sortedset.DefaultSortedSetDocValuesReaderState#<init>(Lorg/apache/lucene/index/IndexReader;Ljava/lang/String;)V
  field
    +c:field \  \ was not indexed with SortedSetDocValues.

org.apache.lucene.facet.taxonomy.AssociationFacetField#<init>(Lorg/apache/lucene/util/BytesRef;Ljava/lang/String;[Ljava/lang/String;)V
  path
    +c:"path must have at least one element".

org.apache.lucene.facet.taxonomy.CachedOrdinalsReader#getCachedOrds(Lorg/apache/lucene/index/LeafReaderContext;)Lorg/apache/lucene/facet/taxonomy/CachedOrdinalsReader$CachedOrds;
  context
    +c:Cannot cache ordinals on leaf:.

org.apache.lucene.facet.taxonomy.LRUHashMap#<init>(I)V
  maxSize
    +d: the maximum size (in number of entries) to which the map can grow before the least recently used entries start being removed.<BR> Setting maxSize to a very large value, like Integer#MAX_VALUE is allowed, but is less efficient than using java.util.HashMap because our class needs to keep track of the use order (via an additional doubly-linked list) which is not used when the map's size is always below the maximum size. 

org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter#getParent(I)I
  ordinal
    +c:.

org.apache.lucene.facet.taxonomy.writercache.UTF8TaxonomyWriterCache#put(Lorg/apache/lucene/facet/taxonomy/FacetLabel;I)Z
  ord
    +c:

org.apache.lucene.search.grouping.BlockGroupingCollector#<init>(Lorg/apache/lucene/search/Sort;IZLorg/apache/lucene/search/Weight;)V
  groupSort
    +d: The Sort used to sort the groups.  The top sorted document within each group according to groupSort, determines how that group sorts against other groups.  This must be non-null, ie, if you want to groupSort by relevance use Sort.RELEVANCE.
  topNGroups
    +c:topNGroups must be >= 1 (got   ).

org.apache.lucene.search.grouping.BlockGroupingCollector#getTopGroups(Lorg/apache/lucene/search/Sort;III)Lorg/apache/lucene/search/grouping/TopGroups;
  withinGroupSort
    +c:

org.apache.lucene.search.grouping.SecondPassGroupingCollector#<init>(Lorg/apache/lucene/search/grouping/GroupSelector;Ljava/util/Collection;Lorg/apache/lucene/search/grouping/GroupReducer;)V
  groups
    +c:"no groups to collect (groups is empty)".

org.apache.lucene.search.grouping.TopGroups#merge([Lorg/apache/lucene/search/grouping/TopGroups;Lorg/apache/lucene/search/Sort;Lorg/apache/lucene/search/Sort;IILorg/apache/lucene/search/grouping/TopGroups$ScoreMergeMode;)Lorg/apache/lucene/search/grouping/TopGroups;
  shardGroups
    +c:
  scoreMergeMode
    +c:can't handle ScoreMergeMode.

org.apache.lucene.search.grouping.FirstPassGroupingCollector#<init>(Lorg/apache/lucene/search/grouping/GroupSelector;Lorg/apache/lucene/search/Sort;I)V
  groupSort
    +d: The Sort used to sort the groups.  The top sorted document within each group according to groupSort, determines how that group sorts against other groups.  This must be non-null, ie, if you want to groupSort by relevance use Sort.RELEVANCE.
  topNGroups
    +c:topNGroups must be >= 1 (got   ).

org.apache.lucene.search.grouping.FirstPassGroupingCollector#getTopGroups(I)Ljava/util/Collection;
  groupOffset
    +c:groupOffset must be >= 0 (got   ).

org.apache.lucene.search.highlight.TokenSources#getTokenStream(Ljava/lang/String;Lorg/apache/lucene/index/Fields;Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;I)Lorg/apache/lucene/analysis/TokenStream;
  tvFields
    +d: from IndexReader#getTermVectors(int) . Possibly null. For performance, this instance should be re-used for the same document (e.g. when highlighting multiple fields).

org.apache.lucene.search.highlight.TokenSources#getTermVectorTokenStreamOrNull(Ljava/lang/String;Lorg/apache/lucene/index/Fields;I)Lorg/apache/lucene/analysis/TokenStream;
  tvFields
    +d: from IndexReader#getTermVectors(int) . Possibly null. For performance, this instance should be re-used for the same document (e.g. when highlighting multiple fields).

org.apache.lucene.search.highlight.TokenSources#getTokenStream(Lorg/apache/lucene/index/Terms;)Lorg/apache/lucene/analysis/TokenStream;
  tpv
    +c:"Highlighting requires offsets from the TokenStream.".

org.apache.lucene.search.highlight.TokenSources#getTokenStream(Lorg/apache/lucene/document/Document;Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;)Lorg/apache/lucene/analysis/TokenStream;
  field
    +c:Field    in document is not stored and cannot be analyzed.

org.apache.lucene.search.highlight.TokenStreamFromTermVector#<init>(Lorg/apache/lucene/index/Terms;I)V
  vector
    +c:"The term vector needs positions and/or offsets."..

org.apache.lucene.search.highlight.GradientFormatter#<init>(FLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
  minForegroundColor
    +c:minForegroundColor is not 7 bytes long eg a hex  RGB value such as #FFFFFF.
  maxForegroundColor
    +c:minForegroundColor is not 7 bytes long eg a hex  RGB value such as #FFFFFF.
  minBackgroundColor
    +c:minBackgroundColor is not 7 bytes long eg a hex  RGB value such as #FFFFFF.
  maxBackgroundColor
    +c:minBackgroundColor is not 7 bytes long eg a hex  RGB value such as #FFFFFF.

org.apache.lucene.search.highlight.GradientFormatter#hexToInt(Ljava/lang/String;)I
  hex
    +c:

org.apache.lucene.search.highlight.QueryTermExtractor#getTerms(Lorg/apache/lucene/search/Query;FLjava/util/HashSet;ZLjava/lang/String;)V
  query
    +c:"Should not happen on an empty index".

org.apache.lucene.search.highlight.Highlighter#getBestTextFragments(Lorg/apache/lucene/analysis/TokenStream;Ljava/lang/String;ZI)[Lorg/apache/lucene/search/highlight/TextFragment;
  text
    +c:Token      exceeds length of provided text sized.

org.apache.lucene.search.highlight.Highlighter#ensureArgumentNotNull(Ljava/lang/Object;Ljava/lang/String;)V
  argument
    +c:.

org.apache.lucene.search.uhighlight.WholeBreakIterator#following(I)I
  pos
    +c:"offset out of bounds".

org.apache.lucene.search.uhighlight.WholeBreakIterator#preceding(I)I
  pos
    +c:"offset out of bounds".

org.apache.lucene.search.uhighlight.Passage#addMatch(IILorg/apache/lucene/util/BytesRef;I)V
  startOffset
    +c:

org.apache.lucene.search.uhighlight.Passage#setEndOffset(I)V
  endOffset
    +c:.

org.apache.lucene.search.uhighlight.OverlaySingleDocTermsLeafReader#<init>(Lorg/apache/lucene/index/LeafReader;Lorg/apache/lucene/index/LeafReader;Ljava/lang/String;I)V
  in2
    +c:.

org.apache.lucene.search.uhighlight.CustomSeparatorBreakIterator#following(I)I
  pos
    +c:"offset out of bounds".

org.apache.lucene.search.uhighlight.CustomSeparatorBreakIterator#preceding(I)I
  pos
    +c:"offset out of bounds".

org.apache.lucene.search.uhighlight.TokenStreamOffsetStrategy#<init>(Lorg/apache/lucene/search/uhighlight/UHComponents;Lorg/apache/lucene/analysis/Analyzer;)V
  components
    +c:.

org.apache.lucene.search.uhighlight.FieldHighlighter#highlightOffsetsEnums(Lorg/apache/lucene/search/uhighlight/OffsetsEnum;)[Lorg/apache/lucene/search/uhighlight/Passage;
  off
    +c:

org.apache.lucene.search.uhighlight.DefaultPassageFormatter#format([Lorg/apache/lucene/search/uhighlight/Passage;Ljava/lang/String;)Ljava/lang/String;
  passages
    +c:

org.apache.lucene.search.uhighlight.UnifiedHighlighter#setMaxLength(I)V
  maxLength
    +c:"maxLength must be < Integer.MAX_VALUE".

org.apache.lucene.search.uhighlight.UnifiedHighlighter#highlightFields([Ljava/lang/String;Lorg/apache/lucene/search/Query;[I[I)Ljava/util/Map;
  fieldsIn
    +c:
  maxPassagesIn
    +c:

org.apache.lucene.search.uhighlight.UnifiedHighlighter#highlightFieldsAsObjects([Ljava/lang/String;Lorg/apache/lucene/search/Query;[I[I)Ljava/util/Map;
  fieldsIn
    +c:"fieldsIn must not be empty".
  docIdsIn
    +c:
  maxPassagesIn
    +c:"invalid number of maxPassagesIn".

org.apache.lucene.search.uhighlight.UnifiedHighlighter#getOffsetStrategy(Lorg/apache/lucene/search/uhighlight/UnifiedHighlighter$OffsetSource;Lorg/apache/lucene/search/uhighlight/UHComponents;)Lorg/apache/lucene/search/uhighlight/FieldOffsetStrategy;
  offsetSource
    +c:Unrecognized offset source.

org.apache.lucene.search.uhighlight.LengthGoalBreakIterator#following(I)I
  followingIdx
    +c:

org.apache.lucene.search.vectorhighlight.FieldQuery#getKey(Lorg/apache/lucene/search/Query;)Ljava/lang/String;
  query
    +c:query \    \ must be flatten first.

org.apache.lucene.search.vectorhighlight.FieldQuery#saveTerms(Ljava/util/Collection;Lorg/apache/lucene/index/IndexReader;)V
  reader
    +c:query \    \ must be flatten first.

org.apache.lucene.search.join.CheckJoinIndex#check(Lorg/apache/lucene/index/IndexReader;Lorg/apache/lucene/search/join/BitSetProducer;)V
  reader
    +c:Every segment should have at least one parent, but     does not have any.The last document of a segment must always be a parent, but     has a child as a last doc.Parent doc      of segment     is live but has a deleted child document.Parent doc      of segment     is deleted but has a live child document.

org.apache.lucene.search.join.BlockJoinSelector#wrap(Lorg/apache/lucene/util/Bits;Lorg/apache/lucene/util/BitSet;Lorg/apache/lucene/util/BitSet;)Lorg/apache/lucene/util/Bits;
  parents
    +c:.

org.apache.lucene.search.join.BlockJoinSelector#wrap(Lorg/apache/lucene/index/SortedSetDocValues;Lorg/apache/lucene/search/join/BlockJoinSelector$Type;Lorg/apache/lucene/util/BitSet;Lorg/apache/lucene/search/DocIdSetIterator;)Lorg/apache/lucene/index/SortedDocValues;
  selection
    +c:.

org.apache.lucene.search.join.BlockJoinSelector#wrap(Lorg/apache/lucene/index/SortedDocValues;Lorg/apache/lucene/search/join/BlockJoinSelector$Type;Lorg/apache/lucene/util/BitSet;Lorg/apache/lucene/search/DocIdSetIterator;)Lorg/apache/lucene/index/SortedDocValues;
  values
    +c:values iterator was already consumed: values.docID=.

org.apache.lucene.search.join.BlockJoinSelector#wrap(Lorg/apache/lucene/index/SortedNumericDocValues;Lorg/apache/lucene/search/join/BlockJoinSelector$Type;Lorg/apache/lucene/util/BitSet;Lorg/apache/lucene/search/DocIdSetIterator;)Lorg/apache/lucene/index/NumericDocValues;
  selection
    +c:.

org.apache.lucene.search.join.BlockJoinSelector#wrap(Lorg/apache/lucene/index/NumericDocValues;Lorg/apache/lucene/search/join/BlockJoinSelector$Type;Lorg/apache/lucene/util/BitSet;Lorg/apache/lucene/search/DocIdSetIterator;)Lorg/apache/lucene/index/NumericDocValues;
  values
    +c:values iterator was already consumed: values.docID=.

org.apache.lucene.search.join.JoinUtil#createJoinQuery(Ljava/lang/String;ZLjava/lang/String;Ljava/lang/Class;Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/join/ScoreMode;)Lorg/apache/lucene/search/Query;
  multipleValuesPerDocument
    +d: Whether the from field has multiple terms per document when true fromField might be DocValuesType#SORTED_NUMERIC , otherwise fromField should be DocValuesType#NUMERIC
  toField
    +d:                   The to field to join to, should be IntPoint , LongPoint , FloatPoint or DoublePoint .
  numericType
    +d:               either java.lang.Integer , java.lang.Long , java.lang.Float or java.lang.Double it should correspond to toField types
  scoreMode
    +c:.

org.apache.lucene.search.join.JoinUtil#createJoinQuery(ZLjava/lang/String;Lorg/apache/lucene/search/Query;Ljava/lang/String;Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/join/ScoreMode;Lorg/apache/lucene/search/join/GenericTermsCollector;)Lorg/apache/lucene/search/Query;
  scoreMode
    +c:Score mode %s isn't supported.

org.apache.lucene.search.join.JoinUtil#createJoinQuery(Ljava/lang/String;Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/join/ScoreMode;Lorg/apache/lucene/index/OrdinalMap;)Lorg/apache/lucene/search/Query;
  fromQuery
    +d:   The query containing the actual user query. Also the fromQuery can only match "from" documents.

org.apache.lucene.search.join.JoinUtil#createJoinQuery(Ljava/lang/String;Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/join/ScoreMode;Lorg/apache/lucene/index/OrdinalMap;II)Lorg/apache/lucene/search/Query;
  fromQuery
    +d:   The query containing the actual user query. Also the fromQuery can only match "from" documents.
  scoreMode
    +c:Score mode %s isn't supported.
  ordinalMap
    +c:"OrdinalMap is required, because there is more than 1 segment".

org.apache.lucene.search.join.ToParentBlockJoinSortField#<init>(Ljava/lang/String;Lorg/apache/lucene/search/SortField$Type;ZLorg/apache/lucene/search/join/BitSetProducer;Lorg/apache/lucene/search/join/BitSetProducer;)V
  type
    +c:Sort type    is not supported.
  reverse
    +d: Whether natural order should be reversed on the nested / child level.

org.apache.lucene.search.join.ToParentBlockJoinSortField#<init>(Ljava/lang/String;Lorg/apache/lucene/search/SortField$Type;ZZLorg/apache/lucene/search/join/BitSetProducer;Lorg/apache/lucene/search/join/BitSetProducer;)V
  order
    +d: Whether natural order should be reversed on the parent level.

org.apache.lucene.index.memory.MemoryIndex#<init>(ZZJ)V
  maxReusedBytes
    +c:.

org.apache.lucene.index.memory.MemoryIndex#addField(Ljava/lang/String;Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;)V
  fieldName
    +c:"fieldName must not be null".
  text
    +c:"text must not be null".
  analyzer
    +c:"analyzer must not be null".

org.apache.lucene.index.memory.MemoryIndex#keywordTokenStream(Ljava/util/Collection;)Lorg/apache/lucene/analysis/TokenStream;
  keywords
    +c:"keywords must not be null".

org.apache.lucene.index.memory.MemoryIndex#addField(Ljava/lang/String;Lorg/apache/lucene/analysis/TokenStream;)V
  fieldName
    +c:

org.apache.lucene.index.memory.MemoryIndex#addField(Ljava/lang/String;Lorg/apache/lucene/analysis/TokenStream;I)V
  fieldName
    +c:

org.apache.lucene.index.memory.MemoryIndex#addField(Ljava/lang/String;Lorg/apache/lucene/analysis/TokenStream;II)V
  fieldName
    +c:
  tokenStream
    +c:
  offsetGap
    +c:

org.apache.lucene.index.memory.MemoryIndex#search(Lorg/apache/lucene/search/Query;)F
  query
    +c:"query must not be null".

org.apache.lucene.document.InetAddressPoint#nextUp(Ljava/net/InetAddress;)Ljava/net/InetAddress;
  address
    +c:Overflow: there is no greater InetAddress than.

org.apache.lucene.document.InetAddressPoint#nextDown(Ljava/net/InetAddress;)Ljava/net/InetAddress;
  address
    +c:Underflow: there is no smaller InetAddress than.

org.apache.lucene.document.InetAddressPoint#setInetAddressValue(Ljava/net/InetAddress;)V
  value
    +c:"point must not be null".

org.apache.lucene.document.InetAddressPoint#newPrefixQuery(Ljava/lang/String;Ljava/net/InetAddress;I)Lorg/apache/lucene/search/Query;
  value
    +c:"InetAddress must not be null".
  prefixLength
    +c:illegal prefixLength '  '. Must be 0-32 for IPv4 ranges, 0-128 for IPv6 ranges.

org.apache.lucene.document.LazyDocument#fetchRealValues(Ljava/lang/String;I)V
  name
    +c:.

org.apache.lucene.index.MultiPassIndexSplitter#split(Lorg/apache/lucene/index/IndexReader;[Lorg/apache/lucene/store/Directory;Z)V
  in
    +d: source index, can have deletions, can have multiple segments (or multiple readers).
    +c:"Not enough documents for splitting".
  outputs
    +c:"Invalid number of outputs.".

org.apache.lucene.index.MultiPassIndexSplitter#main([Ljava/lang/String;)V
  args
    +c:

org.apache.lucene.misc.HighFreqTerms#getHighFreqTerms(Lorg/apache/lucene/index/IndexReader;ILjava/lang/String;Ljava/util/Comparator;)[Lorg/apache/lucene/misc/TermStats;
  field
    +c:field    not found.

org.apache.lucene.store.NativeUnixDirectory#<init>(Ljava/nio/file/Path;IJLorg/apache/lucene/store/LockFactory;Lorg/apache/lucene/store/Directory;)V
  mergeBufferSize
    +c:mergeBufferSize must be 0 mod    (got:   ).

org.apache.lucene.util.fst.ListOfOutputs#add(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
  prefix
    +c:.

org.apache.lucene.util.fst.ListOfOutputs#write(Ljava/lang/Object;Lorg/apache/lucene/store/DataOutput;)V
  output
    +c:.

org.apache.lucene.util.fst.UpToTwoPositiveIntOutputs#common(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Long;
  _output1
    +c:.
  _output2
    +c:.

org.apache.lucene.util.fst.UpToTwoPositiveIntOutputs#subtract(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Long;
  _output
    +c:.
  _inc
    +c:.

org.apache.lucene.util.fst.UpToTwoPositiveIntOutputs#add(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
  _prefix
    +c:.
  _output
    +c:.

org.apache.lucene.util.fst.UpToTwoPositiveIntOutputs#write(Ljava/lang/Object;Lorg/apache/lucene/store/DataOutput;)V
  _output
    +c:.

org.apache.lucene.util.fst.UpToTwoPositiveIntOutputs#merge(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
  first
    +c:.
  second
    +c:.

org.apache.lucene.util.fst.UpToTwoPositiveIntOutputs#ramBytesUsed(Ljava/lang/Object;)J
  o
    +c:.

org.apache.lucene.queries.CommonTermsQuery#<init>(Lorg/apache/lucene/search/BooleanClause$Occur;Lorg/apache/lucene/search/BooleanClause$Occur;F)V
  highFreqOccur
    +c:"highFreqOccur should be MUST or SHOULD but was MUST_NOT".
  lowFreqOccur
    +c:"lowFreqOccur should be MUST or SHOULD but was MUST_NOT".

org.apache.lucene.queries.CommonTermsQuery#add(Lorg/apache/lucene/index/Term;)V
  term
    +c:"Term must not be null".

org.apache.lucene.queryparser.classic.MultiFieldQueryParser#parse([Ljava/lang/String;[Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;)Lorg/apache/lucene/search/Query;
  queries
    +c:"queries.length != fields.length".

org.apache.lucene.queryparser.classic.MultiFieldQueryParser#parse(Ljava/lang/String;[Ljava/lang/String;[Lorg/apache/lucene/search/BooleanClause$Occur;Lorg/apache/lucene/analysis/Analyzer;)Lorg/apache/lucene/search/Query;
  fields
    +c:"fields.length != flags.length".

org.apache.lucene.queryparser.classic.MultiFieldQueryParser#parse([Ljava/lang/String;[Ljava/lang/String;[Lorg/apache/lucene/search/BooleanClause$Occur;Lorg/apache/lucene/analysis/Analyzer;)Lorg/apache/lucene/search/Query;
  queries
    +c:"queries, fields, and flags array have have different length".

org.apache.lucene.queryparser.classic.QueryParser#setAutoGeneratePhraseQueries(Z)V
  value
    +c:"setAutoGeneratePhraseQueries(true) is disallowed when getSplitOnWhitespace() == false".

org.apache.lucene.queryparser.classic.QueryParser#setSplitOnWhitespace(Z)V
  splitOnWhitespace
    +c:"setSplitOnWhitespace(false) is disallowed when getAutoGeneratePhraseQueries() == true".

org.apache.lucene.queryparser.classic.QueryParserTokenManager#SwitchTo(I)V
  lexState
    +c:Error: Ignoring invalid lexical state :   . State unchanged.

org.apache.lucene.queryparser.complexPhrase.ComplexPhraseQueryParser#getWildcardQuery(Ljava/lang/String;Ljava/lang/String;)Lorg/apache/lucene/search/Query;
  field
    +c:

org.apache.lucene.queryparser.complexPhrase.ComplexPhraseQueryParser#getRangeQuery(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;ZZ)Lorg/apache/lucene/search/Query;
  field
    +c:

org.apache.lucene.queryparser.complexPhrase.ComplexPhraseQueryParser#getFuzzyQuery(Ljava/lang/String;Ljava/lang/String;F)Lorg/apache/lucene/search/Query;
  field
    +c:

org.apache.lucene.queryparser.flexible.core.QueryParserHelper#setQueryNodeProcessor(Lorg/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessor;)V
  processor
    +d: the processor that will be used to process the query node tree, this argument can be null

org.apache.lucene.queryparser.flexible.core.QueryParserHelper#setSyntaxParser(Lorg/apache/lucene/queryparser/flexible/core/parser/SyntaxParser;)V
  syntaxParser
    +c:"textParser should not be null!".

org.apache.lucene.queryparser.flexible.core.QueryParserHelper#setQueryBuilder(Lorg/apache/lucene/queryparser/flexible/core/builders/QueryBuilder;)V
  queryBuilder
    +c:"queryBuilder should not be null!".

org.apache.lucene.queryparser.flexible.core.QueryParserHelper#setQueryConfigHandler(Lorg/apache/lucene/queryparser/flexible/core/config/QueryConfigHandler;)V
  config
    +d: the query configuration handler used during query processing, it can be null

org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder#processNode(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;Lorg/apache/lucene/queryparser/flexible/core/builders/QueryBuilder;)V
  builder
    +c:.

org.apache.lucene.queryparser.flexible.core.config.FieldConfig#<init>(Ljava/lang/String;)V
  fieldName
    +d: the field name, it must not be null
    +c:"field name must not be null!".

org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode#<init>(Ljava/util/List;)V
  clauses
    +c:"OR query must have at least one clause".

org.apache.lucene.queryparser.flexible.core.nodes.PathQueryNode#<init>(Ljava/util/List;)V
  pathElements
    +c:"PathQuerynode requires more 2 or more path elements.".

org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode#<init>(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;I)V
  query
    +c:query null.

org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode#<init>(Ljava/util/List;)V
  clauses
    +c:"AND query must have at least one clause".

org.apache.lucene.queryparser.flexible.core.nodes.PhraseSlopQueryNode#<init>(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;I)V
  query
    +c:query null.

org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode#<init>(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;F)V
  query
    +c:query null.

org.apache.lucene.queryparser.flexible.core.nodes.ProximityQueryNode#<init>(Ljava/util/List;Ljava/lang/CharSequence;Lorg/apache/lucene/queryparser/flexible/core/nodes/ProximityQueryNode$Type;IZ)V
  distance
    +c:distance.

org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode#<init>(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;)V
  query
    +c:query null.

org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode#<init>(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;Lorg/apache/lucene/queryparser/flexible/core/nodes/ModifierQueryNode$Modifier;)V
  query
    +c:query null.

org.apache.lucene.queryparser.flexible.standard.QueryParserUtil#parse([Ljava/lang/String;[Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;)Lorg/apache/lucene/search/Query;
  queries
    +c:"queries.length != fields.length".

org.apache.lucene.queryparser.flexible.standard.QueryParserUtil#parse(Ljava/lang/String;[Ljava/lang/String;[Lorg/apache/lucene/search/BooleanClause$Occur;Lorg/apache/lucene/analysis/Analyzer;)Lorg/apache/lucene/search/Query;
  fields
    +c:"fields.length != flags.length".

org.apache.lucene.queryparser.flexible.standard.QueryParserUtil#parse([Ljava/lang/String;[Ljava/lang/String;[Lorg/apache/lucene/search/BooleanClause$Occur;Lorg/apache/lucene/analysis/Analyzer;)Lorg/apache/lucene/search/Query;
  queries
    +c:"queries, fields, and flags array have have different length".

org.apache.lucene.queryparser.flexible.standard.builders.MatchNoDocsQueryNodeBuilder#build(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;)Lorg/apache/lucene/search/MatchNoDocsQuery;
  queryNode
    +c:.

org.apache.lucene.queryparser.flexible.standard.builders.MatchAllDocsQueryNodeBuilder#build(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;)Lorg/apache/lucene/search/MatchAllDocsQuery;
  queryNode
    +c:.

org.apache.lucene.queryparser.flexible.standard.builders.BooleanQueryNodeBuilder#build(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;)Lorg/apache/lucene/search/BooleanQuery;
  queryNode
    +c:.

org.apache.lucene.queryparser.flexible.standard.config.PointsConfigListener#<init>(Lorg/apache/lucene/queryparser/flexible/core/config/QueryConfigHandler;)V
  config
    +c:"config must not be null!".

org.apache.lucene.queryparser.flexible.standard.config.PointsConfig#setType(Ljava/lang/Class;)V
  type
    +c:"type must not be null!".unsupported numeric type:.

org.apache.lucene.queryparser.flexible.standard.config.PointsConfig#setNumberFormat(Ljava/text/NumberFormat;)V
  format
    +d: the NumberFormat used to parse a String to Number , must not be null
    +c:"format must not be null!".

org.apache.lucene.queryparser.flexible.standard.nodes.PointRangeQueryNode#setBounds(Lorg/apache/lucene/queryparser/flexible/standard/nodes/PointQueryNode;Lorg/apache/lucene/queryparser/flexible/standard/nodes/PointQueryNode;ZZLorg/apache/lucene/queryparser/flexible/standard/config/PointsConfig;)V
  pointsConfig
    +c:"pointsConfig must not be null!".lower value's type should be the same as numericConfig type:      !=.upper value's type should be the same as numericConfig type:      !=.

org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParserTokenManager#SwitchTo(I)V
  lexState
    +c:Error: Ignoring invalid lexical state :   . State unchanged.

org.apache.lucene.queryparser.flexible.standard.processors.FuzzyQueryNodeProcessor#preProcessNode(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;)Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;
  node
    +c:

org.apache.lucene.queryparser.flexible.standard.processors.AnalyzerQueryNodeProcessor#postProcessNode(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;)Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;
  node
    +c:.

org.apache.lucene.queryparser.flexible.standard.processors.AllowLeadingWildcardProcessor#postProcessNode(Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;)Lorg/apache/lucene/queryparser/flexible/core/nodes/QueryNode;
  node
    +c:.

org.apache.lucene.queryparser.simple.SimpleQueryParser#setDefaultOperator(Lorg/apache/lucene/search/BooleanClause$Occur;)V
  operator
    +c:"invalid operator: only SHOULD or MUST are allowed".

org.apache.lucene.queryparser.surround.parser.QueryParser#checkDistanceSubQueries(Lorg/apache/lucene/queryparser/surround/query/DistanceQuery;Ljava/lang/String;)V
  opName
    +c:Operator   :.

org.apache.lucene.queryparser.surround.parser.QueryParserTokenManager#SwitchTo(I)V
  lexState
    +c:Error: Ignoring invalid lexical state :   . State unchanged.

org.apache.lucene.queryparser.surround.query.SpanNearClauseFactory#addSpanQuery(Lorg/apache/lucene/search/Query;)V
  q
    +c:Expected SpanQuery:.

org.apache.lucene.queryparser.xml.DOMUtils#getChildByTagOrFail(Lorg/w3c/dom/Element;Ljava/lang/String;)Lorg/w3c/dom/Element;
  name
    +c:missing \  \ child element.

org.apache.lucene.queryparser.xml.DOMUtils#getFirstChildOrFail(Lorg/w3c/dom/Element;)Lorg/w3c/dom/Element;
  e
    +c:does not contain a child element.

org.apache.lucene.queryparser.xml.DOMUtils#getAttributeOrFail(Lorg/w3c/dom/Element;Ljava/lang/String;)Ljava/lang/String;
  e
    +c:missing \  \ attribute.

org.apache.lucene.queryparser.xml.DOMUtils#getAttributeWithInheritanceOrFail(Lorg/w3c/dom/Element;Ljava/lang/String;)Ljava/lang/String;
  e
    +c:missing \  \ attribute.

org.apache.lucene.queryparser.xml.DOMUtils#getNonBlankTextOrFail(Lorg/w3c/dom/Element;)Ljava/lang/String;
  e
    +c:has no text.

org.apache.lucene.queryparser.xml.QueryBuilderFactory#getQuery(Lorg/w3c/dom/Element;)Lorg/apache/lucene/search/Query;
  n
    +c:No QueryObjectBuilder defined for node.

org.apache.lucene.queryparser.xml.builders.SpanQueryBuilderFactory#getSpanQuery(Lorg/w3c/dom/Element;)Lorg/apache/lucene/search/spans/SpanQuery;
  e
    +c:No SpanQueryObjectBuilder defined for node.

org.apache.lucene.replicator.PerSessionDirectoryFactory#cleanupSession(Ljava/lang/String;)V
  sessionID
    +c:"sessionID cannot be empty".

org.apache.lucene.replicator.IndexAndTaxonomyRevision#open(Ljava/lang/String;Ljava/lang/String;)Ljava/io/InputStream;
  source
    +c:.

org.apache.lucene.replicator.RevisionFile#<init>(Ljava/lang/String;)V
  fileName
    +c:"fileName must not be null or empty".

org.apache.lucene.replicator.IndexRevision#open(Ljava/lang/String;Ljava/lang/String;)Ljava/io/InputStream;
  source
    +c:.

org.apache.lucene.replicator.LocalReplicator#obtainFile(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/io/InputStream;
  source
    +c:session (  ) expired while obtaining file: source=   file=.

org.apache.lucene.replicator.LocalReplicator#publish(Lorg/apache/lucene/replicator/Revision;)V
  revision
    +c:Cannot publish an older revision: rev=   current=.

org.apache.lucene.replicator.IndexReplicationHandler#getSegmentsFile(Ljava/util/List;Z)Ljava/lang/String;
  allowEmpty
    +c:"empty list of files not allowed".

org.apache.lucene.replicator.IndexReplicationHandler#revisionReady(Ljava/lang/String;Ljava/util/Map;Ljava/util/Map;Ljava/util/Map;)V
  revisionFiles
    +c:this handler handles only a single source; got.

org.apache.lucene.replicator.ReplicationClient#requiredFiles(Ljava/util/Map;)Ljava/util/Map;
  newRevisionFiles
    +c:.

org.apache.lucene.replicator.ReplicationClient#startUpdateThread(JLjava/lang/String;)V
  threadName
    +c:

org.apache.lucene.replicator.nrt.CopyState#<init>(Ljava/util/Map;JJ[BLjava/util/Set;JLorg/apache/lucene/index/SegmentInfos;)V
  completedMergeFiles
    +c:.

org.apache.lucene.replicator.nrt.NodeCommunicationException#<init>(Ljava/lang/String;Ljava/lang/Throwable;)V
  cause
    +c:.

org.apache.lucene.codecs.idversion.VersionBlockTreeTermsReader#<init>(Lorg/apache/lucene/codecs/PostingsReaderBase;Lorg/apache/lucene/index/SegmentReadState;)V
  state
    +c:invalid docCount:     maxDoc:.

org.apache.lucene.codecs.idversion.VersionBlockTreeTermsReader#terms(Ljava/lang/String;)Lorg/apache/lucene/index/Terms;
  field
    +c:.

org.apache.lucene.codecs.idversion.VersionBlockTreeTermsWriter#write(Lorg/apache/lucene/index/Fields;Lorg/apache/lucene/codecs/NormsProducer;)V
  fields
    +c:

org.apache.lucene.codecs.idversion.VersionBlockTreeTermsWriter#encodeOutput(JZZ)J
  fp
    +c:.

org.apache.lucene.codecs.idversion.IDVersionPostingsFormat#longToBytes(JLorg/apache/lucene/util/BytesRef;)V
  v
    +c:version must be >= MIN_VERSION=   and <= MAX_VERSION=   (got:   ).

org.apache.lucene.codecs.idversion.IDVersionSegmentTermsEnum#pushFrame(Lorg/apache/lucene/util/fst/FST$Arc;Lorg/apache/lucene/util/fst/PairOutputs$Pair;I)Lorg/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame;
  length
    +c:

org.apache.lucene.codecs.idversion.IDVersionSegmentTermsEnum#pushFrame(Lorg/apache/lucene/util/fst/FST$Arc;JI)Lorg/apache/lucene/codecs/idversion/IDVersionSegmentTermsEnumFrame;
  length
    +c:.

org.apache.lucene.codecs.idversion.IDVersionSegmentTermsEnum#seekExact(Lorg/apache/lucene/util/BytesRef;)Z
  target
    +c:

org.apache.lucene.codecs.idversion.IDVersionSegmentTermsEnum#seekExact(Lorg/apache/lucene/util/BytesRef;J)Z
  target
    +c:..

org.apache.lucene.codecs.idversion.IDVersionSegmentTermsEnum#seekCeil(Lorg/apache/lucene/util/BytesRef;)Lorg/apache/lucene/index/TermsEnum$SeekStatus;
  target
    +c:..

org.apache.lucene.codecs.idversion.IDVersionSegmentTermsEnum#seekExact(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/index/TermState;)V
  target
    +c:
  otherState
    +c:.

org.apache.lucene.document.LatLonBoundingBox#checkArgs(DDDD)V
  minLat
    +c:cannot have minLat [  ] exceed maxLat [  ].
  minLon
    +c:cannot have minLon [  ] exceed maxLon [  ].

org.apache.lucene.document.LatLonBoundingBox#toString([BI)Ljava/lang/String;
  dimension
    +c:invalid dimension [  ] in toString.

org.apache.lucene.document.FloatPointNearestNeighbor#nearest(Lorg/apache/lucene/search/IndexSearcher;Ljava/lang/String;I[F)Lorg/apache/lucene/search/TopFieldDocs;
  searcher
    +c:"searcher must not be null".
  field
    +c:"field must not be null".
  topN
    +c:topN must be at least 1; got.

org.apache.lucene.document.BigIntegerPoint#setBigIntegerValues([Ljava/math/BigInteger;)V
  point
    +c:this field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.BigIntegerPoint#<init>(Ljava/lang/String;[Ljava/math/BigInteger;)V
  point
    +c:

org.apache.lucene.document.HalfFloatPoint#roundShift(II)I
  shift
    +c:.

org.apache.lucene.document.HalfFloatPoint#setFloatValues([F)V
  point
    +c:this field (name=  ) uses     dimensions; cannot change to (incoming)     dimensions.

org.apache.lucene.document.HalfFloatPoint#<init>(Ljava/lang/String;[F)V
  point
    +c:

org.apache.lucene.geo.Line#<init>([D[D)V
  lats
    +c:"lats must not be null"."lats and lons must be equal length"."at least 2 line points required".
  lons
    +c:"lons must not be null".

org.apache.lucene.geo.Tessellator#tessellate(Lorg/apache/lucene/geo/Polygon;)Ljava/util/List;
  polygon
    +c:Unable to Tessellate shape [  ]. Possible malformed shape detected.

org.apache.lucene.sandbox.queries.FuzzyLikeThisQuery#addTerms(Ljava/lang/String;Ljava/lang/String;FI)V
  minSimilarity
    +d: The minimum similarity of the term variants; must be 0, 1 or 2 (see FuzzyTermsEnum)
    +c:minSimilarity must integer value between 0 and    , inclusive; got.

org.apache.lucene.search.TermAutomatonQuery#addTransition(IILjava/lang/String;)V
  term
    +c:

org.apache.lucene.search.TermAutomatonQuery#addTransition(IILorg/apache/lucene/util/BytesRef;)V
  term
    +c:"term should not be null".

org.apache.lucene.search.LatLonPointPrototypeQueries#nearest(Lorg/apache/lucene/search/IndexSearcher;Ljava/lang/String;DDI)Lorg/apache/lucene/search/TopFieldDocs;
  searcher
    +c:"searcher must not be null".
  field
    +c:"field must not be null".
  latitude
    +d: latitude at the center: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude at the center: must be within standard +/-180 coordinate bounds.
  n
    +c:n must be at least 1; got.

org.apache.lucene.search.CoveringQuery#<init>(Ljava/util/Collection;Lorg/apache/lucene/search/LongValuesSource;)V
  queries
    +c:.
  minimumNumberMatch
    +c:"The minimum number of matches may not depend on the score.".

org.apache.lucene.spatial.bbox.BBoxOverlapRatioValueSource#<init>(Lorg/apache/lucene/spatial/ShapeValuesSource;ZLorg/locationtech/spatial4j/shape/Rectangle;DD)V
  queryTargetProportion
    +c:"queryTargetProportion must be >= 0 and <= 1".

org.apache.lucene.spatial.bbox.BBoxStrategy#makeQuery(Lorg/apache/lucene/spatial/query/SpatialArgs;)Lorg/apache/lucene/search/Query;
  args
    +c:

org.apache.lucene.spatial.prefix.WithinPrefixTreeQuery#bufferShape(Lorg/locationtech/spatial4j/shape/Shape;D)Lorg/locationtech/spatial4j/shape/Shape;
  distErr
    +c:"distErr must be > 0".

org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy#makeGridShapeIntersectsQuery(Lorg/locationtech/spatial4j/shape/Shape;)Lorg/apache/lucene/search/Query;
  gridShape
    +c:.

org.apache.lucene.spatial.prefix.HeatmapFacetCounter#calcFacets(Lorg/apache/lucene/spatial/prefix/PrefixTreeStrategy;Lorg/apache/lucene/index/IndexReaderContext;Lorg/apache/lucene/util/Bits;Lorg/locationtech/spatial4j/shape/Shape;II)Lorg/apache/lucene/spatial/prefix/HeatmapFacetCounter$Heatmap;
  facetLevel
    +c:.
  maxCells
    +c:maxCells (  ) should be <=.Too many cells (    x    ) for level    shape.

org.apache.lucene.spatial.prefix.PrefixTreeFacetCounter#compute(Lorg/apache/lucene/spatial/prefix/PrefixTreeStrategy;Lorg/apache/lucene/index/LeafReaderContext;Lorg/apache/lucene/util/Bits;Lorg/locationtech/spatial4j/shape/Shape;ILorg/apache/lucene/spatial/prefix/PrefixTreeFacetCounter$FacetVisitor;)V
  acceptDocs
    +c:acceptDocs bits length     != leaf maxdoc.

org.apache.lucene.spatial.prefix.tree.PackedQuadPrefixTree#<init>(Lorg/locationtech/spatial4j/context/SpatialContext;I)V
  maxLevels
    +c:maxLevels of    exceeds limit of.

org.apache.lucene.spatial.prefix.tree.PackedQuadPrefixTree#getTreeCellIterator(Lorg/locationtech/spatial4j/shape/Shape;I)Lorg/apache/lucene/spatial/prefix/tree/CellIterator;
  detailLevel
    +c:detailLevel:   exceed max:.

org.apache.lucene.spatial.prefix.tree.QuadPrefixTree#getCell(Lorg/locationtech/spatial4j/shape/Point;I)Lorg/apache/lucene/spatial/prefix/tree/Cell;
  level
    +c:

org.apache.lucene.spatial.prefix.tree.QuadPrefixTree#checkBattenberg(CDDILjava/util/List;Lorg/apache/lucene/util/BytesRef;Lorg/locationtech/spatial4j/shape/Shape;I)V
  level
    +c:
  str
    +c:.

org.apache.lucene.spatial.prefix.tree.S2PrefixTree#<init>(Lorg/locationtech/spatial4j/context/SpatialContext;II)V
  ctx
    +c:"Spatial context does not support S2 spatial index.".
  arity
    +c:Invalid value for S2 tree arity. Possible values are 1, 2 or 3. Provided value is   .

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#getNumSubCells(Lorg/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree$UnitNRShape;)I
  lv
    +c:.

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#getTreeLevelForCalendarField(I)I
  calField
    +c:Bad calendar field?:.

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#clearFieldsAfter(Ljava/util/Calendar;I)V
  cal
    +c:.

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#toUnitShape(Ljava/lang/Object;)Lorg/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree$UnitNRShape;
  value
    +c:Expecting Calendar or Date but got:.

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#toShape(Ljava/util/Calendar;)Lorg/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree$UnitNRShape;
  cal
    +c:

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#toCalendar(Lorg/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree$UnitNRShape;)Ljava/util/Calendar;
  lv
    +c:.

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#toString(Lorg/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree$UnitNRShape;)Ljava/lang/String;
  lv
    +c:

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#toString(Ljava/util/Calendar;)Ljava/lang/String;
  cal
    +c:

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#parseUnitShape(Ljava/lang/String;)Lorg/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree$UnitNRShape;
  str
    +c:

org.apache.lucene.spatial.prefix.tree.DateRangePrefixTree#parseCalendar(Ljava/lang/String;)Ljava/util/Calendar;
  str
    +c:"str is null or blank".Improperly formatted date:.

org.apache.lucene.spatial.prefix.tree.GeohashPrefixTree#<init>(Lorg/locationtech/spatial4j/context/SpatialContext;I)V
  maxLevels
    +c:maxLevels must be [1-   ] but got.

org.apache.lucene.spatial.query.SpatialArgs#<init>(Lorg/apache/lucene/spatial/query/SpatialOperation;Lorg/locationtech/spatial4j/shape/Shape;)V
  operation
    +c:"operation and shape are required".

org.apache.lucene.spatial.query.SpatialArgs#calcDistanceFromErrPct(Lorg/locationtech/spatial4j/shape/Shape;DLorg/locationtech/spatial4j/context/SpatialContext;)D
  distErrPct
    +c:distErrPct    must be between [0 to 0.5].

org.apache.lucene.spatial.query.SpatialArgsParser#parse(Ljava/lang/String;Lorg/locationtech/spatial4j/context/SpatialContext;)Lorg/apache/lucene/spatial/query/SpatialArgs;
  v
    +c:missing parens:.missing body :.

org.apache.lucene.spatial.spatial4j.Geo3dShape#relate(Lorg/locationtech/spatial4j/shape/Shape;)Lorg/locationtech/spatial4j/shape/SpatialRelation;
  other
    +c:Unimplemented shape relationship determination:.

org.apache.lucene.spatial.spatial4j.Geo3dBinaryCodec#writeShape(Ljava/io/DataOutput;Lorg/locationtech/spatial4j/shape/Shape;)V
  s
    +c:trying to write a not supported shape:.

org.apache.lucene.spatial.spatial4j.Geo3dShapeFactory#verifyX(D)V
  x
    +c:Bad X value    is not in boundary.

org.apache.lucene.spatial.spatial4j.Geo3dShapeFactory#verifyY(D)V
  y
    +c:Bad Y value    is not in boundary.

org.apache.lucene.spatial.vector.PointVectorStrategy#createIndexableFields(Lorg/locationtech/spatial4j/shape/Shape;)[Lorg/apache/lucene/document/Field;
  shape
    +c:Can only index Point, not.

org.apache.lucene.spatial.vector.PointVectorStrategy#makeQuery(Lorg/apache/lucene/spatial/query/SpatialArgs;)Lorg/apache/lucene/search/Query;
  args
    +c:.

org.apache.lucene.spatial.util.MortonEncoder#encode(DD)J
  latitude
    +d: latitude value: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude value: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial.util.MortonEncoder#encodeCeil(DD)J
  latitude
    +d: latitude value: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude value: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial3d.Geo3DPoint#newDistanceQuery(Ljava/lang/String;DDD)Lorg/apache/lucene/search/Query;
  latitude
    +d: latitude at the center: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude at the center: must be within standard +/-180 coordinate bounds.
  radiusMeters
    +d: maximum distance from the center in meters: must be non-negative and finite.

org.apache.lucene.spatial3d.Geo3DPoint#newBoxQuery(Ljava/lang/String;DDDD)Lorg/apache/lucene/search/Query;
  minLatitude
    +d: latitude lower bound: must be within standard +/-90 coordinate bounds.
  maxLatitude
    +d: latitude upper bound: must be within standard +/-90 coordinate bounds.
  minLongitude
    +d: longitude lower bound: must be within standard +/-180 coordinate bounds.
  maxLongitude
    +d: longitude upper bound: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial3d.Geo3DPoint#newPolygonQuery(Ljava/lang/String;[Lorg/apache/lucene/geo/Polygon;)Lorg/apache/lucene/search/Query;
  polygons
    +d: is the list of polygons to use to construct the query; must be at least one.

org.apache.lucene.spatial3d.Geo3DPoint#newLargePolygonQuery(Ljava/lang/String;[Lorg/apache/lucene/geo/Polygon;)Lorg/apache/lucene/search/Query;
  polygons
    +d: is the list of polygons to use to construct the query; must be at least one.

org.apache.lucene.spatial3d.Geo3DPoint#newPathQuery(Ljava/lang/String;[D[DD)Lorg/apache/lucene/search/Query;
  pathLatitudes
    +d: latitude values for points of the path: must be within standard +/-90 coordinate bounds.
  pathLongitudes
    +d: longitude values for points of the path: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial3d.Geo3DDocValuesField#encodeX(D)I
  x
    +c:"x value exceeds WGS84 maximum"."x value less than WGS84 minimum".

org.apache.lucene.spatial3d.Geo3DDocValuesField#encodeY(D)I
  y
    +c:"y value exceeds WGS84 maximum"."y value less than WGS84 minimum".

org.apache.lucene.spatial3d.Geo3DDocValuesField#encodeZ(D)I
  z
    +c:"z value exceeds WGS84 maximum"."z value less than WGS84 minimum".

org.apache.lucene.spatial3d.Geo3DDocValuesField#checkCompatible(Lorg/apache/lucene/index/FieldInfo;)V
  fieldInfo
    +c:field=\   \ was indexed with docValuesType=    but this type has docValuesType=   , is the field really a Geo3DDocValuesField?.

org.apache.lucene.spatial3d.Geo3DDocValuesField#newDistanceSort(Ljava/lang/String;DDD)Lorg/apache/lucene/search/SortField;
  latitude
    +d: latitude at the center: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude at the center: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial3d.Geo3DDocValuesField#newPathSort(Ljava/lang/String;[D[DD)Lorg/apache/lucene/search/SortField;
  pathLatitudes
    +d: latitude values for points of the path: must be within standard +/-90 coordinate bounds.
  pathLongitudes
    +d: longitude values for points of the path: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial3d.Geo3DDocValuesField#newOutsideDistanceSort(Ljava/lang/String;DDD)Lorg/apache/lucene/search/SortField;
  latitude
    +d: latitude at the center: must be within standard +/-90 coordinate bounds.
  longitude
    +d: longitude at the center: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial3d.Geo3DDocValuesField#newOutsideBoxSort(Ljava/lang/String;DDDD)Lorg/apache/lucene/search/SortField;
  minLatitude
    +d: latitude lower bound: must be within standard +/-90 coordinate bounds.
  maxLatitude
    +d: latitude upper bound: must be within standard +/-90 coordinate bounds.
  minLongitude
    +d: longitude lower bound: must be within standard +/-180 coordinate bounds.
  maxLongitude
    +d: longitude upper bound: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial3d.Geo3DDocValuesField#newOutsidePolygonSort(Ljava/lang/String;[Lorg/apache/lucene/geo/Polygon;)Lorg/apache/lucene/search/SortField;
  polygons
    +d: is the list of polygons to use to construct the query; must be at least one.

org.apache.lucene.spatial3d.Geo3DDocValuesField#newOutsideLargePolygonSort(Ljava/lang/String;[Lorg/apache/lucene/geo/Polygon;)Lorg/apache/lucene/search/SortField;
  polygons
    +d: is the list of polygons to use to construct the query; must be at least one.

org.apache.lucene.spatial3d.Geo3DDocValuesField#newOutsidePathSort(Ljava/lang/String;[D[DD)Lorg/apache/lucene/search/SortField;
  pathLatitudes
    +d: latitude values for points of the path: must be within standard +/-90 coordinate bounds.
  pathLongitudes
    +d: longitude values for points of the path: must be within standard +/-180 coordinate bounds.

org.apache.lucene.spatial3d.geom.GeoPolygonFactory#makeGeoPolygon(Lorg/apache/lucene/spatial3d/geom/PlanetModel;Lorg/apache/lucene/spatial3d/geom/GeoPolygonFactory$PolygonDescription;)Lorg/apache/lucene/spatial3d/geom/GeoPolygon;
  planetModel
    +c:
  description
    +d: describes the polygon and its associated holes.  If points go clockwise from a given pole, then that pole should be within the polygon.  If points go counter-clockwise, then that pole should be outside the polygon.
    +c:

org.apache.lucene.spatial3d.geom.GeoPolygonFactory#makeGeoPolygon(Lorg/apache/lucene/spatial3d/geom/PlanetModel;Lorg/apache/lucene/spatial3d/geom/GeoPolygonFactory$PolygonDescription;D)Lorg/apache/lucene/spatial3d/geom/GeoPolygon;
  planetModel
    +c:
  description
    +d: describes the polygon and its associated holes.  If points go clockwise from a given pole, then that pole should be within the polygon.  If points go counter-clockwise, then that pole should be outside the polygon.
    +c:cannot find a point that is inside the polygon.

org.apache.lucene.spatial3d.geom.GeoPolygonFactory#makeGeoPolygon(Lorg/apache/lucene/spatial3d/geom/PlanetModel;Ljava/util/List;)Lorg/apache/lucene/spatial3d/geom/GeoPolygon;
  planetModel
    +c:
  pointList
    +d: is a list of the GeoPoints to build an arbitrary polygon out of.  If points go clockwise from a given pole, then that pole should be within the polygon.  If points go counter-clockwise, then that pole should be outside the polygon.

org.apache.lucene.spatial3d.geom.GeoPolygonFactory#makeGeoPolygon(Lorg/apache/lucene/spatial3d/geom/PlanetModel;Ljava/util/List;Ljava/util/List;)Lorg/apache/lucene/spatial3d/geom/GeoPolygon;
  planetModel
    +c:
  pointList
    +d: is a list of the GeoPoints to build an arbitrary polygon out of.  If points go clockwise from a given pole, then that pole should be within the polygon.  If points go counter-clockwise, then that pole should be outside the polygon.
  holes
    +c:

org.apache.lucene.spatial3d.geom.GeoPolygonFactory#makeGeoPolygon(Lorg/apache/lucene/spatial3d/geom/PlanetModel;Ljava/util/List;Ljava/util/List;D)Lorg/apache/lucene/spatial3d/geom/GeoPolygon;
  planetModel
    +c:
  pointList
    +d: is a list of the GeoPoints to build an arbitrary polygon out of.  If points go clockwise from a given pole, then that pole should be within the polygon.  If points go counter-clockwise, then that pole should be outside the polygon.
  holes
    +c:.

org.apache.lucene.spatial3d.geom.GeoPolygonFactory#makeLargeGeoPolygon(Lorg/apache/lucene/spatial3d/geom/PlanetModel;Ljava/util/List;)Lorg/apache/lucene/spatial3d/geom/GeoPolygon;
  planetModel
    +c:

org.apache.lucene.spatial3d.geom.GeoPolygonFactory#generateGeoPolygon(Lorg/apache/lucene/spatial3d/geom/PlanetModel;Ljava/util/List;Ljava/util/List;Lorg/apache/lucene/spatial3d/geom/GeoPoint;Z)Lorg/apache/lucene/spatial3d/geom/GeoPolygon;
  holes
    +c:
  testPoint
    +c:

org.apache.lucene.spatial3d.geom.GeoPolygonFactory#buildPolygonShape(Lorg/apache/lucene/spatial3d/geom/GeoCompositePolygon;Lorg/apache/lucene/spatial3d/geom/GeoPolygonFactory$MutableBoolean;Lorg/apache/lucene/spatial3d/geom/PlanetModel;Ljava/util/List;Ljava/util/BitSet;IILorg/apache/lucene/spatial3d/geom/SidedPlane;Ljava/util/List;Lorg/apache/lucene/spatial3d/geom/GeoPoint;)Z
  seenConcave
    +c:
  holes
    +c:
  testPoint
    +d: is an (optional) test point, which will be used to determine if we are generating a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside of the generated polygon.  In this case, if the generated polygon is found to contain the point, the method exits early with a null return value. This only makes sense in the context of evaluating both possible choices and using logic to determine which result to use.  If the test point is supposed to be within the shape, then it must be outside of the complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the original shape.  Either way, we can figure out the right thing to use.
    +c:

org.apache.lucene.spatial3d.geom.Plane#recordBounds(Lorg/apache/lucene/spatial3d/geom/PlanetModel;Lorg/apache/lucene/spatial3d/geom/XYZBounds;[Lorg/apache/lucene/spatial3d/geom/Membership;)V
  planetModel
    +c:.

org.apache.lucene.spatial3d.geom.Plane#findArcDistancePoints(Lorg/apache/lucene/spatial3d/geom/PlanetModel;DLorg/apache/lucene/spatial3d/geom/GeoPoint;[Lorg/apache/lucene/spatial3d/geom/Membership;)[Lorg/apache/lucene/spatial3d/geom/GeoPoint;
  startPoint
    +c:"Start point is not on plane".

org.apache.lucene.spatial3d.geom.GeoPoint#<init>(DDDDDD)V
  lat
    +c:Latitude    is out of range: must range from -Math.PI/2 to Math.PI/2.
  lon
    +c:Longitude    is out of range: must range from -Math.PI to Math.PI.

org.apache.lucene.spatial3d.geom.GeoDegenerateVerticalLine#<init>(Lorg/apache/lucene/spatial3d/geom/PlanetModel;DDD)V
  topLat
    +c:"Top latitude out of range".
  bottomLat
    +c:"Bottom latitude out of range"."Top latitude less than bottom latitude".
  longitude
    +c:"Longitude out of range".

org.apache.lucene.search.spell.DirectSpellChecker#setMaxEdits(I)V
  maxEdits
    +c:"Invalid maxEdits".

org.apache.lucene.search.spell.DirectSpellChecker#setThresholdFrequency(F)V
  thresholdFrequency
    +c:"Fractional absolute document frequencies are not allowed".

org.apache.lucene.search.spell.DirectSpellChecker#setMaxQueryFrequency(F)V
  maxQueryFrequency
    +c:"Fractional absolute document frequencies are not allowed".

org.apache.lucene.search.spell.SpellChecker#suggestSimilar(Ljava/lang/String;IF)[Ljava/lang/String;
  accuracy
    +d: The minimum score a suggestion must have in order to qualify for inclusion in the results

org.apache.lucene.search.spell.SpellChecker#suggestSimilar(Ljava/lang/String;ILorg/apache/lucene/index/IndexReader;Ljava/lang/String;Lorg/apache/lucene/search/spell/SuggestMode;F)[Ljava/lang/String;
  ir
    +d: the indexReader of the user index (can be null see field param)
  accuracy
    +d: The minimum score a suggestion must have in order to qualify for inclusion in the results

org.apache.lucene.search.suggest.SortedInputIterator#decodePayload(Lorg/apache/lucene/util/BytesRef;Lorg/apache/lucene/store/ByteArrayDataInput;)Lorg/apache/lucene/util/BytesRef;
  tmpInput
    +c:

org.apache.lucene.search.suggest.analyzing.FuzzySuggester#<init>(Lorg/apache/lucene/store/Directory;Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/analysis/Analyzer;IIIZIZIIZ)V
  preservePositionIncrements
    +d: Whether position holes should appear in the automaton
  maxEdits
    +c:maxEdits must be between 0 and.
  nonFuzzyPrefix
    +c:nonFuzzyPrefix must not be >= 0 (got   ).
  minFuzzyLength
    +c:minFuzzyLength must not be >= 0 (got   ).

org.apache.lucene.search.suggest.analyzing.SuggestStopFilterFactory#<init>(Ljava/util/Map;)V
  args
    +c:Unknown parameters:.

org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester#<init>(Lorg/apache/lucene/store/Directory;Ljava/lang/String;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/analysis/Analyzer;IIIZ)V
  options
    +c:options should only contain EXACT_FIRST and PRESERVE_SEP; got.
  maxSurfaceFormsPerAnalyzedForm
    +c:maxSurfaceFormsPerAnalyzedForm must be > 0 and < 256 (got:   ).
  maxGraphExpansions
    +c:maxGraphExpansions must -1 (no limit) or > 0 (got:   ).
  preservePositionIncrements
    +d: Whether position holes should appear in the automata

org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester#build(Lorg/apache/lucene/search/suggest/InputIterator;)V
  iterator
    +c:"this suggester doesn't support contexts".

org.apache.lucene.search.suggest.analyzing.AnalyzingSuggester#lookup(Ljava/lang/CharSequence;Ljava/util/Set;ZI)Ljava/util/List;
  key
    +c:"lookup key cannot contain HOLE character U+001E; this character is reserved"."lookup key cannot contain unit separator character U+001F; this character is reserved".
  contexts
    +c:"this suggester doesn't support contexts".
  onlyMorePopular
    +c:"this suggester only works with onlyMorePopular=false".
  num
    +c:.

org.apache.lucene.search.suggest.analyzing.FSTUtil#intersectPrefixPaths(Lorg/apache/lucene/util/automaton/Automaton;Lorg/apache/lucene/util/fst/FST;)Ljava/util/List;
  a
    +c:.
  fst
    +c:

org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/analysis/Analyzer;IZ)V
  commitOnBuild
    +d: Call commit after the index has finished building. This would persist the suggester index to disk and future instances of this suggester can use this pre-built dictionary.

org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/analysis/Analyzer;IZZZ)V
  commitOnBuild
    +d: Call commit after the index has finished building. This would persist the suggester index to disk and future instances of this suggester can use this pre-built dictionary.

org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/analysis/Analyzer;IZZZZ)V
  minPrefixChars
    +c:minPrefixChars must be >= 0; got:.
  commitOnBuild
    +d: Call commit after the index has finished building. This would persist the suggester index to disk and future instances of this suggester can use this pre-built dictionary.

org.apache.lucene.search.suggest.analyzing.AnalyzingInfixSuggester#lookup(Ljava/lang/CharSequence;Lorg/apache/lucene/search/BooleanQuery;IZZ)Ljava/util/List;
  allTermsRequired
    +d: all searched terms must match or not

org.apache.lucene.search.suggest.analyzing.FreeTextSuggester#<init>(Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/analysis/Analyzer;IB)V
  grams
    +c:"grams must be >= 1".
  separator
    +c:"separator must be simple ascii character".

org.apache.lucene.search.suggest.analyzing.FreeTextSuggester#build(Lorg/apache/lucene/search/suggest/InputIterator;)V
  iterator
    +c:

org.apache.lucene.search.suggest.analyzing.FreeTextSuggester#build(Lorg/apache/lucene/search/suggest/InputIterator;D)V
  iterator
    +c:"this suggester doesn't support payloads"."this suggester doesn't support contexts".

org.apache.lucene.search.suggest.analyzing.FreeTextSuggester#lookup(Ljava/lang/CharSequence;Ljava/util/Set;ZI)Ljava/util/List;
  contexts
    +c:

org.apache.lucene.search.suggest.analyzing.FreeTextSuggester#lookup(Ljava/lang/CharSequence;Ljava/util/Set;I)Ljava/util/List;
  contexts
    +c:"this suggester doesn't support contexts".

org.apache.lucene.search.suggest.analyzing.BlendedInfixSuggester#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/analysis/Analyzer;ILorg/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester$BlenderType;IZ)V
  commitOnBuild
    +d: Call commit after the index has finished building. This would persist the suggester index to disk and future instances of this suggester can use this pre-built dictionary.

org.apache.lucene.search.suggest.analyzing.BlendedInfixSuggester#<init>(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/analysis/Analyzer;Lorg/apache/lucene/analysis/Analyzer;ILorg/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester$BlenderType;ILjava/lang/Double;ZZZ)V
  commitOnBuild
    +d: Call commit after the index has finished building. This would persist the suggester index to disk and future instances of this suggester can use this pre-built dictionary.

org.apache.lucene.search.suggest.document.ContextQuery#<init>(Lorg/apache/lucene/search/suggest/document/CompletionQuery;)V
  query
    +c:'query' parameter must not be of type.

org.apache.lucene.search.suggest.document.ContextQuery#addContext(Ljava/lang/CharSequence;)V
  context
    +c:

org.apache.lucene.search.suggest.document.ContextQuery#addContext(Ljava/lang/CharSequence;F)V
  context
    +c:
  boost
    +c:

org.apache.lucene.search.suggest.document.ContextQuery#addContext(Ljava/lang/CharSequence;FZ)V
  context
    +c:Illegal value [  ] UTF-16 codepoint [0x       ] at position     is a reserved character.
  boost
    +c:"'boost' must be >= 0".

org.apache.lucene.search.suggest.document.SuggestField#<init>(Ljava/lang/String;Ljava/lang/String;I)V
  value
    +c:"value must have a length > 0".Illegal input [  ] UTF-16 codepoint [0x       ] at position     is a reserved character.
  weight
    +c:"weight must be >= 0".

org.apache.lucene.search.suggest.document.ContextSuggestField#validate(Ljava/lang/CharSequence;)V
  value
    +c:Illegal value [  ] UTF-16 codepoint [0x       ] at position     is a reserved character.

org.apache.lucene.search.suggest.document.CompletionScorer#score(Lorg/apache/lucene/search/LeafCollector;Lorg/apache/lucene/util/Bits;II)I
  collector
    +c:"collector is not of type TopSuggestDocsCollector".

org.apache.lucene.search.suggest.document.NRTSuggester#encode(J)J
  input
    +c:cannot encode value:.

org.apache.lucene.search.suggest.document.NRTSuggester#decode(J)J
  output
    +c:.

org.apache.lucene.search.suggest.document.TopSuggestDocsCollector#<init>(IZ)V
  num
    +c:"'num' must be > 0".

org.apache.lucene.search.suggest.fst.FSTCompletionLookup#build(Lorg/apache/lucene/search/suggest/InputIterator;)V
  iterator
    +c:"this suggester doesn't support payloads"."this suggester doesn't support contexts".

org.apache.lucene.search.suggest.fst.FSTCompletionLookup#encodeWeight(J)I
  value
    +c:cannot encode value:.

org.apache.lucene.search.suggest.fst.FSTCompletionLookup#lookup(Ljava/lang/CharSequence;Ljava/util/Set;ZI)Ljava/util/List;
  contexts
    +c:"this suggester doesn't support contexts".

org.apache.lucene.search.suggest.fst.WFSTCompletionLookup#build(Lorg/apache/lucene/search/suggest/InputIterator;)V
  iterator
    +c:"this suggester doesn't support payloads"."this suggester doesn't support contexts".

org.apache.lucene.search.suggest.fst.WFSTCompletionLookup#lookup(Ljava/lang/CharSequence;Ljava/util/Set;ZI)Ljava/util/List;
  contexts
    +c:"this suggester doesn't support contexts".
  onlyMorePopular
    +c:"this suggester only works with onlyMorePopular=false".
  num
    +c:.

org.apache.lucene.search.suggest.fst.FSTCompletionBuilder#<init>(ILorg/apache/lucene/search/suggest/fst/BytesRefSorter;I)V
  buckets
    +d: The number of buckets for weight discretization. Buckets are used in #add(BytesRef,int) and must be smaller than the number given here.
    +c:Buckets must be >= 1 and <= 255:.
  sorter
    +c:"BytesRefSorter must not be null.".

org.apache.lucene.search.suggest.fst.FSTCompletionBuilder#add(Lorg/apache/lucene/util/BytesRef;I)V
  bucket
    +d: The bucket to place this suggestion in. Must be non-negative and smaller than the number of buckets passed in the constructor. Higher numbers indicate suggestions that should be presented before suggestions placed in smaller buckets.
    +c:Bucket outside of the allowed range [0,   ):.

org.apache.lucene.search.suggest.jaspell.JaspellTernarySearchTrie#getOrCreateNode(Ljava/lang/CharSequence;)Lorg/apache/lucene/search/suggest/jaspell/JaspellTernarySearchTrie$TSTNode;
  key
    +c:"attempt to get or create node with null key"."attempt to get or create node with key of zero length".

org.apache.lucene.search.suggest.jaspell.JaspellTernarySearchTrie#setMatchAlmostDiff(I)V
  diff
    +d: The number of characters by which words can differ from target word.

org.apache.lucene.search.suggest.jaspell.JaspellLookup#build(Lorg/apache/lucene/search/suggest/InputIterator;)V
  iterator
    +c:"this suggester doesn't support payloads"."this suggester doesn't support contexts".

org.apache.lucene.search.suggest.jaspell.JaspellLookup#lookup(Ljava/lang/CharSequence;Ljava/util/Set;ZI)Ljava/util/List;
  contexts
    +c:"this suggester doesn't support contexts".

org.apache.lucene.search.suggest.tst.TSTLookup#build(Lorg/apache/lucene/search/suggest/InputIterator;)V
  iterator
    +c:"this suggester doesn't support payloads"."this suggester doesn't support contexts".

org.apache.lucene.search.suggest.tst.TSTLookup#lookup(Ljava/lang/CharSequence;Ljava/util/Set;ZI)Ljava/util/List;
  contexts
    +c:"this suggester doesn't support contexts".

org.apache.lucene.analysis.MockFixedLengthPayloadFilter#<init>(Ljava/util/Random;Lorg/apache/lucene/analysis/TokenStream;I)V
  length
    +c:"length must be >= 0".

org.apache.lucene.analysis.MockTokenizer#fail(Ljava/lang/String;)V
  message
    +c:.

org.apache.lucene.analysis.MockTokenizer#failAlways(Ljava/lang/String;)V
  message
    +c:.

org.apache.lucene.analysis.MockCharFilter#<init>(Ljava/io/Reader;I)V
  remainder
    +c:invalid remainder parameter (must be 0..10):.

org.apache.lucene.analysis.MockCharFilter#correct(I)I
  currentOff
    +c:.

org.apache.lucene.analysis.MockAnalyzer#<init>(Ljava/util/Random;Lorg/apache/lucene/util/automaton/CharacterRunAutomaton;ZLorg/apache/lucene/util/automaton/CharacterRunAutomaton;)V
  runAutomaton
    +d: DFA describing how tokenization should happen (e.g. [a-zA-Z]+)
  filter
    +d: DFA describing how terms should be filtered (set of stopwords, etc)

org.apache.lucene.analysis.MockReaderWrapper#read([CII)I
  cbuf
    +c:
  off
    +c:
  len
    +c:

org.apache.lucene.analysis.VocabularyAssert#assertVocabulary(Lorg/apache/lucene/analysis/Analyzer;Ljava/nio/file/Path;Ljava/lang/String;Ljava/lang/String;)V
  a
    +c:.

org.apache.lucene.analysis.VocabularyAssert#assertVocabulary(Lorg/apache/lucene/analysis/Analyzer;Ljava/nio/file/Path;Ljava/lang/String;)V
  a
    +c:.

org.apache.lucene.codecs.asserting.AssertingDocValuesFormat#fieldsConsumer(Lorg/apache/lucene/index/SegmentWriteState;)Lorg/apache/lucene/codecs/DocValuesConsumer;
  state
    +c:

org.apache.lucene.codecs.asserting.AssertingDocValuesFormat#fieldsProducer(Lorg/apache/lucene/index/SegmentReadState;)Lorg/apache/lucene/codecs/DocValuesProducer;
  state
    +c:.

org.apache.lucene.codecs.asserting.AssertingNormsFormat#normsConsumer(Lorg/apache/lucene/index/SegmentWriteState;)Lorg/apache/lucene/codecs/NormsConsumer;
  state
    +c:

org.apache.lucene.codecs.asserting.AssertingNormsFormat#normsProducer(Lorg/apache/lucene/index/SegmentReadState;)Lorg/apache/lucene/codecs/NormsProducer;
  state
    +c:.

org.apache.lucene.codecs.asserting.AssertingLiveDocsFormat#readLiveDocs(Lorg/apache/lucene/store/Directory;Lorg/apache/lucene/index/SegmentCommitInfo;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/util/Bits;
  dir
    +c:
  info
    +c:.
  context
    +c:

org.apache.lucene.codecs.mockrandom.MockRandomPostingsFormat#<init>(Ljava/util/Random;)V
  random
    +c:"Please use MockRandomPostingsFormat(Random)".

org.apache.lucene.geo.GeoTestUtil#containsSlowly(Lorg/apache/lucene/geo/Polygon;DD)Z
  polygon
    +c:"this testing method does not support holes".

org.apache.lucene.index.AssertingLeafReader#<init>(Lorg/apache/lucene/index/LeafReader;)V
  in
    +c:....

org.apache.lucene.index.AssertingLeafReader#getNumericDocValues(Ljava/lang/String;)Lorg/apache/lucene/index/NumericDocValues;
  field
    +c:

org.apache.lucene.index.AssertingLeafReader#getBinaryDocValues(Ljava/lang/String;)Lorg/apache/lucene/index/BinaryDocValues;
  field
    +c:

org.apache.lucene.index.AssertingLeafReader#getSortedDocValues(Ljava/lang/String;)Lorg/apache/lucene/index/SortedDocValues;
  field
    +c:

org.apache.lucene.index.AssertingLeafReader#getSortedNumericDocValues(Ljava/lang/String;)Lorg/apache/lucene/index/SortedNumericDocValues;
  field
    +c:

org.apache.lucene.index.AssertingLeafReader#getSortedSetDocValues(Ljava/lang/String;)Lorg/apache/lucene/index/SortedSetDocValues;
  field
    +c:

org.apache.lucene.index.AssertingLeafReader#getNormValues(Ljava/lang/String;)Lorg/apache/lucene/index/NumericDocValues;
  field
    +c:

org.apache.lucene.index.PerThreadPKLookup#lookup(Lorg/apache/lucene/util/BytesRef;)I
  id
    +c:

org.apache.lucene.index.MockRandomMergePolicy#findForcedMerges(Lorg/apache/lucene/index/SegmentInfos;ILjava/util/Map;Lorg/apache/lucene/index/MergePolicy$MergeContext;)Lorg/apache/lucene/index/MergePolicy$MergeSpecification;
  segmentsToMerge
    +c:.

org.apache.lucene.mockfile.WindowsFS#onClose(Ljava/nio/file/Path;Ljava/lang/Object;)V
  path
    +c:.

org.apache.lucene.mockfile.WindowsFS#delete(Ljava/nio/file/Path;)V
  path
    +c:

org.apache.lucene.mockfile.WindowsFS#deleteIfExists(Ljava/nio/file/Path;)Z
  path
    +c:

org.apache.lucene.mockfile.FilterPath#toDelegate(Ljava/nio/file/Path;)Ljava/nio/file/Path;
  path
    +c:mismatch, expected: FilterPath, got:.

org.apache.lucene.mockfile.HandleLimitFS#onOpen(Ljava/nio/file/Path;Ljava/lang/Object;)V
  path
    +c:"Too many open files".

org.apache.lucene.mockfile.VirusCheckingFS#delete(Ljava/nio/file/Path;)V
  path
    +c:VirusCheckingFS is randomly refusing to delete file \  \.

org.apache.lucene.search.CheckHits#checkHitCollector(Ljava/util/Random;Lorg/apache/lucene/search/Query;Ljava/lang/String;Lorg/apache/lucene/search/IndexSearcher;[I)V
  defaultFieldName
    +c:Simple:.Wrap Reader     :.

org.apache.lucene.search.CheckHits#checkDocIds(Ljava/lang/String;[I[Lorg/apache/lucene/search/ScoreDoc;)V
  hits
    +c:nr of hits.doc nrs for hit.

org.apache.lucene.search.CheckHits#checkHitsQuery(Lorg/apache/lucene/search/Query;[Lorg/apache/lucene/search/ScoreDoc;[Lorg/apache/lucene/search/ScoreDoc;[I)V
  query
    +c:
  hits1
    +c:

org.apache.lucene.search.CheckHits#checkEqual(Lorg/apache/lucene/search/Query;[Lorg/apache/lucene/search/ScoreDoc;[Lorg/apache/lucene/search/ScoreDoc;)V
  query
    +c:Hit     docnumbers don't match\n    for query:.Hit    , doc nrs       and      \nunequal       :      \n           and:      \nfor query:.
  hits1
    +c:Unequal lengths: hits1=   ,hits2=.

org.apache.lucene.search.CheckHits#verifyExplanation(Ljava/lang/String;IFZLorg/apache/lucene/search/Explanation;)V
  doc
    +c:: score(doc=  )=   != explanationScore=    Explanation:.
  score
    +c:.
  expl
    +c:: multi valued explanation description=\   \ must be 'max of plus x times others', 'computed as x from:' or end with 'product of'  or 'sum of:' or 'max of:' -.: actual subDetails combined==        != value=    Explanation:.

org.apache.lucene.search.CheckHits#checkTopScores(Ljava/util/Random;Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/IndexSearcher;)V
  query
    +c:

org.apache.lucene.search.QueryUtils#checkUnequal(Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/Query;)V
  q1
    +c:equal to.
  q2
    +c:equal to.

org.apache.lucene.search.QueryUtils#check(Ljava/util/Random;Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/IndexSearcher;)V
  s
    +c:

org.apache.lucene.search.QueryUtils#check(Ljava/util/Random;Lorg/apache/lucene/search/Query;Lorg/apache/lucene/search/IndexSearcher;Z)V
  s
    +c:
  wrap
    +c:

org.apache.lucene.search.AssertingQuery#createWeight(Lorg/apache/lucene/search/IndexSearcher;Lorg/apache/lucene/search/ScoreMode;F)Lorg/apache/lucene/search/Weight;
  boost
    +c:.

org.apache.lucene.search.AssertingScorer#setMinCompetitiveScore(F)V
  score
    +c:..

org.apache.lucene.search.AssertingScorer#advanceShallow(I)I
  target
    +c:...

org.apache.lucene.search.AssertingScorer#getMaxScore(I)F
  upTo
    +c:.

org.apache.lucene.search.AssertingIndexSearcher#search(Ljava/util/List;Lorg/apache/lucene/search/Weight;Lorg/apache/lucene/search/Collector;)V
  weight
    +c:.
  collector
    +c:.

org.apache.lucene.search.similarities.AssertingSimilarity#computeNorm(Lorg/apache/lucene/index/FieldInvertState;)J
  state
    +c:..........

org.apache.lucene.search.similarities.AssertingSimilarity#scorer(FLorg/apache/lucene/search/CollectionStatistics;[Lorg/apache/lucene/search/TermStatistics;)Lorg/apache/lucene/search/similarities/Similarity$SimScorer;
  boost
    +c:.
  collectionStats
    +c:.
  termStats
    +c:.

org.apache.lucene.search.similarities.RandomSimilarity#get(Ljava/lang/String;)Lorg/apache/lucene/search/similarities/Similarity;
  field
    +c:.

org.apache.lucene.search.spans.SpanTestUtil#assertNext(Lorg/apache/lucene/search/spans/Spans;III)V
  spans
    +c:"nextStartPosition of previous doc"."endPosition of previous doc"."first startPosition"."first endPosition".
  doc
    +c:"docId"."nextDoc".
  start
    +c:"nextStartPosition"."startPosition".
  end
    +c:"endPosition".

org.apache.lucene.search.spans.AssertingSpanQuery#equals(Ljava/lang/Object;)Z
  o
    +c:..

org.apache.lucene.store.MockDirectoryWrapper#maybeThrowIOExceptionOnOpen(Ljava/lang/String;)V
  name
    +c:a random IOException (  ).

org.apache.lucene.store.MockDirectoryWrapper#createOutput(Ljava/lang/String;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/store/IndexOutput;
  name
    +c:File \  \ was already written to.MockDirectoryWrapper: file \  \ is still open: cannot overwrite.

org.apache.lucene.store.MockDirectoryWrapper#openInput(Ljava/lang/String;Lorg/apache/lucene/store/IOContext;)Lorg/apache/lucene/store/IndexInput;
  name
    +c:

org.apache.lucene.store.MockIndexOutputWrapper#checkDiskFull([BILorg/apache/lucene/store/DataInput;J)V
  len
    +c:fake disk full at   bytes when writing   (file length=  ; wrote   of   bytes  ).

org.apache.lucene.store.MockIndexInputWrapper#<init>(Lorg/apache/lucene/store/MockDirectoryWrapper;Ljava/lang/String;Lorg/apache/lucene/store/IndexInput;Lorg/apache/lucene/store/MockIndexInputWrapper;)V
  parent
    +c:.

org.apache.lucene.util.TestRuleStoreClassName#apply(Lorg/junit/runners/model/Statement;Lorg/junit/runner/Description;)Lorg/junit/runners/model/Statement;
  d
    +c:"This is a @ClassRule (applies to suites only).".

org.apache.lucene.util.TestRuleIgnoreAfterMaxFailures#<init>(I)V
  maxFailures
    +d: The number of failures after which all tests are ignored. Must be greater or equal 1.
    +c:maxFailures must be >= 1:.

org.apache.lucene.util.ThrottledIndexOutput#<init>(IJJJJLorg/apache/lucene/store/IndexOutput;)V
  bytesPerSecond
    +c:.

org.apache.lucene.util.TestRuleRestoreSystemProperties#<init>([Ljava/lang/String;)V
  propertyNames
    +c:"No properties to restore? Odd.".

org.apache.lucene.util.FailOnNonBulkMergesInfoStream#message(Ljava/lang/String;Ljava/lang/String;)V
  message
    +c:.

org.apache.lucene.util.TestUtil#checkIterator(Ljava/util/Iterator;JZ)V
  iterator
    +c:broken iterator (supports remove):..broken iterator (allows next() when hasNext==false).
  expectedSize
    +c:
  allowNull
    +c:.

org.apache.lucene.util.TestUtil#checkIterator(Ljava/util/Iterator;)V
  iterator
    +c:broken iterator (supports remove):.broken iterator (allows next() when hasNext==false).

org.apache.lucene.util.TestUtil#checkReadOnly(Ljava/util/Collection;)V
  coll
    +c:broken collection, reported size is       but iterator has      elements:.broken collection (supports remove):.broken collection (supports add):.broken collection (supports addAll):.

org.apache.lucene.util.TestUtil#checkReader(Lorg/apache/lucene/index/IndexReader;)V
  reader
    +c:

org.apache.lucene.util.TestUtil#checkReader(Lorg/apache/lucene/index/LeafReader;Z)V
  reader
    +c:

org.apache.lucene.util.TestUtil#nextLong(Ljava/util/Random;JJ)J
  start
    +c:.
  end
    +c:.

org.apache.lucene.util.TestUtil#getPostingsFormatWithOrds(Ljava/util/Random;)Lorg/apache/lucene/codecs/PostingsFormat;
  r
    +c:.

org.apache.lucene.util.TestUtil#assertConsistent(Lorg/apache/lucene/search/TopDocs;Lorg/apache/lucene/search/TopDocs;)V
  actual
    +c:"wrong total hits"."wrong total hits"."wrong total hits"."wrong total hits"."wrong hit count".

org.apache.lucene.util.TestUtil#randomAnalysisString(Ljava/util/Random;IZ)Ljava/lang/String;
  maxLength
    +c:.
  simple
    +c:

org.apache.lucene.util.TestUtil#randomSubString(Ljava/util/Random;IZ)Ljava/lang/String;
  wordLength
    +c:
  simple
    +c:

org.apache.lucene.util.NullInfoStream#message(Ljava/lang/String;Ljava/lang/String;)V
  component
    +c:.
  message
    +c:.

org.apache.lucene.util.NullInfoStream#isEnabled(Ljava/lang/String;)Z
  component
    +c:.

org.apache.lucene.util.automaton.AutomatonTestUtil#assertNoDetachedStates(Lorg/apache/lucene/util/automaton/Automaton;)V
  a
    +c:.

org.apache.lucene.util.automaton.AutomatonTestUtil#isDeterministicSlow(Lorg/apache/lucene/util/automaton/Automaton;)Z
  a
    +c:..

